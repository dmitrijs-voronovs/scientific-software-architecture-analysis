id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:42,Deployability,update,update,42,"/// Commute a two-address instruction and update the basic block, distance map,; /// and live variables if needed. Return true if it is successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:94,Modifiability,variab,variables,94,"/// Commute a two-address instruction and update the basic block, distance map,; /// and live variables if needed. Return true if it is successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update source register map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:183,Safety,avoid,avoid,183,"// Look for situations like this:; // %reg1024 = MOV r1; // %reg1025 = MOV r0; // %reg1026 = ADD %reg1024, %reg1025; // r2 = MOV %reg1026; // Turn ADD into a 3-address instruction to avoid a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:53,Deployability,update,update,53,"// If the old instruction is debug value tracked, an update is required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update source and destination register maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:44,Deployability,update,update,44,"/// Scan forward recursively for only uses, update maps if the use is a copy or; /// a two-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:266,Performance,optimiz,optimizations,266,"/// If the specified instruction is not yet processed, process it if it's a; /// copy. For a copy instruction, we find the physical registers the; /// source and destination registers might be mapped to. These are kept in; /// point-to maps used to determine future optimizations. e.g.; /// v1024 = mov r0; /// v1025 = mov r1; /// v1026 = add v1024, v1025; /// r1 = mov r1026; /// If 'add' is a two-address instruction, v1024, v1026 are both potentially; /// coalesced to r0 (from the input side). v1025 is mapped to r1. v1026 is; /// potentially joined with r1 on the output side. It's worthwhile to commute; /// 'add' to eliminate a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:47,Availability,avail,available,47,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:88,Energy Efficiency,efficient,efficiently,88,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:33,Performance,load,load,33,// Must be created from unfolded load. Don't waste time trying this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:35,Availability,down,down,35,// Move the copies connected to MI down as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:42,Integrability,depend,dependencies,42,// Check if the reschedule will not break dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:29,Energy Efficiency,reduce,reduce,29,// FIXME: Arbitrary limit to reduce compile time cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:46,Deployability,update,update,46,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:17,Modifiability,extend,extend,17,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:12,Energy Efficiency,schedul,schedule,12,// We can't schedule across a use of the register in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:15,Modifiability,variab,variables,15,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:26,Energy Efficiency,schedul,scheduling,26,/// Return true if the re-scheduling will put the given instruction too close; /// to the defs of its register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:111,Integrability,depend,dependencies,111,/// Return true if the re-scheduling will put the given instruction too close; /// to the defs of its register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:47,Availability,avail,available,47,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:88,Energy Efficiency,efficient,efficiently,88,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:33,Performance,load,load,33,// Must be created from unfolded load. Don't waste time trying this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:29,Energy Efficiency,reduce,reduce,29,// FIXME: Arbitrary limit to reduce compile time cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:46,Deployability,update,update,46,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:17,Modifiability,extend,extend,17,// Don't want to extend other live ranges and update kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:12,Energy Efficiency,schedul,schedule,12,// We can't schedule across a use of the register in question.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:15,Modifiability,variab,variables,15,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:208,Modifiability,variab,variables,208,"// The call of findCommutedOpIndices below only checks if BaseOpIdx; // and OtherOpIdx are commutable, it does not really search for; // other commutable operands and does not change the values of passed; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:53,Deployability,update,update,53,"// There might be more than two commutable operands, update BaseOp and; // continue scanning.; // FIXME: This assumes that the new instruction's operands are in the; // same positions and were simply swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:193,Usability,simpl,simply,193,"// There might be more than two commutable operands, update BaseOp and; // continue scanning.; // FIXME: This assumes that the new instruction's operands are in the; // same positions and were simply swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:55,Energy Efficiency,reduce,reduced,55,// Resamples OpsNum in case the number of operands was reduced. This; // happens with X86.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:129,Modifiability,variab,variable,129,"// If the instruction is convertible to 3 Addr, instead; // of returning try 3 Addr transformation aggressively and; // use this variable to check later. Because it might be better.; // For example, we can just use `leal (%rsi,%rdi), %eax` and `ret`; // instead of the following code.; // addl %esi, %edi; // movl %edi, %eax; // ret",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:75,Energy Efficiency,schedul,schedule,75,"// If there is one more use of regB later in the same MBB, consider; // re-schedule this MI below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:70,Safety,avoid,avoid,70,"// If we commuted, regB may have changed so we should re-sample it to avoid; // confusing the three address conversion below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:75,Energy Efficiency,schedul,schedule,75,"// If there is one more use of regB later in the same MBB, consider; // re-schedule it before this MI if it's legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:239,Energy Efficiency,schedul,schedule,239,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:36,Performance,load,load,36,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:79,Performance,load,load,79,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:250,Performance,load,load,250,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:90,Safety,avoid,avoid,90,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:18,Performance,load,load,18,// Determine if a load can be unfolded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:14,Performance,load,load,14,// Unfold the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:7,Performance,load,load,7,"// The load was previously folded, so this is the only use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:107,Testability,log,logic,107,"// Tentatively insert the instructions into the block so that they; // look ""normal"" to the transformation logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:58,Performance,load,load,58,"// Transform the instruction, now that it no longer has a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:60,Modifiability,Rewrite,Rewrite,60,"// Collect tied operands of MI that need to be handled.; // Rewrite trivial cases immediately.; // Return true if any tied operands where found, including the trivial ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:45,Modifiability,rewrite,rewrite,45,// Deal with undef uses immediately - simply rewrite the src operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:38,Usability,simpl,simply,38,// Deal with undef uses immediately - simply rewrite the src operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update DistanceMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:24,Testability,assert,asserts,24,"// The getMatchingSuper asserts guarantee that the register class projected; // by SubRegB is compatible with RegA with no subregister. So regardless of; // whether the dest oper writes a subreg, the source oper should not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update live variables for regB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:15,Modifiability,variab,variables,15,// Update live variables for regB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:258,Availability,failure,failures,258,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:165,Safety,Safe,SafepointIRVerifier,165,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:242,Safety,avoid,avoid,242,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:248,Testability,assert,assertion,248,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce two-address instructions to two operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:11,Performance,optimiz,optimizations,11,// Disable optimizations if requested. We cannot skip the whole pass as some; // fixups are necessary for correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:18,Modifiability,rewrite,rewrite,18,// This pass will rewrite the tied-def to meet the RegConstraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:61,Availability,down,down,61,// The tied operands have been eliminated or shifted further down; // the block to ease elimination. Continue processing with 'nmi'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite INSERT_SUBREG as COPY now that we no longer need SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Usability,Clear,Clear,3,// Clear TiedOperands here instead of at the top of the loop; // since most instructions do not have tied operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:3,Deployability,Update,Update,3,// Update LiveVariables' kill info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:677,Integrability,wrap,wrapping,677,"//===----- TypePromotion.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is an opcode based type promotion pass for small types that would; /// otherwise be promoted during legalisation. This works around the limitations; /// of selection dag for cyclic regions. The search begins from icmp; /// instructions operands where a tree, consisting of non-wrapping or safe; /// wrapping instructions, is built, checked and promoted if possible.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:699,Integrability,wrap,wrapping,699,"//===----- TypePromotion.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is an opcode based type promotion pass for small types that would; /// otherwise be promoted during legalisation. This works around the limitations; /// of selection dag for cyclic regions. The search begins from icmp; /// instructions operands where a tree, consisting of non-wrapping or safe; /// wrapping instructions, is built, checked and promoted if possible.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:689,Safety,safe,safe,689,"//===----- TypePromotion.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is an opcode based type promotion pass for small types that would; /// otherwise be promoted during legalisation. This works around the limitations; /// of selection dag for cyclic regions. The search begins from icmp; /// instructions operands where a tree, consisting of non-wrapping or safe; /// wrapping instructions, is built, checked and promoted if possible.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:460,Availability,mask,masked,460,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:696,Availability,mask,masking,696,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:43,Energy Efficiency,efficient,efficient,43,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:1696,Performance,perform,perform,1696,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:645,Usability,ux,uxtb,645,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:756,Usability,UX,UXTB,756,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:64,Integrability,wrap,wrapping,64,"// Is I an add or a sub, which isn't marked as nuw, but where a wrapping; // result won't affect the computation?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:76,Integrability,wrap,wrapping,76,"// Is V an instruction thats result can trivially promoted, or has safe; // wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:67,Safety,safe,safe,67,"// Is V an instruction thats result can trivially promoted, or has safe; // wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:273,Performance,load,loads,273,"/// Return true if the given value is a source in the use-def chain, producing; /// a narrow 'TypeSize' value. These values will be zext to start the promotion; /// of the tree to i32. We guarantee that these won't populate the upper bits; /// of the register. ZExt on the loads will be free, and the same for call; /// return values because we only accept ones that guarantee a zeroext ret val.; /// Many arguments will have the zeroext attribute too, so those would be free; /// too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:47,Integrability,wrap,wrap,47,/// Return whether this instruction can safely wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:40,Safety,safe,safely,40,/// Return whether this instruction can safely wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:32,Integrability,wrap,wrapping,32,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:146,Integrability,wrap,wrapping,146,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:202,Integrability,wrap,wrapping,202,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:276,Integrability,wrap,wrapping,276,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:407,Integrability,wrap,wrap,407,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:473,Integrability,wrap,wrap,473,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:886,Integrability,wrap,wrap,886,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:629,Modifiability,extend,extending,629,"// We can support a potentially wrapping instruction (I) if:; // - It is only used by an unsigned icmp.; // - The icmp uses a constant.; // - The wrapping value (I) is decreasing, i.e would underflow - wrapping; // around zero to become a larger number than before.; // - The wrapping instruction (I) also uses a constant.; //; // We can then use the two constants to calculate whether the result would; // wrap in respect to itself in the original bitwidth. If it doesn't wrap,; // just underflows the range, the icmp would give the same result whether the; // result has been truncated or not. We calculate this by:; // - Zero extending both constants, if needed, to RegisterBitWidth.; // - Take the absolute value of I's constant, adding this to the icmp const.; // - Check that this value is not out of range for small type. If it is, it; // means that it has underflowed enough to wrap around the icmp constant.; //; // For example:; //; // %sub = sub i8 %a, 2; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -2 == FE == 254; // But if this is evalulated as a i32; // %sub = -2 == FF FF FF FE == 4294967294; // So the unsigned compares (i8 and i32) would not yield the same result.; //; // Another way to look at it is:; // %a - 2 <= 254; // %a + 2 <= 254 + 2; // %a <= 256; // And we can't represent 256 in the i8 format, so we don't support it.; //; // Whereas:; //; // %sub i8 %a, 1; // %cmp = icmp ule i8 %sub, 254; //; // If %a = 0, %sub = -1 == FF == 255; // As i32:; // %sub = -1 == FF FF FF FF == 4294967295; //; // In this case, the unsigned compare results would be the same and this; // would also be true for ult, uge and ugt:; // - (255 < 254) == (0xFFFFFFFF < 254) == false; // - (255 <= 254) == (0xFFFFFFFF <= 254) == false; // - (255 > 254) == (0xFFFFFFFF > 254) == true; // - (255 >= 254) == (0xFFFFFFFF >= 254) == true; //; // To demonstrate why we can't handle increasing values:; //; // %add = add i8 %a, 2; // %cmp = icmp ult i8 %add, 127; //; // If %a = 254, %add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:104,Modifiability,extend,extending,104,/// Return whether we can safely mutate V's type to ExtTy without having to be; /// concerned with zero extending or truncation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:26,Safety,safe,safely,26,/// Return whether we can safely mutate V's type to ExtTy without having to be; /// concerned with zero extending or truncation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:15,Modifiability,extend,extending,15,"// Now, insert extending instructions between the sources and their users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:156,Modifiability,extend,extend,156,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:236,Modifiability,extend,extend,236,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:75,Safety,Safe,SafeWrap,75,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:92,Safety,Safe,SafeWrap,92,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:35,Availability,redundant,redundant,35,"// Some zexts will now have become redundant, along with their trunc; // operands, so remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:35,Safety,redund,redundant,35,"// Some zexts will now have become redundant, along with their trunc; // operands, so remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:3,Performance,Cache,Cache,3,// Cache original types of the values that will likely need truncating,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:53,Availability,mask,masks,53,"// Convert any truncs, that aren't sources, into AND masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:80,Usability,clear,clear,80,"// Finally, remove unecessary zexts and truncs, delete old instructions and; // clear the data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:7,Performance,optimiz,optimizations,7,"// DAG optimizations should be able to handle these cases better, especially; // for function arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:560,Performance,perform,performs,560,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:409,Usability,simpl,simple,409,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:431,Usability,Simpl,SimplifyCFG,431,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:571,Usability,simpl,simple,571,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:3,Testability,Test,Test,3,// Test for deadness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:3,Deployability,Update,Update,3,// Update dominator and loop info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:156,Usability,simpl,simply,156,// The input register to the PHI has a subregister or it can't be; // constrained to the proper register class or it is undef:; // insert a COPY instead of simply replacing the output; // with the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp:169,Safety,abort,abort,169,"/// getTypeForEVT - This method returns an LLVM type corresponding to the; /// specified EVT. For integer types, this returns an unsigned type. Note; /// that this will abort for types that cannot be represented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:482,Integrability,interface,interface,482,"//===- llvm/CodeGen/VirtRegMap.cpp - Virtual Register Map -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the VirtRegMap class.; //; // It also contains implementations of the Spiller interface, which, given a; // virtual register map and a machine function, eliminates all virtual; // references by replacing them with physical register references - adding spill; // code as necessary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:366,Deployability,update,updates,366,//===----------------------------------------------------------------------===//; // VirtRegRewriter; //===----------------------------------------------------------------------===//; //; // The VirtRegRewriter is the last of the register allocator passes.; // It rewrites virtual registers to physical registers as specified in the; // VirtRegMap analysis. It also updates live-in information on basic blocks; // according to LiveIntervals.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:264,Modifiability,rewrite,rewrites,264,//===----------------------------------------------------------------------===//; // VirtRegRewriter; //===----------------------------------------------------------------------===//; //; // The VirtRegRewriter is the last of the register allocator passes.; // It rewrites virtual registers to physical registers as specified in the; // VirtRegMap analysis. It also updates live-in information on basic blocks; // according to LiveIntervals.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:64,Usability,Clear,ClearVirtRegs,64,// Write out new DBG_VALUE instructions.; // We only do this if ClearVirtRegs is specified since this should be the; // final run of the pass and we don't want to emit them multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:123,Deployability,release,release,123,// All machine operands and other references to virtual registers have been; // replaced. Remove the virtual registers and release all the transient data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:93,Energy Efficiency,allocate,allocated,93,// There may be no physical register assigned if only some register; // classes were already allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:99,Safety,detect,detect,99,// This code is only meant to handle reading undefined subregisters which; // we couldn't properly detect before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:118,Deployability,update,update,118,"// We may have deferred allocation of the virtual register, and the rewrite; // regs code doesn't handle the liveness update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:68,Modifiability,rewrite,rewrite,68,"// We may have deferred allocation of the virtual register, and the rewrite; // regs code doesn't handle the liveness update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:213,Deployability,update,update,213,/// The liverange splitting logic sometimes produces bundles of copies when; /// subregisters are involved. Expand these into a sequence of copy instructions; /// after processing the last in the bundle. Does not update LiveIntervals; /// which we shouldn't need for this instruction anymore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:28,Testability,log,logic,28,/// The liverange splitting logic sometimes produces bundles of copies when; /// subregisters are involved. Expand these into a sequence of copy instructions; /// after processing the last in the bundle. Does not update LiveIntervals; /// which we shouldn't need for this instruction anymore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:109,Energy Efficiency,schedul,schedule,109,"// If any of the destination registers in the bundle of copies alias any of; // the source registers, try to schedule the instructions to avoid any; // clobbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:138,Safety,avoid,avoid,138,"// If any of the destination registers in the bundle of copies alias any of; // the source registers, try to schedule the instructions to avoid any; // clobbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:195,Usability,undo,undone,195,"// If instruction is in the middle of the bundle, move it before the; // bundle starts, otherwise, just unbundle it. When we get to the last; // instruction, the bundle will have been completely undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite. Note we could have used MachineOperand::substPhysReg(), but; // we need the inlining here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:88,Energy Efficiency,allocate,allocated,88,// Don't bother maintaining accurate LiveIntervals for registers which were; // already allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:47,Energy Efficiency,Schedul,Scheduling,47,"//===- VLIWMachineScheduler.cpp - VLIW-Focused Scheduling Pass ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:400,Energy Efficiency,schedul,schedules,400,"//===- VLIWMachineScheduler.cpp - VLIW-Focused Scheduling Pass ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:64,Availability,avail,available,64,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:16,Energy Efficiency,schedul,scheduler,16,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:109,Integrability,depend,dependence,109,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:101,Performance,latency,latency,101,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:162,Availability,avail,available,162,"// This value is used to determine if a register class is a high pressure set.; // We compute the maximum number of registers needed and divided by the total; // available. Then, we compare the result to this value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:30,Integrability,depend,dependence,30,/// Return true if there is a dependence between SUd and SUu.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:74,Integrability,depend,dependencies,74,"// Since we do not add pseudos to packets, might as well; // ignore order dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Energy Efficiency,schedul,scheduling,13,"/// Check if scheduling of this SU is possible; /// in the current packet.; /// It is _not_ precise (statefull), it is more like; /// another heuristic. Many corner cases are figured; /// empirically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Deployability,pipeline,pipeline,20,// First see if the pipeline could receive this instruction; // in the current cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:33,Integrability,depend,dependencies,33,// Now see if there are no other dependencies to instructions already; // in the packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:18,Availability,avail,available,18,/// Keep track of available resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:4,Energy Efficiency,schedul,schedule,4,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:105,Energy Efficiency,schedul,scheduling,105,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:206,Energy Efficiency,schedul,scheduling,206,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:59,Integrability,depend,dependencies,59,// Postprocess the DAG to add platform-specific artificial dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,// Notify the scheduling strategy after updating the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:18,Safety,Hazard,HazardRecognizers,18,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:108,Safety,Hazard,HazardRecs,108,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:83,Energy Efficiency,schedul,scheduler,83,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:157,Energy Efficiency,Schedul,ScheduleHazardRecognizer,157,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:475,Energy Efficiency,schedul,scheduler,475,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:24,Safety,hazard,hazard,24,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:115,Safety,hazard,hazard,115,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:209,Safety,hazard,hazard,209,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:428,Safety,hazard,hazards,428,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:357,Testability,log,logic,357,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:450,Usability,simpl,simple,450,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Safety,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Security,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:10,Safety,Hazard,HazardRec,10,// Bypass HazardRec virtual calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:46,Performance,latency,latency,46,// Bypass getHazardType calls in case of long latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:3,Deployability,Update,Update,3,// Update the reservation table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:98,Deployability,pipeline,pipeline,98,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,Energy Efficiency,schedul,scheduled,13,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:76,Energy Efficiency,schedul,scheduling,76,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:88,Usability,clear,clear,88,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:3,Deployability,Update,Update,3,// Update DFA model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:42,Availability,avail,available,42,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:4,Deployability,Release,Release,4,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:52,Performance,queue,queue,52,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:10,Availability,avail,available,10,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Performance,queue,queue,20,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:42,Safety,safe,safe,42,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:98,Availability,avail,available,98,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:108,Performance,queue,queue,108,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:12,Performance,queue,queue,12,"/// If this queue only has one ready candidate, return it. As a side effect,; /// advance the cycle until at least one node is ready. If multiple instructions; /// are ready, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:17,Performance,queue,queue,17,"// Very detailed queue dump, to be used with higher verbosity levels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:15,Availability,avail,available,15,"// We found an available, but not scheduled, predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:34,Energy Efficiency,schedul,scheduled,34,"// We found an available, but not scheduled, predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:15,Availability,avail,available,15,"// We found an available, but not scheduled, successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:34,Energy Efficiency,schedul,scheduled,34,"// We found an available, but not scheduled, successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:155,Availability,down,down,155,"// The pressure differences are computed bottom-up, so the comparison for; // an increase is positive in the bottom direction, but negative in the; // top-down direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:36,Energy Efficiency,schedul,scheduling,36,/// Single point to compute overall scheduling cost.; /// TODO: More heuristics will be used soon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:47,Energy Efficiency,schedul,scheduled,47,// Do not waste time on a node that is already scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Availability,avail,available,20,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:65,Energy Efficiency,schedul,scheduling,65,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:20,Availability,avail,available,20,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:65,Energy Efficiency,schedul,scheduling,65,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:35,Energy Efficiency,schedul,scheduling,35,// How many SUs does it block from scheduling?; // Look at all of the successors of this node.; // Count the number of nodes that; // this node is the sole unscheduled node for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:103,Availability,avail,available,103,"// If there are register pressure issues, then we remove the value added for; // the instruction being available. The rationale is that we really don't; // want to schedule an instruction that causes a spill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:164,Energy Efficiency,schedul,schedule,164,"// If there are register pressure issues, then we remove the value added for; // the instruction being available. The rationale is that we really don't; // want to schedule an instruction that causes a spill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:56,Integrability,depend,dependent,56,// Give preference to a zero latency instruction if the dependent; // instruction is in the current packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:29,Performance,latency,latency,29,// Give preference to a zero latency instruction if the dependent; // instruction is in the current packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:304,Availability,avail,available,304,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:242,Deployability,update,updates,242,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:125,Energy Efficiency,schedul,scheduled,125,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:194,Energy Efficiency,schedul,scheduled,194,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:232,Energy Efficiency,schedul,scheduler,232,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:45,Integrability,depend,dependence,45,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:169,Integrability,depend,dependent,169,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:37,Performance,latency,latency,37,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:180,Energy Efficiency,schedul,scheduling,180,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:269,Energy Efficiency,schedul,scheduled,269,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:41,Performance,queue,queue,41,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:106,Performance,cache,cached,106,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:39,Integrability,depend,depend,39,// Choose an instruction that does not depend on an artificial edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:29,Energy Efficiency,schedul,scheduling,29,"// Tie breaker.; // To avoid scheduling indeterminism, we need a tie breaker; // for the case when cost is identical for two nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:23,Safety,avoid,avoid,23,"// Tie breaker.; // To avoid scheduling indeterminism, we need a tie breaker; // for the case when cost is identical for two nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:63,Performance,queue,queue,63,/// Pick the best candidate node from either the top or bottom queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:79,Energy Efficiency,efficient,efficient,79,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:17,Energy Efficiency,schedul,scheduling,17,// Prefer bottom scheduling when heuristics are silent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:114,Energy Efficiency,schedul,schedule,114,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:199,Energy Efficiency,schedul,scheduled,199,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:258,Energy Efficiency,schedul,scheduling,258,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:347,Energy Efficiency,schedul,schedule,347,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:38,Energy Efficiency,schedul,schedule,38,/// Pick the best node to balance the schedule. Implements MachineSchedStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:4,Deployability,Update,Update,4,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:167,Deployability,update,update,167,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:15,Energy Efficiency,schedul,scheduler,15,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:39,Energy Efficiency,schedul,scheduling,39,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, VLIWMachineScheduler needs; /// to update it's state based on the current cycle before MachineSchedStrategy; /// does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:1698,Integrability,wrap,wrapper,1698,"ock:; // (In C-style pseudocode); //; // - Before:; // catchpad ...; // exn = wasm.get.exception();; // selector = wasm.get.selector();; // ...; //; // - After:; // catchpad ...; // exn = wasm.catch(WebAssembly::CPP_EXCEPTION);; // // Only add below in case it's not a single catch (...); // wasm.landingpad.index(index);; // __wasm_lpad_context.lpad_index = index;; // __wasm_lpad_context.lsda = wasm.lsda();; // _Unwind_CallPersonality(exn);; // selector = __wasm_lpad_context.selector;; // ...; //; //; // * Background: Direct personality function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:2544,Integrability,wrap,wrapper,2544,"ty function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_obj =; // (struct _Unwind_Exception *)exception_ptr;; // _Unwind_Reason_Code ret = __gxx_personality_v0(; // 1, _UA_CLEANUP_PHASE, exception_obj->exception_class, exception_obj,; // (struct _Unwind_Context *)__wasm_lpad_context);; // return ret;; // }; //; // We pass a landing pad index, and the address of LSDA for the current function; // to the wrapper function _Unwind_CallPersonality in libunwind, and we retrieve; // the selector after it returns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:3061,Integrability,wrap,wrapper,3061,"ty function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_obj =; // (struct _Unwind_Exception *)exception_ptr;; // _Unwind_Reason_Code ret = __gxx_personality_v0(; // 1, _UA_CLEANUP_PHASE, exception_obj->exception_class, exception_obj,; // (struct _Unwind_Context *)__wasm_lpad_context);; // return ret;; // }; //; // We pass a landing pad index, and the address of LSDA for the current function; // to the wrapper function _Unwind_CallPersonality in libunwind, and we retrieve; // the selector after it returns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:1920,Performance,perform,perform,1920,"d ...; // exn = wasm.catch(WebAssembly::CPP_EXCEPTION);; // // Only add below in case it's not a single catch (...); // wasm.landingpad.index(index);; // __wasm_lpad_context.lpad_index = index;; // __wasm_lpad_context.lsda = wasm.lsda();; // _Unwind_CallPersonality(exn);; // selector = __wasm_lpad_context.selector;; // ...; //; //; // * Background: Direct personality function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_obj =; // (struct _Unwind_Exception *)exception_ptr;; // _Unwind_Reason_Code ret = __gxx_personality_v0(; // 1, _UA_CLEANUP_PHASE, exception_obj->exception_class, exception_",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:29,Integrability,wrap,wrapper,29,// _Unwind_CallPersonality() wrapper,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:170,Availability,down,downgrade,170,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:125,Integrability,depend,depend,125,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:30,Modifiability,variab,variable,30,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:49,Modifiability,variab,variable,49,"// __wasm_lpad_context global variable.; // This variable should be thread local. If the target does not support TLS,; // we depend on CoalesceFeaturesAndStripAtomics to downgrade it to; // non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:32,Availability,down,down,32,// wasm.catch() will be lowered down to wasm 'catch' instruction in; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:29,Integrability,wrap,wrapper,29,"// _Unwind_CallPersonality() wrapper function, which calls the personality",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:202,Performance,optimiz,optimizing,202,"// TODO Sometimes storing the LSDA address every time is not necessary, in; // case it is already set in a dominating EH pad and there is no function call; // between from that EH pad to here. Consider optimizing those cases.; // Pseudocode: __wasm_lpad_context.lsda = wasm.lsda();",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:83,Performance,load,loaded,83,// Replace the return value from wasm.get.ehselector() with the selector value; // loaded from __wasm_lpad_context.selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:30,Integrability,rout,routine,30,"// The central theory of this routine is based on the following:; // A _try scope is always a SEME (Single Entry Multiple Exits) region; // as jumping into a _try is not allowed; // The single entry must start with a seh_try_begin() invoke with a; // correct State number that is the initial state of the SEME.; // Through control-flow, state number is propagated into all blocks.; // Side exits marked by seh_try_end() will unwind to parent state via; // existing SEHUnwindMap[].; // Side exits can ONLY jump into parent scopes (lower state number).; // Thus, when a block succeeds various states from its predecessors,; // the lowest State trumphs others.; // If some exits flow to unreachable, propagation on those paths terminate,; // not affecting remaining blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:36,Deployability,update,update,36,"// Now child Catches are processed, update CatchHigh",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:974,Availability,down,down,974,"// This numbering assigns one state number to each catchpad and cleanuppad.; // It also computes two tree-like relations over states:; // 1) Each state has a ""HandlerParentState"", which is the state of the next; // outer handler enclosing this state's handler (same as nearest ancestor; // per the ParentPad linkage on EH pads, but skipping over catchswitches).; // 2) Each state has a ""TryParentState"", which:; // a) for a catchpad that's not the last handler on its catchswitch, is; // the state of the next catchpad on that catchswitch; // b) for all other pads, is the state of the pad whose try region is the; // next outer try region enclosing this state's try region. The ""try; // regions are not present as such in the IR, but will be inferred; // based on the placement of invokes and pads which reach each other; // by exceptional exits; // Catchswitches do not get their own states, but each gets mapped to the; // state of its first catchpad.; // Step one: walk down from outermost to innermost funclets, assigning each; // catchpad and cleanuppad a state number. Add an entry to the; // ClrEHUnwindMap for each state, recording its HandlerParentState and; // handler attributes. Record the TryParentState as well for each catchpad; // that's not the last on its catchswitch, but initialize all other entries'; // TryParentStates to a sentinel -1 value that the next pass will update.; // Seed a worklist with pads that have no parent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:1389,Deployability,update,update,1389,"// This numbering assigns one state number to each catchpad and cleanuppad.; // It also computes two tree-like relations over states:; // 1) Each state has a ""HandlerParentState"", which is the state of the next; // outer handler enclosing this state's handler (same as nearest ancestor; // per the ParentPad linkage on EH pads, but skipping over catchswitches).; // 2) Each state has a ""TryParentState"", which:; // a) for a catchpad that's not the last handler on its catchswitch, is; // the state of the next catchpad on that catchswitch; // b) for all other pads, is the state of the pad whose try region is the; // next outer try region enclosing this state's try region. The ""try; // regions are not present as such in the IR, but will be inferred; // based on the placement of invokes and pads which reach each other; // by exceptional exits; // Catchswitches do not get their own states, but each gets mapped to the; // state of its first catchpad.; // Step one: walk down from outermost to innermost funclets, assigning each; // catchpad and cleanuppad a state number. Add an entry to the; // ClrEHUnwindMap for each state, recording its HandlerParentState and; // handler attributes. Record the TryParentState as well for each catchpad; // that's not the last on its catchswitch, but initialize all other entries'; // TryParentStates to a sentinel -1 value that the next pass will update.; // Seed a worklist with pads that have no parent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:94,Availability,fault,fault,94,// Create the entry for this cleanup with the appropriate handler; // properties. Finally and fault handlers are distinguished by arity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Performance,Queue,Queue,3,// Queue any child EH pads on the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Performance,Queue,Queue,3,// Queue any child EH pads on the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:172,Usability,Simpl,SimplifyUnreachable,172,"// Not having an unwind dest for this user might indicate that it; // doesn't unwind, so can't be taken as proof that the cleanup itself; // may unwind to caller (see e.g. SimplifyUnreachable and; // RemoveUnwindEdge).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:659,Availability,down,down,659,"// If UnwindDest is null at this point, either the pad in question can; // be exited by unwind to caller, or it cannot be exited by unwind. In; // either case, reporting such cases as unwinding to caller is correct.; // This can lead to EH tables that ""look strange"" -- if this pad's is in; // a parent funclet which has other children that do unwind to an enclosing; // pad, the try region for this pad will be missing the ""duplicate"" EH; // clause entries that you'd expect to see covering the whole parent. That; // should be benign, since the unwind never actually happens. If it were; // an issue, we could add a subsequent pass that pushes unwind dests down; // from parents that have them to children that appear to unwind to caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:43,Performance,perform,perform,43,// Record delta operations that we need to perform to our color mappings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Deployability,Update,Update,3,// Update our color mappings to reflect that one block has lost a color and; // another has gained a color.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:48,Deployability,update,updated,48,// Catchrets targeting cloned blocks need to be updated separately from; // the loop above because they are not in the current funclet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:97,Deployability,update,update,97,"// If there were values defined in BB that are used outside the funclet,; // then we now have to update all uses of the value to use either the; // original value, the cloned value, or some PHI derived value. This can; // require arbitrary PHI insertion, of which we are prepared to do, clean; // these up now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:134,Availability,alive,alive,134,// Remove unreachable blocks. It is not valuable to assign them a color and; // their existence can trick us into thinking values are alive when they are; // not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:15,Performance,load,loads,15,"// TODO: Share loads when one use dominates another, or when a catchpad exit; // dominates uses (needs dominators).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:57,Performance,load,load,57,"// If the EHPad isn't a terminator, then we can insert a load in this block; // that will dominate all uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:81,Performance,load,loads,81,"// Otherwise, we have a PHI on a terminator EHPad, and we give up and insert; // loads of the slot before every use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:57,Performance,load,loads,57,// Use is on an EH pad phi. Leave it alone; we'll insert loads and; // stores for it separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:13,Safety,safe,safely,13,// Undef can safely be skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:39,Performance,queue,queue,39,"// Pred is unsplittable, so we need to queue it on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:44,Performance,load,load,44,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:101,Performance,load,load,101,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:287,Performance,load,loads,287,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:378,Performance,load,load,378,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:494,Performance,load,loads,494,"// If this is a PHI node, we can't insert a load of the value before; // the use. Instead insert the load in the predecessor block; // corresponding to the incoming value.; //; // Note that if there are multiple edges from a basic block to this; // PHI node that we cannot have multiple loads. The problem is that; // the resulting PHI node will have multiple values (from each load); // coming in from the same block, which is illegal SSA form.; // For this reason, we keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:13,Performance,load,load,13,"// Putting a load above a catchret and use on the phi would still leave; // a cross-funclet def/use. We need to split the edge, change the; // catchret to target the new block, and put the load there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:189,Performance,load,load,189,"// Putting a load above a catchret and use on the phi would still leave; // a cross-funclet def/use. We need to split the edge, change the; // catchret to target the new block, and put the load there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:3,Deployability,Update,Update,3,// Update the color mapping for the newly split edge.; // Grab a reference to the ColorVector to be inserted before getting the; // reference to the vector we are copying because inserting the new; // element in BlockColors might cause the map to be reallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:39,Performance,load,load,39,// Treat the new block as incoming for load insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:14,Performance,load,load,14,// Insert the load into the predecessor block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp:66,Deployability,patch,patchable,66,"// Replace the original RET instruction with the exit sled code (""patchable; // ret"" pseudo-instruction), so that at runtime XRay can replace the sled; // with a code jumping to XRay trampoline, which calls the tracing handler; // and, in the end, issues the RET instruction.; // This is the approach to go on CPUs which have a single RET instruction,; // like x86/x86_64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp:69,Deployability,patch,patchable,69,"// Prepend the original return instruction with the exit sled code (""patchable; // function exit"" pseudo-instruction), preserving the original return; // instruction just after the exit sled code.; // This is the approach to go on CPUs which have multiple options for the; // return instruction, like ARM. For such CPUs we can't just jump into the; // XRay trampoline and issue a single return instruction there. We rather; // have to call the trampoline and return from it to the original return; // instruction of the function being instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp:94,Integrability,depend,dependent,94,"// Check if we have a loop.; // FIXME: Maybe make this smarter, and see whether the loops are dependent; // on inputs or side-effects?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/XRayInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:34,Security,hash,hashes,34,// First get the number of unique hashes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:25,Security,hash,hash,25,// Create the individual hash data outputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:105,Security,hash,hashes,105,"// Figure out how many buckets we need, then compute the bucket contents and; // the final ordering. The hashes and offsets can be emitted by walking these; // data structures. We add temporary symbols to the data so they can be; // referenced when emitting the offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:39,Security,hash,hash,39,// Sort the contents of the buckets by hash value so that hash collisions end; // up together. Stable sort makes testing easier and doesn't cost much more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:58,Security,hash,hash,58,// Sort the contents of the buckets by hash value so that hash collisions end; // up together. Stable sort makes testing easier and doesn't cost much more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:113,Testability,test,testing,113,// Sort the contents of the buckets by hash value so that hash collisions end; // up together. Stable sort makes testing easier and doesn't cost much more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:59,Security,hash,hash,59,"///< Data to emit.; /// Controls whether to emit duplicate hash and offset table entries for names; /// with identical hashes. Apple tables don't emit duplicate entries, DWARF v5; /// tables do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:119,Security,hash,hashes,119,"///< Data to emit.; /// Controls whether to emit duplicate hash and offset table entries for names; /// with identical hashes. Apple tables don't emit duplicate entries, DWARF v5; /// tables do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:26,Safety,detect,detect,26,/// 'HASH' magic value to detect endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:5,Security,HASH,HASH,5,/// 'HASH' magic value to detect endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:112,Performance,perform,performs,112,"/// Class responsible for emitting a DWARF v5 Accelerator Table. The only; /// public function is emit(), which performs the actual emission.; ///; /// A callback abstracts the logic to provide a CU index for a given entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:177,Testability,log,logic,177,"/// Class responsible for emitting a DWARF v5 Accelerator Table. The only; /// public function is emit(), which performs the actual emission.; ///; /// A callback abstracts the logic to provide a CU index for a given entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:32,Security,hash,hashes,32,"// Buckets point in the list of hashes, not to the data. Do not increment; // the index multiple times in case of hash collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:114,Security,hash,hash,114,"// Buckets point in the list of hashes, not to the data. Do not increment; // the index multiple times in case of hash collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:47,Security,hash,hash,47,// Terminate the previous entry if there is no hash collision with the; // current one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:102,Availability,fault,faulty,102,// This is not crashing on bad input: we should only reach this if the; // internal compiler logic is faulty; see getFormForIdxParent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:93,Testability,log,logic,93,// This is not crashing on bad input: we should only reach this if the; // internal compiler logic is faulty; see getFormForIdxParent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:59,Security,access,accesses,59,/// Constructs a unique AbbrevTag that captures what a DIE accesses.; /// Using this tag we can emit a unique abbreviation for each DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:137,Safety,avoid,avoids,137,"// Emit the label for this Entry, so that IDX_parents may refer to it.; // Note: a DIE may have multiple accelerator Entries; this check avoids; // creating/emitting multiple labels for the same DIE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:359,Integrability,rout,routine,359,"// Generate EH Info Table.; // The EH Info Table, aka, 'compat unwind section' on AIX, have the following; // format: struct eh_info_t {; // unsigned version; /* EH info verion 0 */; // #if defined(__64BIT__); // char _pad[4]; /* padding */; // #endif; // unsigned long lsda; /* Pointer to LSDA */; // unsigned long personality; /* Pointer to the personality routine */; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:15,Integrability,rout,routine,15,// Personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:27,Security,access,access,27,"// There is no easy way to access register information in `AIXException`; // class. when ShouldEmitEHBlock is false and VRs are saved, A dumy eh info; // table are emitted in PPCAIXAsmPrinter::emitFunctionBodyEnd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:155,Performance,queue,queue,155,"// If the block got deleted, there is no need for the symbol. If the symbol; // was already emitted, we can just forget about it, otherwise we need to; // queue it up for later emission when the function is output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Usability,Clear,Clear,3,// Clear the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:57,Safety,detect,detectable,57,"// BasicBlock is destroyed already, so this access is UB detectable by msan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:44,Security,access,access,44,"// BasicBlock is destroyed already, so this access is UB detectable by msan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Deployability,Update,Update,3,// Update the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Deployability,Update,Update,3,"// Update the callback.; // Otherwise, we need to add the old symbols to the new block's set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:18,Performance,cache,cached,18,"// Do not use the cached DataLayout because some client use it without a Module; // (dsymutil, llvm-dwarfdump).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:24,Deployability,deploy,deployment,24,"// Emit the version-min deployment target directive if needed.; //; // FIXME: If we end up with a collection of these sorts of Darwin-specific; // or ELF-specific things, it may make sense to have a platform helper class; // that will work with the target helper class. For now keep it here, as the; // alternative is duplicated code in each of the target asm printers that; // use the directive, where it would need the same conditionalization; // anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:51,Modifiability,variab,variable,51,/// EmitGlobalVariable - Emit the specified global variable to the .s file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:18,Modifiability,variab,variable,18,// Never emit TLS variable xyz in emulated TLS model.; // The initialization value is in __emutls_t.xyz instead of xyz.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:29,Modifiability,variab,variable,29,"// When printing the control variable __emutls_v.*,; // we don't need to print the original TLS variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:96,Modifiability,variab,variable,96,"// When printing the control variable __emutls_v.*,; // we don't need to print the original TLS variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,Safety,avoid,avoid,30,"// .comm Foo, 0 is undefined, avoid it.; // .comm _foo, 42, 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:351,Deployability,integrat,integrated,351,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:351,Integrability,integrat,integrated,351,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,Safety,avoid,avoid,30,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:387,Usability,simpl,simply,387,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:304,Availability,down,down,304,"// Handle thread local data for mach-o which requires us to output an; // additional structure of data and mangle the original symbol so that we; // can reference it later.; //; // TODO: This should become an ""emit thread local global"" method on TLOF.; // All of this macho specific stuff should be sunk down into TLOFMachO and; // stuff like ""TLSExtraDataSection"" should no longer be part of the parent; // TLOF class. This will also make it more obvious that stuff like; // MCStreamer::EmitTBSSSymbol is macho specific and only called from macho; // specific code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:12,Modifiability,variab,variable,12,// Emit the variable struct for the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:37,Deployability,patch,patchable-function-prefix,37,// Emit KCFI type information before patchable-function-prefix nops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:57,Security,sanitiz,sanitizer,57,// Emit the function prologue data for the indirect call sanitizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:178,Energy Efficiency,Power,PowerPC,178,// Emit the function descriptor. This is a virtual function to allow targets; // to emit their specific function descriptor. Right now it is only used by; // the AIX target. The PowerPC 64-bit V1 ELF target also uses function; // descriptors and should be converted to use this hook as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:137,Availability,error,error,137,// The function label could have already been emitted if two symbols end up; // conflicting due to asm renaming. Detect this and emit an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,Safety,Detect,Detect,113,// The function label could have already been emitted if two symbols end up; // conflicting due to asm renaming. Detect this and emit an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:67,Usability,simpl,simplify,67,"// First convert this to a non-variadic expression if possible, to simplify; // the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:29,Usability,simpl,simplified,29,"// Then, output the possibly-simplified expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:110,Usability,simpl,simply,110,"// Expect the first operand to be a section name. After that, a tuple of; // constants may appear, which will simply be emitted into the current; // section (the user of MD_pcsections decides the format of encoded data).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:49,Safety,avoid,avoids,49,"// Emit relative relocation `addr - base`, which avoids a dynamic; // relocation in the final binary. User will get the address with; // `base + addr`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:270,Modifiability,variab,variable,270,"// For AsynchEH, insert a Nop if followed by a trap inst; // Or the exception won't be caught.; // (see MCConstantExpr::create(1,..) in WinException.cpp); // Ignore SDiv/UDiv because a DIV with Const-0 divisor; // must have being turned into an UndefValue.; // Div with variable opnds won't be the first instruction in; // an EH region as it must be led by at least a Load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:368,Performance,Load,Load,368,"// For AsynchEH, insert a Nop if followed by a trap inst; // Or the exception won't be caught.; // (see MCConstantExpr::create(1,..) in WinException.cpp); // Ignore SDiv/UDiv because a DIV with Const-0 divisor; // must have being turned into an UndefValue.; // Div with variable opnds won't be the first instruction in; // an EH region as it must be led by at least a Load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:120,Safety,safe,safely,120,"// This instruction reference will have been resolved to a machine; // location, and a nearby DBG_VALUE created. We can safely ignore; // the instruction reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:406,Performance,load,load,406,"// If the function is empty and the object file uses .subsections_via_symbols,; // then we need to emit *something* to the function body to prevent the; // labels from collapsing together. Just emit a noop.; // Similarly, don't emit empty functions on Windows either. It can lead to; // duplicate entries (two functions with the same RVA) in the Guard CF Table; // after linking, causing the kernel not to load the binary:; // https://developercommunity.visualstudio.com/content/problem/45366/vc-linker-creates-invalid-dll-with-clang-cl.html; // FIXME: Hide this behind some API in e.g. MCAsmInfo or MCTargetStreamer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:33,Modifiability,Variab,Variables,33,/// Compute the number of Global Variables that uses a Constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:120,Modifiability,variab,variables,120,"/// Only consider global GOT equivalents if at least one user is a; /// cstexpr inside an initializer of another global variables. Also, don't; /// handle cstexpr inside instructions. During global variable emission,; /// candidates are skipped and are emitted later in case at least one cstexpr; /// isn't replaced by a PC relative GOT entry access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:198,Modifiability,variab,variable,198,"/// Only consider global GOT equivalents if at least one user is a; /// cstexpr inside an initializer of another global variables. Also, don't; /// handle cstexpr inside instructions. During global variable emission,; /// candidates are skipped and are emitted later in case at least one cstexpr; /// isn't replaced by a PC relative GOT entry access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:343,Security,access,access,343,"/// Only consider global GOT equivalents if at least one user is a; /// cstexpr inside an initializer of another global variables. Also, don't; /// handle cstexpr inside instructions. During global variable emission,; /// candidates are skipped and are emitted later in case at least one cstexpr; /// isn't replaced by a PC relative GOT entry access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,Modifiability,variab,variable,113,"// To be a got equivalent, at least one of its users need to be a constant; // expression used by another global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:28,Modifiability,variab,variables,28,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:89,Modifiability,variab,variable,89,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:360,Modifiability,variab,variables,360,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:186,Performance,Optimiz,Optimize,186,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:373,Safety,avoid,avoid,373,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:210,Security,access,accesses,210,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:465,Security,access,access,465,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:42,Usability,usab,usable,42,"// AIX's assembly directive `.set` is not usable for aliasing purpose,; // so AIX has to use the extra-label-at-definition strategy. At this; // point, all the extra label is emitted, we just have to emit linkage for; // those labels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:31,Modifiability,variab,variable,31,// Linkage for alias of global variable has been emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:73,Security,access,accesses,73,// Set the MachineFunction to nullptr so that we can catch attempted; // accesses to MF specific features at the module level and so that; // we can conditionalize accesses based on whether or not it is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:164,Security,access,accesses,164,// Set the MachineFunction to nullptr so that we can catch attempted; // accesses to MF specific features at the module level and so that; // we can conditionalize accesses based on whether or not it is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:130,Safety,avoid,avoid,130,"// Gather all GOT equivalent globals in the module. We really need two; // passes over the globals: one to compute and another to avoid its emission; // in EmitGlobalVariable, otherwise we would not be able to handle cases; // where the got equivalent shows up before its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:15,Modifiability,variab,variables,15,// Emit global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,Modifiability,Variab,Variable,30,// Handle the XCOFF case.; // Variable `Name` is the function descriptor symbol (see above). Get the; // function entry point symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:72,Safety,safe,safest,72,// Emit the remarks section contents.; // FIXME: Figure out when is the safest time to emit this section. It should; // not come after debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:47,Modifiability,variab,variables,47,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:10,Testability,stub,stubs,10,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:47,Modifiability,variab,variables,47,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:10,Testability,stub,stubs,10,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:243,Modifiability,plugin,plugins,243,"// Emit Stack maps before any debug info. Mach-O requires that no data or; // text sections come after debug info has been emitted. This matters for; // stack maps as they are arbitrary data, and may even have a custom format; // through user plugins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:144,Energy Efficiency,Power,PowerPC,144,"// Print aliases in topological order, that is, for each alias a = b,; // b must be printed before a.; // This is because on some targets (e.g. PowerPC) linker expects aliases in; // such an order to generate correct TOC information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:112,Availability,alive,alive,112,"// This deletes all the ephemeral handlers that AsmPrinter added, while; // keeping all the user-added handlers alive until the AsmPrinter is; // destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:112,Energy Efficiency,reduce,reduce,112,// Calculate sections for constant pool entries. We collect entries to go into; // the same section together to reduce amount of section switch statements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:53,Safety,avoid,avoids,53,"// For the EK_LabelDifference32 entry, if using .set avoids a relocation,; /// emit a .set directive for each unique entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:137,Usability,Simpl,Simplify,137,"// FIXME: This doesn't have to have any specific name, just any randomly; // named and numbered local label started with 'l' would work. Simplify; // GetJTISymbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:211,Safety,avoid,avoids,211,"// Each entry is the address of the block minus the address of the jump; // table. This is used for PIC jump tables where gprel32 is not supported.; // e.g.:; // .word LBB123 - LJTI1_2; // If the .set directive avoids relocations, this is emitted as:; // .set L4_5_set_123, LBB123 - LJTI1_2; // .word L4_5_set_123",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:152,Availability,redundant,redundant,152,"// FIXME: For non-dllimport functions, MSVC emits the same entry; // twice, for reasons I don't understand. I have to assume the linker; // ignores the redundant entry; there aren't any reasonable semantics; // to attach to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:152,Safety,redund,redundant,152,"// FIXME: For non-dllimport functions, MSVC emits the same entry; // twice, for reasons I don't understand. I have to assume the linker; // ignores the redundant entry; there aren't any reasonable semantics; // to attach to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:21,Modifiability,variab,variable,21,"// If the associated variable is not defined in this module; // (it might be available_externally, or have been an; // available_externally definition that was dropped by the; // EliminateAvailableExternally pass), some other TU; // will provide its dynamic initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:102,Integrability,rout,routines,102,//===--------------------------------------------------------------------===//; // Emission and print routines; //; /// Emit a byte directive and value.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:172,Safety,avoid,avoids,172,"/// Emit something like "".long Hi-Lo"" where the size in bytes of the directive; /// is specified by Size and Hi/Lo specify the labels. This implicitly uses; /// .set if it avoids relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:205,Availability,avail,available,205,"/// EmitLabelPlusOffset - Emit something like "".long Label+Offset""; /// where the size in bytes of the directive is specified by Size and Label; /// specifies the label. This implicitly uses .set if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:146,Energy Efficiency,power,power,146,"//===----------------------------------------------------------------------===//; // EmitAlignment - Emit an alignment directive to the specified power of; // two boundary. If a global value is specified, and if that global has; // an explicit alignment requested, it will override the alignment request; // if required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:25,Integrability,depend,depend,25,"// We emit the value and depend on the assembler to truncate the generated; // expression properly. This is important for differences between; // blockaddress labels. Since the two labels are in the same function, it; // is reasonable to treat their delta as a 32-bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:128,Usability,simpl,simplifies,128,// Handle casts to pointers by changing them into casts to the appropriate; // integer type. This promotes constant folding and simplifies this code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:206,Integrability,depend,depend,206,"// We can emit the pointer value into this slot if the slot is an; // integer slot equal to the size of the pointer.; //; // If the pointer is larger than the resultant integer, then; // as with Trunc just depend on the assembler to truncate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:21,Performance,optimiz,optimized,21,"// If the code isn't optimized, there may be outstanding folding; // opportunities. Attempt to fold the expression using DataLayout as a; // last resort before giving up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Modifiability,Extend,Extend,3,// Extend the element to take zero padding into account.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:129,Security,access,access,129,"/// Transform a not absolute MCExpr containing a reference to a GOT; /// equivalent global, by a target specific GOT pc relative access to the; /// final symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:39,Performance,cache,cached,39,// Check that GOT equivalent symbol is cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:3,Deployability,Update,Update,3,// Update GOT equivalent usage information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:91,Safety,detect,detect,91,"// Since lowerConstant already folded and got rid of all IR pointer and; // integer casts, detect GOT equivalent accesses by looking into the MCExpr; // directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,Security,access,accesses,113,"// Since lowerConstant already folded and got rid of all IR pointer and; // integer casts, detect GOT equivalent accesses by looking into the MCExpr; // directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:101,Integrability,Rout,Routines,101,//===----------------------------------------------------------------------===//; // Symbol Lowering Routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:40,Deployability,update,updated,40,// Check if CFI information needs to be updated for this MBB with basic block; // sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:18,Usability,simpl,simple,18,"// If it is not a simple branch, we are in a table somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:132,Deployability,patch,patches,132,"// In the binary's ""xray_instr_map"" section, an array of these function entries; // describes each instrumentation point. When XRay patches your code, the index; // into this table will be given to your handler as a patch point identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:216,Deployability,patch,patch,216,"// In the binary's ""xray_instr_map"" section, an array of these function entries; // describes each instrumentation point. When XRay patches your code, the index; // into this table will be given to your handler as a patch point identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:222,Availability,down,down,222,"// We then emit a single entry in the index per function. We use the symbols; // that bound the instrumentation map as the range for a specific function.; // Each entry here will be 2 * word size aligned, as we're writing down two; // pointers. This should work for both 32-bit and 64-bit platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp:107,Integrability,Rout,Routines,107,//===----------------------------------------------------------------------===//; // Dwarf Emission Helper Routines; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp:100,Integrability,Rout,Routines,100,//===----------------------------------------------------------------------===//; // Dwarf Lowering Routines; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:61,Safety,avoid,avoid,61,// Remember if the buffer is nul terminated or not so we can avoid a copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:65,Deployability,integrat,integrated,65,"// If the output streamer does not have mature MC support or the integrated; // assembler has been disabled or not required, just emit the blob textually.; // Otherwise parse the asm and emit it via MC support.; // This is useful in case the asm parser doesn't handle something but the; // system assembler does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:65,Integrability,integrat,integrated,65,"// If the output streamer does not have mature MC support or the integrated; // assembler has been disabled or not required, just emit the blob textually.; // Otherwise parse the asm and emit it via MC support.; // This is useful in case the asm parser doesn't handle something but the; // system assembler does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:259,Integrability,depend,dependent,259,// We create a new MCInstrInfo here since we might be at the module level; // and not have a MachineFunction to initialize the TargetInstrInfo from and; // we only need MCInstrInfo for asm parsing. We create one unconditionally; // because it's not subtarget dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:5,Modifiability,variab,variable,5,// ${variable},MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:164,Availability,error,error,164,"// We may have a location metadata attached to the end of the; // instruction, and at no point should see metadata at any; // other point while processing. It's an error if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:189,Modifiability,portab,portably,189,"/// PrintSpecial - Print information related to the specified machine instr; /// that is independent of the operand, and may be independent of the instr; /// itself. This can be useful for portably encoding the comment character; /// or other bits of target-specific knowledge into the asmstrings. The; /// syntax used is ${:comment}. Targets can override this to add support; /// for their own strange codes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:82,Energy Efficiency,allocate,allocated,82,"// Comparing the address of MI isn't sufficient, because machineinstrs may; // be allocated to the same address across functions.; // If this is a new LastFn instruction, bump the counter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h:68,Security,hash,hashing,68,// For now we're just handling the calls we need for dwarf emission/hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:87,Security,access,access,87,"// Canonicalize the path. We have to do it textually because we may no longer; // have access the file in the filesystem.; // First, replace all slashes with backslashes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:53,Safety,abort,abort,53,"// Something's wrong if the path starts with ""\..\"", abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:22,Safety,abort,abort,22,"// Something's wrong, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:222,Availability,error,error,222,"// No scope means global scope and that uses the zero index.; //; // We also use zero index when the scope is a DISubprogram; // to suppress the emission of LF_STRING_ID for the function,; // which can trigger a link-time error with the linker in; // VS2019 version 16.11.2 or newer.; // Note, however, skipping the debug info emission for the DISubprogram; // is a temporary fix. The root issue here is that we need to figure out; // the proper way to encode a function nested in another function; // (as introduced by the Fortran 'contains' keyword) in CodeView.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:132,Security,access,access,132,"// If the scope is a DICompositeType, then this must be a method. Member; // function types take some special handling, and require access to the; // subprogram.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Modifiability,variab,variable,8,// This variable was inlined. Associate it with the InlineSite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Modifiability,variab,variable,8,// This variable goes into the corresponding lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:82,Availability,avail,available,82,"// If module doesn't have named metadata anchors or COFF debug section; // is not available, skip any debug info related stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:39,Security,hash,hashes,39,// Check if we should emit type record hashes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,Modifiability,variab,variable,15,// Emit global variable debug information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,variab,variables,49,// Emit UDT records for any types used by global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:29,Security,hash,hashes,29,"// Emit type information and hashes last, so that any types we translate while; // emitting function info are included.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Energy Efficiency,adapt,adapter,49,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Integrability,adapter,adapter,49,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,adapt,adapter,49,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:51,Security,hash,hash,51,"// Start the .debug$H section with the version and hash algorithm, currently; // hardcoded to version 0, SHA1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:55,Security,hash,hash,55,"// Emit an EOL-comment describing which TypeIndex this hash corresponds; // to, as well as the stringified SHA1 hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:112,Security,hash,hash,112,"// Emit an EOL-comment describing which TypeIndex this hash corresponds; // to, as well as the stringified SHA1 hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:384,Usability,clear,clear,384,"// First, make LF_BUILDINFO. It's a sequence of strings with various bits of; // build info. The known prefix is:; // - Absolute path of current directory; // - Compiler path; // - Main source file path, relative to CWD or absolute; // - Type server PDB file; // - Canonical compiler command line; // If frontend and backend compilation are separated (think llc or LTO), it's; // not clear if the compiler path should refer to the executable for the; // frontend or the backend. Leave it blank for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:118,Performance,load,loading,118,"// We emit the checksum info for files. This is used by debuggers to; // determine if a pdb matches the source before loading it. Visual Studio,; // for instance, will display a warning that the breakpoints are not valid if; // the pdb does not match the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,Security,checksum,checksum,15,"// We emit the checksum info for files. This is used by debuggers to; // determine if a pdb matches the source before loading it. Visual Studio,; // for instance, will display a warning that the breakpoints are not valid if; // the pdb does not match the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:51,Integrability,rout,routine,51,// Emit an S_THUNK32/S_END symbol pair for a thunk routine.; // The only supported thunk ordinal is currently the standard type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:27,Integrability,rout,routines,27,// Local variables/inlined routines are purposely omitted here. The point of; // marking this as a thunk is so Visual Studio will NOT stop in this routine.; // Emit S_PROC_ID_END,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:147,Integrability,rout,routine,147,// Local variables/inlined routines are purposely omitted here. The point of; // marking this as a thunk is so Visual Studio will NOT stop in this routine.; // Emit S_PROC_ID_END,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:9,Modifiability,variab,variables,9,// Local variables/inlined routines are purposely omitted here. The point of; // marking this as a thunk is so Visual Studio will NOT stop in this routine.; // Emit S_PROC_ID_END,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:10,Modifiability,variab,variable,10,"// If the variable has an attached offset expression, extract it.; // FIXME: Try to handle DW_OP_deref as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:43,Modifiability,variab,variables,43,"// FIXME: Find a way to represent constant variables, since they are; // relatively common.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:29,Modifiability,variab,variables,29,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:55,Modifiability,variab,variables,55,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:130,Modifiability,variab,variables,130,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:390,Modifiability,variab,variable,390,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:280,Performance,load,load,280,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:315,Performance,load,load,315,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:482,Performance,load,load,482,"// CodeView can only express variables in register and variables in memory; // at a constant offset from a register. However, for variables passed; // indirectly by pointer, it is common for that pointer to be spilled to a; // stack location. For the special case of one offseted load followed by a; // zero offset load (a pointer spilled to the stack), we change the type of; // the local variable from a value type to a reference type. This tricks the; // debugger into doing the load for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:59,Performance,load,load,59,// We're using a reference type. Drop the last zero offset load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:48,Performance,load,load,48,// We can only handle a register or an offseted load of a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:44,Modifiability,extend,extend,44,"// If the last range end is our begin, just extend the last range.; // Otherwise make a new range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:12,Modifiability,variab,variable,12,// Grab the variable info that was squirreled away in the MMI side-table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:46,Security,access,accessible,46,"// Instruction ranges, specifying where IV is accessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:14,Safety,safe,safebuffers,14,// __declspec(safebuffers) disables stack guards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:163,Usability,simpl,simpler,163,"// Find the end of the function prolog. First known non-DBG_VALUE and; // non-frame setup location marks the beginning of the function body.; // FIXME: is there a simpler a way to do this? Can we just search; // for the first instruction of the function, not the last of the prolog?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:230,Performance,perform,perform,230,"// TODO: What if the ClosestSubprogram is neither null or the current; // subprogram? Currently, the UDT just gets dropped on the floor.; //; // The current behavior is not desirable. To get maximal fidelity, we would; // need to perform all type translation before beginning emission of .debug$S; // and then make LocalUDTs a member of FunctionInfo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:30,Integrability,depend,depends,30,"// IndexType is size_t, which depends on the bitness of the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:211,Usability,clear,clear,211,"// Forward declarations of arrays without a size and VLAs use a count of -1.; // Emit a count of zero in these cases to match what MSVC does for arrays; // without a size. MSVC doesn't support VLAs, so it's not clear what we; // should do for them even if we could distinguish them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Deployability,Update,Update,3,// Update the element size and element type index for subsequent subranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:30,Integrability,depend,depends,30,"// IndexType is size_t, which depends on the bitness of the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,Usability,simpl,simple,15,"// Pointers to simple types without any options can use SimpleTypeMode, rather; // than having a dedicated pointer type record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:56,Usability,Simpl,SimpleTypeMode,56,"// Pointers to simple types without any options can use SimpleTypeMode, rather; // than having a dedicated pointer type record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:114,Integrability,wrap,wrappers,114,"// Return the base type index if there aren't any modifiers. For example, the; // metadata could contain restrict wrappers around non-pointer types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:28,Security,access,access,28,"// If there was no explicit access control, provide the default for the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:135,Integrability,wrap,wrapped,135,"// An unnamed member may represent a nested struct or union. Attempt to; // interpret the unnamed member as a DICompositeType possibly wrapped in; // qualifier types. Add all the indirect fields to the current record if that; // succeeds, and drop the member if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Integrability,rout,routine,8,// This routine is used by lowerTypeClass and lowerTypeUnion to determine; // if a complete type should be emitted instead of a forward reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:194,Availability,error,error,194,// If this unnamed complete type is already in the process of being defined; // then the description of the type is malformed and cannot be emitted; // into CodeView correctly so report a fatal error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:120,Availability,avail,available,120,"// First, construct the forward decl. Don't look into Ty to compute the; // forward decl options, since it might not be available in all TUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:22,Security,access,accessor,22,"// FIXME: Despite the accessor name, the offset is really in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:50,Security,hash,hash,50,// The null DIType is the void type. Don't try to hash it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:167,Deployability,update,update,167,// Check if we've already translated this type. Don't try to do a; // get-or-create style insertion that caches the hash lookup across the; // lowerType call. It will update the TypeIndices map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:105,Performance,cache,caches,105,// Check if we've already translated this type. Don't try to do a; // get-or-create style insertion that caches the hash lookup across the; // lowerType call. It will update the TypeIndices map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:116,Security,hash,hash,116,// Check if we've already translated this type. Don't try to do a; // get-or-create style insertion that caches the hash lookup across the; // lowerType call. It will update the TypeIndices map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:50,Security,hash,hash,50,// The null DIType is the void type. Don't try to hash it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Deployability,Update,Update,3,// Update the type index associated with this CompositeType. This cannot; // use the 'InsertResult' iterator above because it is potentially; // invalidated by map insertions which can occur while lowering the class; // type above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:8,Modifiability,variab,variables,8,// Emit variables local to this lexical block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:16,Integrability,rout,routine,16,/// Convenience routine for collecting lexical block information for a list; /// of lexical scopes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:42,Modifiability,variab,variable,42,/// Populate the lexical blocks and local variable lists of the parent with; /// information about the specified lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:62,Modifiability,variab,variables,62,"// Gather information about the lexical scope including local variables,; // global variables, and address ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:84,Modifiability,variab,variables,84,"// Gather information about the lexical scope including local variables,; // global variables, and address ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:46,Modifiability,variab,variables,46,// Ignore lexical scopes which do not contain variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:546,Integrability,rout,routine,546,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:609,Integrability,rout,routine,609,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:374,Modifiability,variab,variables,374,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:673,Modifiability,variab,variables,673,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:60,Energy Efficiency,reduce,reduce,60,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:129,Modifiability,variab,variable,129,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:21,Safety,safe,safely,21,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:41,Modifiability,variab,variables,41,// Create a lexical block containing the variables and collect the; // lexical block information for the children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:54,Integrability,rout,routine,54,// Build the lexical block structure to emit for this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:124,Integrability,rout,routine,124,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:183,Integrability,rout,routine,183,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:23,Modifiability,variab,variable,23,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Usability,Clear,Clear,3,// Clear the scope and variable information from the map which will not be; // valid after we have finished processing this routine. This also prepares; // the map for the subsequent routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:229,Integrability,depend,depending,229,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:99,Performance,optimiz,optimized,99,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Usability,Usab,Usable,3,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:72,Safety,avoid,avoid,72,"// MSVC does not pad out symbol records to four bytes, but LLVM does to avoid; // an extra copy of every symbol record in LLD. This increases object file; // size by less than 1% in the clang build, and is compatible with the Visual; // C++ linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:38,Modifiability,variab,variable,38,// Record the constant offset for the variable.; //; // A Fortran common block uses this idiom to encode the offset; // of a variable from the common block's starting address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:125,Modifiability,variab,variable,125,// Record the constant offset for the variable.; //; // A Fortran common block uses this idiom to encode the offset; // of a variable from the common block's starting address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:24,Modifiability,variab,variables,24,// Emit constant global variables in a global symbol section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:19,Modifiability,variab,variable,19,"// Locate a global variable list for this scope, creating one if; // necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variable,20,// Emit this global variable into a COMDAT section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variable,20,// Emit this global variable in a single global symbol section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variable,20,// Emit each global variable in the specified array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:20,Modifiability,variab,variables,20,"// For static local variables and Fortran, the scoping portion is elided; // in its name so that we can reference the variable in the command line; // of the VS debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:118,Modifiability,variab,variable,118,"// For static local variables and Fortran, the scoping portion is elided; // in its name so that we can reference the variable in the command line; // of the VS debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:19,Modifiability,variab,variable,19,/// Indicates that variable data is stored in memory relative to the; /// specified register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:14,Modifiability,variab,variable,14,/// Offset of variable data in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:32,Security,hash,hashes,32,/// Whether to emit type record hashes into .debug$H.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:35,Modifiability,variab,variables,35,// Lexical blocks containing local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:20,Energy Efficiency,allocate,allocated,20,/// Number of bytes allocated in the prologue for all local stack objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:100,Modifiability,variab,variables,100,/// Two-bit value indicating which register is the designated frame pointer; /// register for local variables. Included in S_FRAMEPROC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:24,Modifiability,variab,variables,24,// Map used to seperate variables according to the lexical scope they belong; // in. This is populated by recordLocalVariable() before; // collectLexicalBlocks() separates the variables between the FunctionInfo; // and LexicalBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:176,Modifiability,variab,variables,176,// Map used to seperate variables according to the lexical scope they belong; // in. This is populated by recordLocalVariable() before; // collectLexicalBlocks() separates the variables between the FunctionInfo; // and LexicalBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:26,Modifiability,variab,variables,26,// Map to separate global variables according to the lexical scope they; // belong in. A null local scope represents the global scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:19,Modifiability,variab,variables,19,// Array of global variables which need to be emitted into a COMDAT section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:30,Modifiability,variab,variables,30,// Array of non-COMDAT global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:13,Availability,avail,available,13,/// The next available function index for use with our .cv_* directives. Not; /// to be confused with type indices for LF_FUNC_ID records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:116,Usability,simpl,simpler,116,"/// Emits an S_END, S_INLINESITE_END, or S_PROC_ID_END record. These records; /// are empty, so we emit them with a simpler assembly sequence that doesn't; /// involve labels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:42,Integrability,rout,routine,42,"// Construct the lexical block tree for a routine, pruning emptpy lexical; // scopes, and populate it with local variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:113,Modifiability,variab,variables,113,"// Construct the lexical block tree for a routine, pruning emptpy lexical; // scopes, and populate it with local variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:38,Modifiability,variab,variable,38,"/// Records information about a local variable in the appropriate scope. In; /// particular, locals from inlined code live inside the inlining site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:16,Modifiability,variab,variables,16,/// Emits local variables in the appropriate order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:116,Safety,avoid,avoid,116,"/// Symbol records should point to complete types, but type records should; /// always point to incomplete types to avoid cycles in the type graph. Only; /// use this entry point when generating symbol records. The complete and; /// incomplete type indices only differ for record types. All other types use; /// the same index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:152,Modifiability,variab,variable,152,"// We give meta instructions the same ordinal as the preceding instruction; // because this class is written for the task of comparing positions of; // variable location ranges against scope ranges. To reflect what we'll see; // in the binary, when we look at location ranges we must consider all; // DBG_VALUEs between two real instructions at the same position. And a; // scope range which ends on a meta instruction should be considered to end; // at the last seen real instruction. E.g.; //; // 1 instruction p Both the variable location for x and for y start; // 1 DBG_VALUE for ""x"" after instruction p so we give them all the same; // 1 DBG_VALUE for ""y"" number. If a scope range ends at DBG_VALUE for ""y"",; // 2 instruction q we should treat it as ending after instruction p; // because it will be the last real instruction in the; // range. DBG_VALUEs at or after this position for; // variables declared in the scope will have no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:524,Modifiability,variab,variable,524,"// We give meta instructions the same ordinal as the preceding instruction; // because this class is written for the task of comparing positions of; // variable location ranges against scope ranges. To reflect what we'll see; // in the binary, when we look at location ranges we must consider all; // DBG_VALUEs between two real instructions at the same position. And a; // scope range which ends on a meta instruction should be considered to end; // at the last seen real instruction. E.g.; //; // 1 instruction p Both the variable location for x and for y start; // 1 DBG_VALUE for ""x"" after instruction p so we give them all the same; // 1 DBG_VALUE for ""y"" number. If a scope range ends at DBG_VALUE for ""y"",; // 2 instruction q we should treat it as ending after instruction p; // because it will be the last real instruction in the; // range. DBG_VALUEs at or after this position for; // variables declared in the scope will have no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:894,Modifiability,variab,variables,894,"// We give meta instructions the same ordinal as the preceding instruction; // because this class is written for the task of comparing positions of; // variable location ranges against scope ranges. To reflect what we'll see; // in the binary, when we look at location ranges we must consider all; // DBG_VALUEs between two real instructions at the same position. And a; // scope range which ends on a meta instruction should be considered to end; // at the last seen real instruction. E.g.; //; // 1 instruction p Both the variable location for x and for y start; // 1 DBG_VALUE for ""x"" after instruction p so we give them all the same; // 1 DBG_VALUE for ""y"" number. If a scope range ends at DBG_VALUE for ""y"",; // 2 instruction q we should treat it as ending after instruction p; // because it will be the last real instruction in the; // range. DBG_VALUEs at or after this position for; // variables declared in the scope will have no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:75,Modifiability,variab,variable,75,// Instruction range should start with a DBG_VALUE instruction for the; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:58,Modifiability,variab,variable,58,"// If an instruction clobbers multiple registers that the variable is; // described by, then we may have already created a clobbering instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:61,Modifiability,variab,variable,61,// The indices of the entries we're going to remove for each variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:34,Modifiability,variab,variable,34,// Entry reference count for each variable. Clobbers left with no references; // will be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:10,Modifiability,variab,variables,10,"// Ignore variables for non-inlined function level scopes. The scope; // ranges (from scope->getRanges()) will not include any instructions; // before the first one with a debug-location, which could cause us to; // incorrectly drop a location. We could introduce special casing for; // these variables, but it doesn't seem worth it because no out-of-scope; // locations have been observed for variables declared in function level; // scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:293,Modifiability,variab,variables,293,"// Ignore variables for non-inlined function level scopes. The scope; // ranges (from scope->getRanges()) will not include any instructions; // before the first one with a debug-location, which could cause us to; // incorrectly drop a location. We could introduce special casing for; // these variables, but it doesn't seem worth it because no out-of-scope; // locations have been observed for variables declared in function level; // scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:394,Modifiability,variab,variables,394,"// Ignore variables for non-inlined function level scopes. The scope; // ranges (from scope->getRanges()) will not include any instructions; // before the first one with a debug-location, which could cause us to; // incorrectly drop a location. We could introduce special casing for; // these variables, but it doesn't seem worth it because no out-of-scope; // locations have been observed for variables declared in function level; // scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:32,Modifiability,variab,variable,32,// If there is no scope for the variable then something has probably gone; // wrong.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:92,Modifiability,variab,variable,92,"// Check if the location range [StartMI, EndMI] intersects with any scope; // range for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:51,Deployability,update,update,51,"// Because we'll be removing this entry we need to update the reference; // count of the closing entry, if one exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:51,Modifiability,variab,variable,51,// If there is nothing to remove then jump to next variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:33,Deployability,update,update,33,// Build an offset map so we can update the EndIndex of the remaining; // entries.; // Zero the offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:3,Deployability,Update,Update,3,// Update the EndIndex of the entries to account for those which will be; // removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:34,Modifiability,variab,variable,34,// A DBG_VALUE $noreg is an empty variable location,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:31,Modifiability,variab,variables,31,// Maps physreg numbers to the variables they describe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:220,Modifiability,variab,variable,220,"// If a given register appears in a live DBG_VALUE_LIST for Var alongside the; // clobbered register, and never appears in a live DBG_VALUE* for Var without; // the clobbered register, then it is no longer linked to the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:36,Modifiability,variab,variables,36,// Terminate the location range for variables described by register at; // @I by inserting @ClobberingInstr to their history.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:20,Modifiability,variab,variables,20,"// Iterate over all variables described by this register and add this; // instruction to their history, clobbering it. All registers that also; // describe the clobbered variables (i.e. in variadic debug values) will have; // those Variables removed from their DescribedVars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:170,Modifiability,variab,variables,170,"// Iterate over all variables described by this register and add this; // instruction to their history, clobbering it. All registers that also; // describe the clobbered variables (i.e. in variadic debug values) will have; // those Variables removed from their DescribedVars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:232,Modifiability,Variab,Variables,232,"// Iterate over all variables described by this register and add this; // instruction to their history, clobbering it. All registers that also; // describe the clobbered variables (i.e. in variadic debug values) will have; // those Variables removed from their DescribedVars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:36,Modifiability,variab,variables,36,// Terminate the location range for variables described by register; // @RegNo by inserting @ClobberingInstr to their history.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:16,Modifiability,variab,variable,16,// Use the base variable (without any DW_OP_piece expressions); // as index into History. The full variables including the; // piece expressions are attached to the MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:99,Modifiability,variab,variables,99,// Use the base variable (without any DW_OP_piece expressions); // as index into History. The full variables including the; // piece expressions are attached to the MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:83,Safety,safe,safely,83,// Meta Instructions have no output and do not change any values and so; // can be safely ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:81,Modifiability,variab,variables,81,// Not a DBG_VALUE instruction. It may clobber registers which describe; // some variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:25,Availability,mask,mask,25,"// If this is a register mask operand, clobber all debug values in; // non-CSRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:49,Availability,mask,masks,49,// Don't consider SP to be clobbered by register masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:51,Modifiability,variab,variables,51,"// End instr loop.; // Make sure locations for all variables are valid only until the end of; // the basic block (unless it's the last basic block, in which case let; // their liveness run off to the end of the function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:20,Modifiability,variab,variables,20,// Iterate over all variables that have open debug values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:21,Modifiability,variab,variable,21,"/// If true, we drop variable location ranges which exist entirely outside the; /// variable's lexical scope instruction ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:84,Modifiability,variab,variable,84,"/// If true, we drop variable location ranges which exist entirely outside the; /// variable's lexical scope instruction ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:3,Modifiability,Variab,Variables,3,// Variables calculated from multiple locations can't be represented here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:153,Integrability,inject,inject,153,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:370,Safety,avoid,avoid,370,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:153,Security,inject,inject,153,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:31,Modifiability,variab,variables,31,// Calculate history for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:170,Energy Efficiency,reduce,reduces,170,"// We need a label after this instruction. With basic block sections, just; // use the end symbol of the section if this is the last instruction of the; // section. This reduces the need for an additional label and also helps; // merging ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:43,Modifiability,variab,variable,43,"/// A single location or constant within a variable location description, with; /// either a single entry (with an optional DIExpression) used for a DBG_VALUE,; /// or a list of entries used for a DBG_VALUE_LIST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:29,Modifiability,variab,variable,29,"/// The location of a single variable, composed of an expression and 0 or more; /// DbgValueLocEntries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:134,Modifiability,variab,variable,134,"/// Create a location list entry for the range [\p Begin, \p End).; ///; /// \param Vals One or more values describing (parts of) the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h:44,Modifiability,variab,variable,44,"// If this and Next are describing the same variable, merge them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h:126,Modifiability,variab,variable,126,"/// Byte stream of .debug_loc entries.; ///; /// Stores a unified stream of .debug_loc entries. There's \a List for each; /// variable/inlined-at pair, and an \a Entry for each \a DebugLocEntry.; ///; /// FIXME: Do we need all these temp symbols?; /// FIXME: Why not output directly to the output stream?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp:102,Availability,down,down,102,"// Could be an assertion, but this way we can see the failing form code; // easily, which helps track down where it came from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp:15,Testability,assert,assertion,15,"// Could be an assertion, but this way we can see the failing form code; // easily, which helps track down where it came from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,Security,Hash,Hashing,41,"//===-- llvm/CodeGen/DIEHash.cpp - Dwarf Hashing Framework ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:421,Security,hash,hashing,421,"//===-- llvm/CodeGen/DIEHash.cpp - Dwarf Hashing Framework ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:37,Security,hash,hash,37,/// Adds the string in \p Str to the hash. This also hashes; /// a trailing NULL with the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:53,Security,hash,hashes,53,/// Adds the string in \p Str to the hash. This also hashes; /// a trailing NULL with the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:21,Integrability,rout,routines,21,// FIXME: The LEB128 routines are copied and only slightly modified out of; // LEB128.h.; /// Adds the unsigned in \p Value to the hash encoded as a ULEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:131,Security,hash,hash,131,// FIXME: The LEB128 routines are copied and only slightly modified out of; // LEB128.h.; /// Adds the unsigned in \p Value to the hash encoded as a ULEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:58,Security,hash,hash,58,/// Including \p Parent adds the context of Parent to the hash..,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,Security,hash,hashed,41,"// a) If T is in the list of [previously hashed types], use the letter; // 'R' as the marker",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:109,Security,hash,hash,109,"// and the referenced type (via the [below attributes]); // FIXME: This seems overly restrictive, and causes hash mismatches; // there's a decl/def difference in the containing type of a; // ptr_to_member_type, but it's what DWARF says, for some reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,Performance,perform,performing,41,"// ... process the type T recursively by performing Steps 2 through 7, and; // use the result as the attribute value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash all of the values in a block like set of values. This assumes that; // all of the data is going to be added as integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash the contents of a loclistptr class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash an individual attribute \param Attr based on the type of attribute and; // the form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:115,Security,hash,hash,115,"// We could add the block length, but that would take; // a bit of work and not add a lot of uniqueness; // to the hash in some way we could test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:141,Testability,test,test,141,"// We could add the block length, but that would take; // a bit of work and not add a lot of uniqueness; // to the hash in some way we could test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:88,Security,hash,hash,88,// Go through the attributes from \param Attrs in the order specified in 7.27.4; // and hash them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:18,Modifiability,extend,extended,18,// FIXME: Add the extended attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:51,Security,hash,hash,51,// Add all of the attributes for \param Die to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:15,Security,hash,hash,15,// Compute the hash of a DIE. This is based on the type signature computation; // given in section 7.27 of the DWARF4 standard. It is the md5 hash of a; // flattened description of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:142,Security,hash,hash,142,// Compute the hash of a DIE. This is based on the type signature computation; // given in section 7.27 of the DWARF4 standard. It is the md5 hash of a; // flattened description of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:8,Security,hash,hash,8,// Then hash each of the children of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:116,Security,hash,hash,116,/// This is based on the type signature computation given in section 7.27 of the; /// DWARF4 standard. It is an md5 hash of the flattened description of the DIE; /// with the inclusion of the full CU and all top level CU entities.; // TODO: Initialize the type chain at 0 instead of 1 for CU signatures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:116,Security,hash,hash,116,/// This is based on the type signature computation given in section 7.27 of the; /// DWARF4 standard. It is an md5 hash of the flattened description of the DIE; /// with the inclusion of additional forms not specifically called out in the; /// standard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:3,Security,Hash,Hash,3,// Hash the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:39,Security,Hash,Hashing,39,"//===-- llvm/CodeGen/DIEHash.h - Dwarf Hashing Framework -------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:421,Security,hash,hashing,421,"//===-- llvm/CodeGen/DIEHash.h - Dwarf Hashing Framework -------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains support for DWARF4 hashing of DIEs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:43,Security,hash,hashing,43,/// An object containing the capability of hashing and adding hash; /// attributes onto a DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:62,Security,hash,hash,62,/// An object containing the capability of hashing and adding hash; /// attributes onto a DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:40,Security,hash,hashing,40,// Collection of all attributes used in hashing a particular DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:10,Integrability,rout,routines,10,// Helper routines to process parts of a DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:52,Security,hash,hash,52,/// Adds the parent context of \param Parent to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:45,Security,hash,hash,45,/// Adds the attributes of \param Die to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:34,Security,hash,hash,34,/// Computes the full DWARF4 7.27 hash of the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:3,Integrability,Rout,Routines,3,// Routines that add DIEValues to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:38,Security,hash,hash,38,// Routines that add DIEValues to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:29,Security,hash,hash,29,/// Adds \param Value to the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:41,Security,hash,hash,41,/// Encodes and adds \param Value to the hash as a ULEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:41,Security,hash,hash,41,/// Encodes and adds \param Value to the hash as a SLEB128.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:27,Security,hash,hash,27,/// Adds \param Str to the hash and includes a NULL byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes the attributes in \param Attrs in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,"/// Hashes the data in a block like DIEValue, e.g. DW_FORM_block or; /// DW_FORM_exprloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes the contents pointed to in the .debug_loc section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes an individual attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes an attribute that refers to another DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes a reference to a named type in such a way that is; /// independent of whether that type is described by a declaration or a; /// definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:4,Security,Hash,Hashes,4,/// Hashes a reference to a previously referenced type DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp:24,Integrability,rout,routine,24,"// Indicate personality routine, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:12,Modifiability,extend,extended,12,// Could be extended to work with DWARFv4 Split DWARF if that's important for; // someone. In that case DW_FORM_data would be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:223,Modifiability,extend,extend,223,"// If we print assembly, we can't separate .file entries according to; // compile units. Thus all files will belong to the default compile unit.; // FIXME: add a better feature test than hasRawTextSupport. Even better,; // extend .file to support this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:177,Testability,test,test,177,"// If we print assembly, we can't separate .file entries according to; // compile units. Thus all files will belong to the default compile unit.; // FIXME: add a better feature test than hasRawTextSupport. Even better,; // extend .file to support this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:17,Modifiability,variab,variable,17,"// If the global variable's type is different from the one in the class; // member type, assume that it's more specific and also emit it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:50,Modifiability,variab,variables,50,// We cannot describe the location of dllimport'd variables: the; // computation of their address requires loads from the IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:107,Performance,load,loads,107,// We cannot describe the location of dllimport'd variables: the; // computation of their address requires loads from the IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.; // Decode DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef; // sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:73,Testability,assert,assert,73,"// 16-bit platforms like MSP430 and AVR take this path, so sink this; // assert to platforms that use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:160,Modifiability,variab,variables,160,"// FIXME This is not guaranteed, but in practice, in static linking,; // if present, __tls_base's index is 1. This doesn't hold for dynamic; // linking, so TLS variables used in dynamic linking won't have; // correct debug info for now. See; // https://github.com/llvm/llvm-project/blob/19afbfe33156d211fa959dadeea46cd17b9c723c/lld/wasm/Driver.cpp#L786-L823",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:51,Modifiability,variab,variable,51,// 2) containing the (relocated) offset of the TLS variable; // within the module's TLS block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:10,Modifiability,variab,variables,10,"// Global variables attached to symbols are memory locations.; // It would be better if this were unconditional, but malformed input that; // mixes non-fragments and fragments for the same variable is too expensive; // to detect in the verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:189,Modifiability,variab,variable,189,"// Global variables attached to symbols are memory locations.; // It would be better if this were unconditional, but malformed input that; // mixes non-fragments and fragments for the same variable is too expensive; // to detect in the verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:222,Safety,detect,detect,222,"// Global variables attached to symbols are memory locations.; // It would be better if this were unconditional, but malformed input that; // mixes non-fragments and fragments for the same variable is too expensive; // to detect in the verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be able to; // correctly interpret address space of the variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:239,Modifiability,extend,extend,239,"// If we have no current ranges just add the range and return, otherwise,; // check the current section and CU against the previous section and CU we; // emitted into and the subprogram was contained within. If these are the; // same then extend our current range, otherwise add this as a new range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:77,Integrability,depend,depend,77,// FIXME: duplicated from Target/WebAssembly/WebAssembly.h; // don't want to depend on target specific headers in this code?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:39,Safety,avoid,avoid,39,"// FIXME: when writing dwo, we need to avoid relocations. Probably; // the ""right"" solution is to treat globals the way func and data; // symbols are (with entries in .debug_addr).; // For now we hardcode the indices in the callsites. Global indices are not; // fixed, but in practice a few are fixed; for example, __stack_pointer is; // always index 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:127,Modifiability,variab,variables,127,// Find DIE for the given subprogram and attach appropriate DW_AT_low_pc; // and DW_AT_high_pc attributes. If there are global variables in this; // scope then create and insert DIEs for these variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:193,Modifiability,variab,variables,193,// Find DIE for the given subprogram and attach appropriate DW_AT_low_pc; // and DW_AT_high_pc attributes. If there are global variables in this; // scope then create and insert DIEs for these variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:292,Integrability,depend,depends,292,"// Basic block sections allows basic block subsets to be placed in unique; // sections. For each section, the begin and end label must be added to the; // list. If there is more than one range, debug ranges must be used.; // Otherwise, low/high PC can be used.; // FIXME: Debug Info Emission depends on block order and this assumes that; // the order of blocks will be frozen beyond this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:12,Modifiability,variab,variables,12,"// Abstract variables don't get common attributes later, so apply them now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address. Decode DW_OP_constu <DWARF Address Space> DW_OP_swap; // DW_OP_xderef sequence for the NVPTX + gdb target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:83,Integrability,interoperab,interoperability,83,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:181,Modifiability,variab,variables,181,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:250,Modifiability,variab,variable,250,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:74,Usability,guid,guide-to-interoperability,74,// According to; // https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf; // cuda-gdb requires DW_AT_address_class for all variables to be; // able to correctly interpret address space of the variable; // address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:15,Modifiability,variab,variables,15,/// Sort local variables so that variables appearing inside of helper; /// expressions come first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:33,Modifiability,variab,variables,33,/// Sort local variables so that variables appearing inside of helper; /// expressions come first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:13,Safety,detect,detection,13,// For cycle detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:3,Performance,Perform,Perform,3,// Perform a stable topological sort by doing a DFS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:24,Integrability,depend,dependencies,24,// Add to Result if all dependencies are visited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:3,Safety,Detect,Detect,3,// Detect cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:8,Integrability,depend,dependencies,8,"// Push dependencies and this node onto the worklist, so that this node is; // visited again after all of its dependencies are handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:110,Integrability,depend,dependencies,110,"// Push dependencies and this node onto the worklist, so that this node is; // visited again after all of its dependencies are handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:13,Integrability,depend,dependency,13,// Don't add dependency if it is in a different lexical scope or a global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:97,Modifiability,variab,variable,97,// Collect lexical scope children first.; // ObjectPointer might be a local (non-argument) local variable if it's a; // block's synthetic this pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:14,Modifiability,variab,variables,14,// Emit local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:251,Modifiability,refactor,refactored,251,"// Some of this is duplicated from DwarfUnit::getOrCreateSubprogramDIE, with; // the important distinction that the debug node is not associated with the; // DIE (since the debug node will be associated with the concrete DIE, if; // any). It could be refactored to some common utility function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:299,Testability,log,logic,299,"// Attach the return PC to allow the debugger to disambiguate call paths; // from one function to another.; //; // The return PC is only really needed when the call /isn't/ a tail call, but; // GDB expects it in DWARF4 mode, even for tail calls (see the comment above; // the DW_AT_call_pc emission logic for an explanation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:62,Modifiability,variab,variables,62,// This is for imported module with renamed entities (such as variables and; // subprograms).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:128,Modifiability,variab,variable,128,"/// Start with the address based on the location provided, and generate the; /// DWARF information necessary to find the actual variable given the extra; /// address information encoded in the DbgVariable, starting from the starting; /// location. Add the DWARF information to the die.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:140,Modifiability,Variab,VariableDie,140,"/// \anchor applyConcreteDbgVariableAttribute; /// \name applyConcreteDbgVariableAttribute; /// Overload set which applies attributes to \c VariableDie based on; /// the active variant of \c DV, which is passed as the first argument.; ///@{; /// See \ref applyConcreteDbgVariableAttribute",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:25,Modifiability,variab,variable,25,/// Get or create global variable DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:134,Modifiability,variab,variables,134,/// Find DIE for the given subprogram and attach appropriate; /// DW_AT_low_pc and DW_AT_high_pc attributes. If there are global; /// variables in this scope then create and insert DIEs for these; /// variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:201,Modifiability,variab,variables,201,/// Find DIE for the given subprogram and attach appropriate; /// DW_AT_low_pc and DW_AT_high_pc attributes. If there are global; /// variables in this scope then create and insert DIEs for these; /// variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:136,Availability,error,error,136,"/// Get a DIE for the given DILexicalBlock.; /// Note that this function assumes that the DIE has been already created; /// and it's an error, if it hasn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:66,Modifiability,variab,variable,66,/// Convenience overload which writes the DIE pointer into an out variable; /// ObjectPointer in addition to returning it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:18,Modifiability,variab,variable,18,/// Find abstract variable associated with Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:128,Modifiability,variab,variable,128,"/// Start with the address based on the location provided, and generate the; /// DWARF information necessary to find the actual variable (navigating the; /// extra location information encoded in the type) based on the starting; /// location. Add the DWARF information to the die.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:116,Integrability,depend,dependant,116,"/// Add attributes to \p Var which reflect the common attributes of \p; /// VariableDie, namely those which are not dependant on the active variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:76,Modifiability,Variab,VariableDie,76,"/// Add attributes to \p Var which reflect the common attributes of \p; /// VariableDie, namely those which are not dependant on the active variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:27,Availability,avail,available,27,// This information is not available while emitting .debug_loc entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Safety,Avoid,Avoid,3,// Avoid building the original CU if it won't be used,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiple DW_OP_stack_values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:21,Performance,load,loaded,21,/// Interpret values loaded into registers by \p CurMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:524,Integrability,depend,dependent,524,"// If an instruction defines more than one item in the worklist, we may run; // into situations where a worklist register's value is (potentially); // described by the previous value of another register that is also defined; // by that instruction.; //; // This can for example occur in cases like this:; //; // $r1 = mov 123; // $r0, $r1 = mvrr $r1, 456; // call @foo, $r0, $r1; //; // When describing $r1's value for the mvrr instruction, we need to make sure; // that we don't finalize an entry value for $r0, as that is dependent on the; // previous value of $r1 (123 rather than 456).; //; // In order to not have to distinguish between those cases when finalizing; // entry values, we simply postpone adding new parameter registers to the; // worklist, by first keeping them in this temporary container until the; // instruction has been handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:691,Usability,simpl,simply,691,"// If an instruction defines more than one item in the worklist, we may run; // into situations where a worklist register's value is (potentially); // described by the previous value of another register that is also defined; // by that instruction.; //; // This can for example occur in cases like this:; //; // $r1 = mov 123; // $r0, $r1 = mvrr $r1, 456; // call @foo, $r0, $r1; //; // When describing $r1's value for the mvrr instruction, we need to make sure; // that we don't finalize an entry value for $r0, as that is dependent on the; // previous value of $r1 (123 rather than 456).; //; // In order to not have to distinguish between those cases when finalizing; // entry values, we simply postpone adding new parameter registers to the; // worklist, by first keeping them in this temporary container until the; // instruction has been handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:129,Testability,Test,Test,129,"// It's possible that we find a copy from a non-volatile register to the param; // register, which is clobbered in the meantime. Test for clobbered reg unit; // overlaps before completing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:132,Integrability,depend,dependent,132,"// ParamFwdReg was described by the non-callee saved register; // RegLoc. Mark that the call site values for the parameters are; // dependent on that register instead of ParamFwdReg. Since RegLoc; // may be a register that will be handled in this iteration, we; // postpone adding the items to the worklist, and instead keep them; // in a temporary container.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Safety,Avoid,Avoid,3,// Avoid NOP description.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:28,Performance,load,loaded,28,/// Try to interpret values loaded into registers that forward parameters; /// for \p CallMI. Store parameters with interpreted value into \p Params.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:112,Performance,load,loaded,112,"// We erase, from the ForwardedRegWorklist, those forwarding registers for; // which we successfully describe a loaded value (by using; // the describeLoadedValue()). For those remaining arguments in the working; // list, for which we do not describe a loaded value by; // the describeLoadedValue(), we try to generate an entry value expression; // for their call site value description, if the call is within the entry MBB.; // TODO: Handle situations when call site parameter value can be described; // as the entry value within basic blocks other than the first one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:253,Performance,load,loaded,253,"// We erase, from the ForwardedRegWorklist, those forwarding registers for; // which we successfully describe a loaded value (by using; // the describeLoadedValue()). For those remaining arguments in the working; // list, for which we do not describe a loaded value by; // the describeLoadedValue(), we try to generate an entry value expression; // for their call site value description, if the call is within the entry MBB.; // TODO: Handle situations when call site parameter value can be described; // as the entry value within basic blocks other than the first one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:16,Performance,load,loading,16,// Search for a loading value in forwarding registers inside call delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:26,Performance,load,loaded,26,// Try to interpret value loaded by instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:16,Performance,load,loading,16,// Search for a loading value in forwarding registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:27,Performance,load,loaded,27,// Try to interpret values loaded by instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:224,Performance,optimiz,optimized-out,224,// Use DW_AT_call_all_calls to express that call site entries are present; // for both tail and non-tail calls. Don't use DW_AT_call_all_source_calls; // because one of its requirements is not met: call site entries for; // optimized-out calls are elided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:52,Testability,test,test,52,// Bundles with call in them will pass the isCall() test below but do not; // have callee operand information so skip them here. Iterator will; // eventually reach the call MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:84,Safety,avoid,avoid,84,"// LTO with assembly output shares a single line table amongst multiple CUs.; // To avoid the compilation directory being ambiguous, let the line table; // explicitly describe the directory of all files, never relying on the; // compilation directory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:10,Modifiability,Variab,Variables,10,// Global Variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:101,Modifiability,variab,variable,101,// Don't bother adding DIGlobalVariableExpressions listed in the CU if we; // already know about the variable and it isn't adding a constant; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:171,Usability,simpl,simple,171,"// FIXME: Consider the time-space tradeoff of just storing the unit pointer; // in the ConcreteEntities list, rather than looking it up again here.; // DIE::getUnit isn't simple - it walks parent pointers, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:36,Security,hash,hash,36,// Include the DWO file name in the hash if there's more than one CU.; // This handles ThinLTO's situation where imported CUs may very easily be; // duplicate with the same CU partially imported into another ThinLTO unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:42,Usability,clear,clear,42,// clean up.; // FIXME: AbstractVariables.clear();,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:11,Modifiability,variab,variable,11,// Collect variable information from side table maintained by MF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:48,Modifiability,variab,variable,48,"// If we have already seen information for this variable, add to what we; // already know.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:52,Performance,optimiz,optimized,52,"// Locations differ, this should (rarely) happen in optimized async; // coroutines.; // Prefer whichever location has an EntryValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Testability,Test,Test,3,// Test if the location terminates before the end of the scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:661,Integrability,depend,depending,661,"/// Build the location list for all DBG_VALUEs in the function that; /// describe the same variable. The resulting DebugLocEntries will have; /// strict monotonically increasing begin addresses and will never; /// overlap. If the resulting list has only one entry that is valid; /// throughout variable's scope return true.; //; // See the definition of DbgValueHistoryMap::Entry for an explanation of the; // different kinds of history map entries. One thing to be aware of is that if; // a debug value is ended by another entry (rather than being valid until the; // end of the function), that entry's instruction may or may not be included in; // the range, depending on if the entry is a clobbering entry (it has an; // instruction that clobbers one or more preceding locations), or if it is an; // (overlapping) debug value entry. This distinction can be seen in the example; // below. The first debug value is ended by the clobbering entry 2, and the; // second and third debug values are ended by the overlapping debug value entry; // 4.; //; // Input:; //; // History map entries [type, end index, mi]; //; // 0 | [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]; // 1 | | [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]; // 2 | | [Clobber, $reg0 = [...], -, -]; // 3 | | [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]; // 4 [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]; //; // Output [start, end) [Value...]:; //; // [0-1) [(reg0, fragment 0, 32)]; // [1-3) [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]; // [3-4) [(reg1, fragment 32, 32), (123, fragment 64, 32)]; // [4-) [(@g, fragment 0, 96)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:91,Modifiability,variab,variable,91,"/// Build the location list for all DBG_VALUEs in the function that; /// describe the same variable. The resulting DebugLocEntries will have; /// strict monotonically increasing begin addresses and will never; /// overlap. If the resulting list has only one entry that is valid; /// throughout variable's scope return true.; //; // See the definition of DbgValueHistoryMap::Entry for an explanation of the; // different kinds of history map entries. One thing to be aware of is that if; // a debug value is ended by another entry (rather than being valid until the; // end of the function), that entry's instruction may or may not be included in; // the range, depending on if the entry is a clobbering entry (it has an; // instruction that clobbers one or more preceding locations), or if it is an; // (overlapping) debug value entry. This distinction can be seen in the example; // below. The first debug value is ended by the clobbering entry 2, and the; // second and third debug values are ended by the overlapping debug value entry; // 4.; //; // Input:; //; // History map entries [type, end index, mi]; //; // 0 | [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]; // 1 | | [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]; // 2 | | [Clobber, $reg0 = [...], -, -]; // 3 | | [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]; // 4 [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]; //; // Output [start, end) [Value...]:; //; // [0-1) [(reg0, fragment 0, 32)]; // [1-3) [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]; // [3-4) [(reg1, fragment 32, 32), (123, fragment 64, 32)]; // [4-) [(@g, fragment 0, 96)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:294,Modifiability,variab,variable,294,"/// Build the location list for all DBG_VALUEs in the function that; /// describe the same variable. The resulting DebugLocEntries will have; /// strict monotonically increasing begin addresses and will never; /// overlap. If the resulting list has only one entry that is valid; /// throughout variable's scope return true.; //; // See the definition of DbgValueHistoryMap::Entry for an explanation of the; // different kinds of history map entries. One thing to be aware of is that if; // a debug value is ended by another entry (rather than being valid until the; // end of the function), that entry's instruction may or may not be included in; // the range, depending on if the entry is a clobbering entry (it has an; // instruction that clobbers one or more preceding locations), or if it is an; // (overlapping) debug value entry. This distinction can be seen in the example; // below. The first debug value is ended by the clobbering entry 2, and the; // second and third debug values are ended by the overlapping debug value entry; // 4.; //; // Input:; //; // History map entries [type, end index, mi]; //; // 0 | [DbgValue, 2, DBG_VALUE $reg0, [...] (fragment 0, 32)]; // 1 | | [DbgValue, 4, DBG_VALUE $reg1, [...] (fragment 32, 32)]; // 2 | | [Clobber, $reg0 = [...], -, -]; // 3 | | [DbgValue, 4, DBG_VALUE 123, [...] (fragment 64, 32)]; // 4 [DbgValue, ~0, DBG_VALUE @g, [...] (fragment 0, 96)]; //; // Output [start, end) [Value...]:; //; // [0-1) [(reg0, fragment 0, 32)]; // [1-3) [(reg0, fragment 0, 32), (reg1, fragment 32, 32)]; // [3-4) [(reg1, fragment 32, 32), (123, fragment 64, 32)]; // [4-) [(@g, fragment 0, 96)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Availability,redundant,redundant,46,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:366,Availability,redundant,redundant,366,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Safety,redund,redundant,46,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:366,Safety,redund,redundant,366,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:62,Availability,redundant,redundant,62,"// Location list entries with empty location descriptions are redundant; // information in DWARF, so do not emit those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:62,Safety,redund,redundant,62,"// Location list entries with empty location descriptions are redundant; // information in DWARF, so do not emit those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:8,Modifiability,variab,variables,8,// Find variables for each lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:12,Modifiability,variab,variable,12,// Grab the variable info that was squirreled away in the MMI side-table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Security,access,accessible,46,"// Instruction ranges, specifying where IV is accessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:29,Modifiability,variab,variable,29,// Try to find any non-empty variable location. Do not create a concrete; // entity if there are no locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:6,Modifiability,variab,variable,6,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:49,Modifiability,variab,variable,49,// If variable scope is not found then skip this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:57,Modifiability,variab,variable,57,// Handle multiple DBG_VALUE instructions describing one variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:36,Modifiability,variab,variable,36,// Build the location list for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:106,Modifiability,variab,variable,106,"// Check whether buildLocationList managed to merge all locations to one; // that is valid throughout the variable's scope. If so, produce single; // value location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:10,Modifiability,variab,variable,10,"// If the variable has a DIBasicType, extract it. Basic types cannot have; // unique identifiers, so don't bother resolving the type with the; // identifier map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:42,Deployability,update,update,42,"// When we emit a line-0 record, we don't update PrevInstLoc; so look at; // the last line number actually emitted, to see if it was line 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:347,Modifiability,inherit,inherit,347,"// See if we have a reason to emit a line-0 record now.; // Reasons to emit a line-0 record include:; // - User asked for it (UnknownLocations).; // - Instruction has a label, so it's referenced from somewhere else,; // possibly debug information; we want it to have a source location.; // - Instruction is at the top of a block; we don't want to inherit the; // location from the physically previous (maybe unrelated) block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:108,Deployability,update,update,108,"// Preserve the file and column numbers, if we can, to save space in; // the encoded line table.; // Do not update PrevInstLoc, it remembers the last non-0 line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:133,Testability,test,testing,133,"// We'd like to list the prologue as ""not statements"" but GDB behaves; // poorly if we do that. Revisit this with caution/GDB (7.5+) testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:20,Modifiability,variab,variables,20,// Collect info for variables/labels that were optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:47,Performance,optimiz,optimized,47,// Collect info for variables/labels that were optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Usability,Clear,Clear,3,// Clear debug info; // Ownership of DbgVariables is a bit subtle - ScopeVariables owns all the; // DbgVariables except those that are also in AbstractVariables (since they; // can be used cross-function),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:29,Security,hash,hashed,29,// Emit visible names into a hashed accelerator table section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:50,Security,hash,hashed,50,// Emit objective C classes and categories into a hashed accelerator table; // section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:30,Security,hash,hashed,30,// Emit namespace dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:25,Security,hash,hashed,25,// Emit type dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,Modifiability,variab,variable,46,// Emit all fragments that belong to the same variable and range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:178,Integrability,depend,dependent,178,"// Fast path if we're building some type units and one has already used the; // address pool we know we're going to throw away all this work anyway, so; // don't bother building dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:116,Integrability,depend,dependent,116,// Remove all the types built while building this type.; // This is pessimistic as some of these types might not be dependent on; // the type that used an address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:83,Integrability,depend,dependent,83,"// Construct this type in the CU directly.; // This is inefficient because all the dependent types will be rebuilt; // from scratch, including building them in type units, discovering that; // they depend on addresses, throwing them out and rebuilding them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:198,Integrability,depend,depend,198,"// Construct this type in the CU directly.; // This is inefficient because all the dependent types will be rebuilt; // from scratch, including building them in type units, discovering that; // they depend on addresses, throwing them out and rebuilding them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:22,Integrability,depend,dependent,22,"// If the type wasn't dependent on fission addresses, finish adding the type; // and all its dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:93,Integrability,depend,dependent,93,"// If the type wasn't dependent on fission addresses, finish adding the type; // and all its dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:22,Security,checksum,checksum,22,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:82,Security,validat,validates,82,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:96,Security,checksum,checksum,96,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:140,Security,checksum,checksum,140,// Convert the string checksum to an MD5Result for the streamer.; // The verifier validates the checksum so we assume it's okay.; // An MD5 checksum is 16 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:190,Modifiability,polymorphi,polymorphism,190,//===----------------------------------------------------------------------===//; /// This class is defined as the common parent of DbgVariable and DbgLabel; /// such that it could levarage polymorphism to extract common code for; /// DbgVariable and DbgLabel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:69,Modifiability,variab,variable,69,"// Add the pair Reg, Expr to the list of entry values describing the variable.; // If multiple expressions are added, it is the callers responsibility to; // ensure they are all non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:138,Modifiability,variab,variable,138,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:170,Modifiability,Variab,Variables,170,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:370,Modifiability,Variab,Variables,370,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:471,Modifiability,variab,variables,471,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:584,Modifiability,Variab,Variables,584,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:706,Modifiability,variab,variables,706,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:852,Modifiability,Variab,Variables,852,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:195,Performance,optimiz,optimized,195,"// namespace Loc; //===----------------------------------------------------------------------===//; /// This class is used to track local variable information.; ///; /// Variables that have been optimized out hold the \c monostate alternative.; /// This is not distinguished from the case of a constructed \c DbgVariable; /// which has not be initialized yet.; ///; /// Variables can be created from allocas, in which case they're generated from; /// the MMI table. Such variables hold the \c Loc::MMI alternative which can; /// have multiple expressions and frame indices.; ///; /// Variables can be created from the entry value of registers, in which case; /// they're generated from the MMI table. Such variables hold the \c; /// EntryValueLoc alternative which can either have a single expression or; /// multiple *fragment* expressions.; ///; /// Variables can be created from \c DBG_VALUE instructions. Those whose; /// location changes over time hold a \c Loc::Multi alternative which uses \c; /// DebugLocListIndex and (optionally) \c DebugLocListTagOffset, while those; /// with a single location hold a \c Loc::Single alternative which use \c; /// ValueLoc and (optionally) a single \c Expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:149,Security,expose,expose,149,"/// To workaround P2162R0 https://github.com/cplusplus/papers/issues/873 the; /// base class subobject needs to be passed directly to std::visit, so expose; /// it directly here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Testability,Assert,Asserting,4,"/// Asserting, noexcept member alternative to std::get",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Testability,Assert,Asserting,4,"/// Asserting, noexcept member alternative to std::get",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:49,Modifiability,variab,variable,49,/// Construct a DbgVariable.; ///; /// Creates a variable without any DW_AT_location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:22,Energy Efficiency,allocate,allocated,22,/// All DIEValues are allocated through this allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:27,Modifiability,variab,variables,27,/// Collection of abstract variables/labels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:10,Performance,optimiz,optimization,10,"/// As an optimization, there is no need to emit an entry in the directory; /// table for the same directory as DW_AT_comp_dir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:84,Security,expose,exposed,84,/// Holders for the various debug information flags that we might need to; /// have exposed. See accessor functions below for description.; /// Map from MDNodes for user-defined types to their type signatures. Also; /// used to keep track of which types we have emitted type units for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:97,Security,access,accessor,97,/// Holders for the various debug information flags that we might need to; /// have exposed. See accessor functions below for description.; /// Map from MDNodes for user-defined types to their type signatures. Also; /// used to keep track of which types we have emitted type units for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Safety,Avoid,Avoid,4,/// Avoid using DW_OP_convert due to consumer incompatibilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:102,Testability,test,testing,102,/// Enable production of call site parameters needed to print the debug entry; /// values. Useful for testing purposes when a debugger does not support the; /// feature yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:20,Modifiability,Variab,Variables,20,"/// Separated Dwarf Variables; /// In general these will all be for bits that are left in the; /// original object file, rather than things that are meant; /// to be in the .dwo sections.; /// Holder for the skeleton information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:30,Security,hash,hashed,30,/// Emit visible names into a hashed accelerator table section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:51,Security,hash,hashed,51,/// Emit objective C classes and categories into a hashed; /// accelerator table section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:31,Security,hash,hashed,31,/// Emit namespace dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:26,Security,hash,hashed,26,/// Emit type dies into a hashed accelerator table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:9,Modifiability,variab,variable,9,/// Emit variable locations into a debug loc section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:9,Modifiability,variab,variable,9,/// Emit variable locations into a debug loc dwo section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:39,Modifiability,variab,variables,39,/// Populate LexicalScope entries with variables' info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:91,Modifiability,variab,variable,91,/// Build the location list for all DBG_VALUEs in the; /// function that describe the same variable. If the resulting; /// list has only one entry that is valid for entire variable's; /// scope return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:172,Modifiability,variab,variable,172,/// Build the location list for all DBG_VALUEs in the; /// function that describe the same variable. If the resulting; /// list has only one entry that is valid for entire variable's; /// scope return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:12,Modifiability,variab,variable,12,/// Collect variable information from the side table maintained by MF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Performance,Perform,Perform,4,/// Perform an MD5 checksum of \p Identifier and return the lower 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:19,Security,checksum,checksum,19,/// Perform an MD5 checksum of \p Identifier and return the lower 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:78,Energy Efficiency,reduce,reduce,78,// Returns whether novel exprloc addrx+offset encodings should be used to; // reduce debug_addr size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:70,Energy Efficiency,reduce,reduce,70,// Returns whether addrx+offset LLVM extension form should be used to reduce; // debug_addr size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:43,Deployability,update,updated,43,/// Returns the previous CU that was being updated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:43,Performance,tune,tune,43,"/// \defgroup DebuggerTuning Predicates to tune DWARF for a given debugger.; ///; /// Returns whether we are ""tuning"" for a given debugger.; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:71,Energy Efficiency,allocate,allocated,71,"/// If the \p File has an MD5 checksum, return it as an MD5Result; /// allocated in the MCContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:30,Security,checksum,checksum,30,"/// If the \p File has an MD5 checksum, return it as an MD5Result; /// allocated in the MCContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:91,Availability,redundant,redundant,91,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:76,Safety,avoid,avoid,76,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:91,Safety,redund,redundant,91,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:94,Performance,perform,perform,94,"// The loop below is emitting the value starting at least significant byte,; // so we need to perform a byte-swap to get the byte order correct in case; // of a big-endian target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:110,Safety,safe,safely,110,"// If the register can only be described by a complex expression (i.e.,; // multiple subregisters) it doesn't safely compose with another complex; // expression. For example, it is not possible to apply a DW_OP_deref; // operation to multiple DW_OP_pieces, since composite location descriptions; // do not push anything on the DWARF stack.; //; // DW_OP_entry_value operations can only hold a DWARF expression or a; // register location description, so we can't emit a single entry value; // covering a composite location description. In the future we may want to; // emit entry value operations for each register location in the composite; // location, but until that is supported do not emit anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:10,Usability,simpl,simple,10,"// Handle simple register locations. If we are supposed to emit; // a call site parameter expression and if that expression is just a register; // location, emit it with addBReg and offset 0, because we should emit a DWARF; // expression representing a value, rather than a location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:17,Availability,mask,mask,17,"// If we need to mask out a subregister, do it now, unless the next; // operation would emit an OpPiece anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:45,Energy Efficiency,efficient,efficient,45,"// Pattern-match combinations for which more efficient representations exist.; // [Reg, DW_OP_plus_uconst, Offset] --> [DW_OP_breg, Offset].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:177,Availability,mask,mask,177,"// [Reg, DW_OP_constu, Offset, DW_OP_plus] --> [DW_OP_breg, Offset]; // [Reg, DW_OP_constu, Offset, DW_OP_minus] --> [DW_OP_breg,-Offset]; // If Reg is a subregister we need to mask it out before subtracting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:17,Availability,mask,mask,17,"// If we need to mask out a subregister, do it now, unless the next; // operation would emit an OpPiece anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:58,Testability,assert,assert,58,"// The temporary buffer can't be emptied, so for now just assert that nothing; // has been emitted to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:33,Usability,simpl,simply,33,"// If targeting a location-list; simply emit the index into the raw; // byte stream as ULEB128, DwarfDebug::emitDebugLocEntry has been; // fitted with means to extract it later.; // If targeting a inlined DW_AT_location; insert a DIEBaseTypeRef; // (containing the index and a resolve mechanism during emit) into the; // DIE value list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:8,Availability,mask,masking,8,/// add masking operations to stencil out a subregister.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:50,Availability,mask,mask,50,// Emit any outstanding DW_OP_piece operations to mask out subregisters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:32,Energy Efficiency,efficient,efficient,32,// Heuristic to decide the most efficient encoding.; // A ULEB can encode 7 1-bits per byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:30,Testability,log,logic,30,"/// Base class containing the logic for constructing DWARF expressions; /// independently of whether they are emitted into a DIE or into a .debug_loc; /// entry.; ///; /// Some DWARF operations, e.g. DW_OP_entry_value, need to calculate the size; /// of a succeeding DWARF block before the latter is emitted to the output.; /// To handle such cases, data can conditionally be emitted to a temporary; /// buffer, which can later on be committed to the main output. The size of the; /// temporary buffer is queryable, allowing for the size of the data to be; /// emitted before the data is committed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:8,Availability,mask,masking,8,/// Add masking operations to stencil out a subregister.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:58,Modifiability,variab,variable,58,/// Emit a DW_OP_piece or DW_OP_bit_piece operation for a variable fragment.; /// \param OffsetInBits This is an optional offset into the location that; /// is at the top of the DWARF stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:188,Availability,avail,available,188,"/// Emit a DW_OP_stack_value, if supported.; ///; /// The proper way to describe a constant value is DW_OP_constu <const>,; /// DW_OP_stack_value. Unfortunately, DW_OP_stack_value was not available; /// until DWARF 4, so we will continue to generate DW_OP_constu <const> for; /// DWARF 2 and DWARF 3. Technically, this is incorrect since DW_OP_const; /// <const> actually describes a value at a constant address, not a constant; /// value. However, in the past there was no better way to describe a; /// constant value, so the producers and consumers started to rely on; /// heuristics to disambiguate the value vs. location status of the; /// expression. See PR21176 for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,Availability,down,down,14,/// Lock this down to become a memory location description.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,Availability,down,down,14,/// Lock this down to become an entry value location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,Availability,down,down,14,/// Lock this down to become a call site parameter location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:126,Energy Efficiency,efficient,efficient,126,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:384,Modifiability,variab,variable,384,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:44,Performance,optimiz,optimization,44,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h:8,Modifiability,variab,variables,8,/// The variables of a lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:218,Safety,redund,redundancy,218,"// When the MDNode can be part of the type system, the DIE can be shared; // across CUs.; // Combining type units and cross-CU DIE sharing is lower value (since; // cross-CU DIE sharing is used in LTO and removes type redundancy at that; // level already) but may be implementable for some value in projects; // building multiple independent libraries with LTO and then linking those; // together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:13,Availability,down,down,13,// Pass this down to addConstantValue as an unsigned bag of bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:87,Modifiability,extend,extended,87,// FIXME: This is a bit conservative/simple - it emits negative values always; // sign extended to 64 bits rather than minimizing the number of bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:37,Usability,simpl,simple,37,// FIXME: This is a bit conservative/simple - it emits negative values always; // sign extended to 64 bits rather than minimizing the number of bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:113,Availability,down,down,113,"// This is to describe the memory location of the; // length of a Fortran deferred length string, so; // lock it down as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:73,Availability,down,down,73,"// This is to describe the memory location of the; // string, so lock it down as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:27,Availability,avail,available,27,// Add source line info if available and TyDesc is not a forward declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:33,Integrability,wrap,wrap,33,"// When emitting a variant part, wrap each member in; // DW_TAG_variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:29,Availability,avail,available,29,// Add accessibility info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:7,Security,access,accessibility,7,// Add accessibility info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:27,Availability,avail,available,27,// Add source line info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:21,Availability,avail,available,21,// Add align info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:106,Performance,load,loads,106,// We cannot describe the location of dllimport'd entities: the; // computation of their address requires loads from the IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:37,Integrability,depend,depending,37,"// Stop here and fill this in later, depending on whether or not this; // subprogram turns out to have inlined instances or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:108,Modifiability,variab,variables,108,// Add arguments. Do not add arguments for subprogram definition. They will; // be handled while processing variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:79,Availability,down,down,79,// Get an anonymous type for index type.; // FIXME: This type should be passed down from the front end; // as different languages may have different sizes for indexes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:21,Energy Efficiency,allocate,allocated,21,// All DIEValues are allocated through this allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:55,Modifiability,variab,variables,55,/// Tracks the mapping of unit level debug information variables to debug; /// information entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:51,Availability,avail,available,51,"// For strict DWARF mode, only generate attributes available to current; // DWARF version.; // Attribute 0 is used when emitting form-encoded values in blocks, which; // don't have attributes (only forms) so we cannot detect their DWARF; // version compatibility here and assume they are compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:218,Safety,detect,detect,218,"// For strict DWARF mode, only generate attributes available to current; // DWARF version.; // Attribute 0 is used when emitting form-encoded values in blocks, which; // don't have attributes (only forms) so we cannot detect their DWARF; // version compatibility here and assume they are compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:53,Modifiability,variab,variable,53,"/// Returns the DIE map slot for the specified debug variable.; ///; /// We delegate the request to DwarfDebug when the MDNode can be part of the; /// type system, since DIEs for the type system can be shared across CUs and; /// the mappings are kept in DwarfDebug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:26,Energy Efficiency,allocate,allocated,26,/// Returns a fresh newly allocated DIELoc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:156,Safety,predict,predictable,156,/// Add a string attribute data and value.; ///; /// We always emit a reference to the string pool instead of immediate; /// strings so that DIEs have more predictable sizes. In the case of split; /// dwarf we emit an index into another table which gets us the static offset; /// into the string table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:32,Modifiability,variab,variable,32,/// Add constant value entry in variable DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:32,Modifiability,variab,variable,32,/// Add constant value entry in variable DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:12,Security,access,accessibility,12,/// Add the accessibility attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:883,Modifiability,variab,variable,883,"// The action table follows the call-site table in the LSDA. The individual; // records are of two types:; //; // * Catch clause; // * Exception specification; //; // The two record kinds have the same format, with only small differences.; // They are distinguished by the ""switch value"" field: Catch clauses; // (TypeInfos) have strictly positive switch values, and exception; // specifications (FilterIds) have strictly negative switch values. Value 0; // indicates a catch-all clause.; //; // Negative type IDs index into FilterIds. Positive type IDs index into; // TypeInfos. The value written for a positive type ID is just the type ID; // itself. For a negative type ID, however, the value written is the; // (negative) byte offset of the corresponding FilterIds entry. The byte; // offset is usually equal to the type ID (because the FilterIds entries are; // written using a variable width encoding, which outputs one byte per entry; // as long as the value written is not too large) but can differ. This kind; // of complication does not occur for positive type IDs because type infos are; // output using a fixed width encoding. FilterOffsets[i] holds the byte; // offset corresponding to FilterIds[i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:3,Modifiability,Extend,Extend,3,// Extend the range of the previous entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:1037,Deployability,update,updated,1037,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:945,Testability,stub,stub,945,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:973,Testability,stub,stub,973,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:1187,Testability,stub,stub,1187,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:1265,Testability,stub,stubs,1265,"// Okay, we have actual filters or typeinfos to emit. As such, we need to; // pick a type encoding for them. We're about to emit a list of pointers to; // typeinfo objects at the end of the LSDA. However, unless we're in static; // mode, this reference will require a relocation by the dynamic linker.; //; // Because of this, we have a couple of options:; //; // 1) If we are in -static mode, we can always use an absolute reference; // from the LSDA, because the static linker will resolve it.; //; // 2) Otherwise, if the LSDA section is writable, we can output the direct; // reference to the typeinfo and allow the dynamic linker to relocate; // it. Since it is in a writable section, the dynamic linker won't; // have a problem.; //; // 3) Finally, if we're in PIC mode and the LDSA section isn't writable,; // we need to use some form of indirection. For example, on Darwin,; // we can output a statically-relocatable reference to a dyld stub. The; // offset to the stub is constant, but the contents are in a section; // that is updated by the dynamic linker. This is easy enough, but we; // need to tell the personality function of the unwinder to indirect; // through the dyld stub.; //; // FIXME: When (3) is actually implemented, we'll have to emit the stubs; // somewhere. This predicate should be moved to a shared location that is; // in target-independent code.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:20,Integrability,depend,dependency,20,// N.B.: There is a dependency loop between the size of the TTBase uleb128; // here and the amount of padding before the aligned type table. The; // assembler must sometimes pad this uleb128 or insert extra padding; // before the type table. See PR35809 or GNU as bug 4029.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:104,Usability,simpl,simply,104,"// For more than one call-site ranges, LPStart must be explicitly; // specified.; // For non-PIC we can simply use the absolute value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:417,Modifiability,plugin,plugin,417,"//===- ErlangGCPrinter.cpp - Erlang/OTP frametable emitter ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the compiler plugin that is used in order to emit; // garbage collection information in a convenient layout for parsing and; // loading in the Erlang/OTP runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:532,Performance,load,loading,532,"//===- ErlangGCPrinter.cpp - Erlang/OTP frametable emitter ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the compiler plugin that is used in order to emit; // garbage collection information in a convenient layout for parsing and; // loading in the Erlang/OTP runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:98,Safety,Safe,SafePointAddress,98,/** A compact GC layout. Emit this data structure:; *; * struct {; * int16_t PointCount;; * void *SafePointAddress[PointCount];; * int16_t StackFrameSize; (in words); * int16_t StackArity;; * int16_t LiveCount;; * int16_t LiveOffsets[LiveCount];; * } __gcmap_<FUNCTIONNAME>;; **/; // Align to address width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:12,Safety,safe,safe,12,// And each safe point...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:27,Safety,safe,safe,27,// Emit the address of the safe point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:37,Safety,safe,safe,37,// Stack information never change in safe points! Only print info from the; // first call-site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp:544,Safety,abort,abort,544,"/// emitAssembly - Print the frametable. The ocaml frametable format is thus:; ///; /// extern ""C"" struct align(sizeof(intptr_t)) {; /// uint16_t NumDescriptors;; /// struct align(sizeof(intptr_t)) {; /// void *ReturnAddress;; /// uint16_t FrameSize;; /// uint16_t NumLiveOffsets;; /// uint16_t LiveOffsets[NumLiveOffsets];; /// } Descriptors[NumDescriptors];; /// } caml${module}__frametable;; ///; /// Note that this precludes programs from stack frames larger than 64K; /// (FrameSize and LiveOffsets would overflow). FrameTablePrinter will abort if; /// either condition is detected in a function which uses the GC.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp:578,Safety,detect,detected,578,"/// emitAssembly - Print the frametable. The ocaml frametable format is thus:; ///; /// extern ""C"" struct align(sizeof(intptr_t)) {; /// uint16_t NumDescriptors;; /// struct align(sizeof(intptr_t)) {; /// void *ReturnAddress;; /// uint16_t FrameSize;; /// uint16_t NumLiveOffsets;; /// uint16_t LiveOffsets[NumLiveOffsets];; /// } Descriptors[NumDescriptors];; /// } caml${module}__frametable;; ///; /// Note that this precludes programs from stack frames larger than 64K; /// (FrameSize and LiveOffsets would overflow). FrameTablePrinter will abort if; /// either condition is detected in a function which uses the GC.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:242,Usability,Guid,Guid,242,"// Gather all the inlined-at nodes.; // When it's done ReversedInlineStack looks like ([66, B], [88, A]); // which means, Function A inlines function B at calliste with a probe id 88,; // and B inlines C at probe 66 where C is represented by Guid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:24,Availability,redundant,redundant,24,// Use caching to avoid redundant md5 computation for build speed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:18,Safety,avoid,avoid,18,// Use caching to avoid redundant md5 computation for build speed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:24,Safety,redund,redundant,24,// Use caching to avoid redundant md5 computation for build speed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h:11,Usability,GUID,GUID,11,"// Name to GUID map, used as caching/memoization for speed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp:472,Performance,load,loaded,472,"// These are symbols used to throw/catch C++ exceptions and C longjmps. These; // symbols have to be emitted somewhere once in the module. Check if each of; // the symbols has already been created, i.e., we have at least one 'throw' or; // 'catch' instruction with the symbol in the module, and emit the symbol only; // if so.; //; // But in dynamic linking, it is in general not possible to come up with a; // module instantiating order in which tag-defining modules are loaded before; // the importing modules. So we make them undefined symbols here, define tags; // in the JS side, and feed them to each importing module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp:110,Integrability,rout,routines,110,"// Compute the call-site table for wasm EH. Even though we use the same function; // name to share the common routines, a call site entry in the table corresponds; // to not a call site for possibly-throwing functions but a landing pad. In wasm; // EH the VM is responsible for stack unwinding. After an exception occurs and; // the stack is unwound, the control flow is transferred to wasm 'catch'; // instruction by the VM, after which the personality function is called from; // the compiler-generated code. Refer to WasmEHPrepare pass for more; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp:325,Safety,risk,risks,325,"// Add the function's symbol to the .gfids section.; // Note: For dllimport functions, MSVC sometimes does not add this symbol; // to the .gfids section, but only adds the corresponding ""__imp_"" symbol; // to the .giats section. Here we always add the symbol to the .gfids; // section, since this does not introduce security risks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp:316,Security,secur,security,316,"// Add the function's symbol to the .gfids section.; // Note: For dllimport functions, MSVC sometimes does not add this symbol; // to the .gfids section, but only adds the corresponding ""__imp_"" symbol; // to the .giats section. Here we always add the symbol to the .gfids; // section, since this does not introduce security risks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:31,Integrability,rout,routine,31,// Determine which personality routine we are using for this funclet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:26,Usability,simpl,simplify,26,// Reject empty ranges to simplify bookkeeping by ensuring that we can get; // the end of the last block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:172,Availability,fault,faults,172,"/// Emit the language-specific data that __C_specific_handler expects. This; /// handler lives in the x64 Microsoft C runtime and allows catching or cleaning; /// up after faults with __try, __except, and __finally. The typeinfo values; /// are not really RTTI data, but pointers to filter functions that return an; /// integer (1, 0, or -1) indicating how to handle the exception. For __finally; /// blocks and other cleanups, the landing pad label is zero, and the filter; /// function is actually a cleanup handler with the same prototype. A catch-all; /// entry is modeled with a null filter function field and a non-zero landing; /// pad label.; ///; /// Possible filter function return values:; /// EXCEPTION_EXECUTE_HANDLER (1):; /// Jump to the landing pad label after cleanups.; /// EXCEPTION_CONTINUE_SEARCH (0):; /// Continue searching this table or continue unwinding.; /// EXCEPTION_CONTINUE_EXECUTION (-1):; /// Resume execution at the trapping PC.; ///; /// Inferred table structure:; /// struct Table {; /// int NumEntries;; /// struct Entry {; /// imagerel32 LabelStart; // Inclusive; /// imagerel32 LabelEnd; // Exclusive; /// imagerel32 FilterOrFinally; // One means catch-all.; /// imagerel32 LabelLPad; // Zero means __finally.; /// } Entries[NumEntries];; /// };",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:926,Usability,Resume,Resume,926,"/// Emit the language-specific data that __C_specific_handler expects. This; /// handler lives in the x64 Microsoft C runtime and allows catching or cleaning; /// up after faults with __try, __except, and __finally. The typeinfo values; /// are not really RTTI data, but pointers to filter functions that return an; /// integer (1, 0, or -1) indicating how to handle the exception. For __finally; /// blocks and other cleanups, the landing pad label is zero, and the filter; /// function is actually a cleanup handler with the same prototype. A catch-all; /// entry is modeled with a null filter function field and a non-zero landing; /// pad label.; ///; /// Possible filter function return values:; /// EXCEPTION_EXECUTE_HANDLER (1):; /// Jump to the landing pad label after cleanups.; /// EXCEPTION_CONTINUE_SEARCH (0):; /// Continue searching this table or continue unwinding.; /// EXCEPTION_CONTINUE_EXECUTION (-1):; /// Resume execution at the trapping PC.; ///; /// Inferred table structure:; /// struct Table {; /// int NumEntries;; /// struct Entry {; /// imagerel32 LabelStart; // Inclusive; /// imagerel32 LabelEnd; // Exclusive; /// imagerel32 FilterOrFinally; // One means catch-all.; /// imagerel32 LabelLPad; // Zero means __finally.; /// } Entries[NumEntries];; /// };",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:86,Availability,recover,recoverfp,86,// Emit a label assignment with the SEH frame offset so we can use it for; // llvm.eh.recoverfp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:86,Safety,recover,recoverfp,86,// Emit a label assignment with the SEH frame offset so we can use it for; // llvm.eh.recoverfp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:171,Testability,test,test,171,"// TODO: The check for UnwindHelpFrameIdx against max() below (and the; // second check further below) can be removed if MS C++ unwinding is; // implemented for ARM, when test/CodeGen/ARM/Windows/wineh-basic.ll; // passes without the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:10,Testability,assert,assert,10,// FIXME: assert that NewState is between CatchLow and CatchHigh.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:108,Availability,recover,recover,108,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:390,Performance,optimiz,optimization,390,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:108,Safety,recover,recover,108,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:95,Testability,assert,assertion,95,// Retrieve the EH Guard slot.; // TODO(etienneb): Get rid of this value and change it for and assertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:35,Deployability,update,update,35,"// For each clause we're starting, update the MinClauseMap so we can; // know which is the topmost funclet containing a clause targeting; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:58,Deployability,update,update,58,// Save the previous current start/label on the stack and update to; // the newly-current start/state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:625,Availability,fault,fault,625,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:897,Availability,fault,fault,897,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:1628,Availability,fault,faulting,1628,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:1903,Availability,fault,fault,1903,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:1515,Testability,log,logic,1515,"// Emit a CORINFO_EH_CLAUSE :; /*; struct CORINFO_EH_CLAUSE; {; CORINFO_EH_CLAUSE_FLAGS Flags; // actually a CorExceptionFlag; DWORD TryOffset;; DWORD TryLength; // actually TryEndOffset; DWORD HandlerOffset;; DWORD HandlerLength; // actually HandlerEndOffset; union; {; DWORD ClassToken; // use for catch clauses; DWORD FilterOffset; // use for filter clauses; };; };. enum CORINFO_EH_CLAUSE_FLAGS; {; CORINFO_EH_CLAUSE_NONE = 0,; CORINFO_EH_CLAUSE_FILTER = 0x0001, // This clause is for a filter; CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause; CORINFO_EH_CLAUSE_FAULT = 0x0004, // This clause is a fault clause; };; typedef enum CorExceptionFlag; {; COR_ILEXCEPTION_CLAUSE_NONE,; COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001, // This is a filter clause; COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002, // This is a finally clause; COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004, // This is a fault clause; COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008, // duplicated clause. This; // clause was duplicated; // to a funclet which was; // pulled out of line; } CorExceptionFlag;; */; // Add 1 to the start/end of the EH clause; the IP associated with a; // call when the runtime does its scan is the IP of the next instruction; // (the one to which control will return after the call), so we need; // to add 1 to the end of the clause to cover that offset. We also add; // 1 to the start of the clause to make sure that the ranges reported; // for all clauses are disjoint. Note that we'll need some additional; // logic when machine traps are supported, since in that case the IP; // that the runtime uses is the offset of the faulting instruction; // itself; if such an instruction immediately follows a call but the; // two belong to different clauses, we'll need to insert a nop between; // them so the runtime can distinguish the point to which the call will; // return from the point at which the fault occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:20,Usability,clear,clear,20,// Leaving bits 0-2 clear indicates catch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h:38,Availability,recover,recoverfp,38,"/// Emits the label used with llvm.eh.recoverfp, which is used by; /// outlined funclets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h:38,Safety,recover,recoverfp,38,"/// Emits the label used with llvm.eh.recoverfp, which is used by; /// outlined funclets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:422,Usability,simpl,simple,422,"//===-- lib/CodeGen/GlobalISel/CallLowering.cpp - Call lowering -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements some simple delegations needed for call lowering.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:26,Deployability,update,updates,26,/// Helper function which updates \p Flags when \p AttrFn returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:18,Safety,avoid,avoided,18,"// We should have avoided introducing a new virtual register, and just; // directly assigned here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:26,Modifiability,extend,extending,26,// A vector PartLLT needs extending to LLTy's element size.; // E.g. <2 x s64> = G_SEXT <2 x s32>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:38,Modifiability,extend,extended,38,// Sometimes pointers are passed zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:201,Modifiability,Extend,Extend,201,"// If PartLLT is a mismatched vector in both number of elements and element; // size, e.g. PartLLT == v2s64 and LLTy is v3s32, then first coerce it to; // have the same elt type, i.e. v4s32.; // TODO: Extend this coersion to element multiples other than just 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:86,Safety,avoid,avoid,86,// Pointer information was discarded. We'll need to coerce some register types; // to avoid violating type constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:146,Modifiability,Extend,ExtendOp,146,/// Create a sequence of instructions to expand the value in \p SrcReg (of type; /// \p SrcTy) to the types in \p DstRegs (of type \p PartTy). \p ExtendOp should; /// contain the type of scalar value extension if necessary.; ///; /// This is used for outgoing values (vregs to physregs),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:43,Modifiability,extend,extended,43,"// Vector was scalarized, and the elements extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:53,Usability,simpl,simple,53,"// If this already evenly divisible, we can create a simple unmerge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:48,Usability,simpl,simple,48,"// For scalars, it's common to be able to use a simple extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:64,Modifiability,extend,extend,64,// Widen to the common type.; // FIXME: This should respect the extend type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:29,Modifiability,extend,extend,29,"// The x32 ABI wants to zero extend 32-bit pointers to 64-bit registers, so; // we have to cast to do the extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:421,Energy Efficiency,schedul,schedule,421,"// end namespace llvm; /// This class acts as the glue the joins the CombinerHelper to the overall; /// Combine algorithm. The CombinerHelper is intended to report the; /// modifications it makes to the MIR to the GISelChangeObserver and the; /// observer subclass will act on these events. In this case, instruction; /// erasure will cancel any future visits to the erased instruction and; /// instruction creation will schedule that instruction for a future visit.; /// Other Combiner implementations may require more complex behaviour from; /// their GISelChangeObserver subclass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running this pass.; // FIXME: Should this be here or in individual combiner passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:157,Availability,down,down,157,"// Collect all instructions. Do a post order traversal for basic blocks and; // insert with list bottom up, so while we pop_back_val, we'll traverse top; // down RPOT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:19,Testability,test,testing,19,// Option to allow testing of the combiner while no targets know about indexed; // addressing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:60,Performance,load,load,60,"/// Given a map from byte offsets in memory to indices in a load/store,; /// determine if that map corresponds to a little or big endian byte pattern.; ///; /// \param MemOffset2Idx maps memory offsets to address offsets.; /// \param LowestIdx is the lowest index in \p MemOffset2Idx.; ///; /// \returns true if the map corresponds to a big endian byte pattern, false if; /// it corresponds to a little endian byte pattern, and std::nullopt otherwise.; ///; /// E.g. given a 32-bit type x, and x[AddrOffset], the in-memory byte patterns; /// are as follows:; ///; /// AddrOffset Little endian Big endian; /// 0 0 3; /// 1 1 2; /// 2 2 1; /// 3 3 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Availability,redundant,redundant,28,"// Note: IsUndef is sort of redundant. We could have determine it by; // checking that at all Ops are undef. Alternatively, we could have; // generate a build_vector of undefs and rely on another combine to; // clean that up. For now, given we already gather this information; // in tryCombineConcatVectors, just save compile time and issue the; // right thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Safety,redund,redundant,28,"// Note: IsUndef is sort of redundant. We could have determine it by; // checking that at all Ops are undef. Alternatively, we could have; // generate a build_vector of undefs and rely on another combine to; // clean that up. For now, given we already gather this information; // in tryCombineConcatVectors, just save compile time and issue the; // right thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:287,Usability,clear,clear,287,"// If the resulting vector is smaller than the size of the source; // vectors being concatenated, we won't be able to replace the; // shuffle vector into a concat_vectors.; //; // Note: We may still be able to produce a concat_vectors fed by; // extract_vector_elt and so on. It is less clear that would; // be better though, so don't bother for now.; //; // If the destination is a scalar, the size of the sources doesn't; // matter. we will lower the shuffle to a plain copy. This will; // work only if the source and destination have the same size. But; // that's covered by the next condition.; //; // TODO: If the size between the source and destination don't match; // we could still emit an extract vector element in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Availability,mask,mask,26,// Check that the shuffle mask can be broken evenly between the; // different sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Availability,Mask,Mask,3,// Mask length is a multiple of the source vector length.; // Check if the shuffle is some kind of concatenation of the input; // vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:344,Energy Efficiency,reduce,reduce,344,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:17,Modifiability,extend,extend,17,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:102,Modifiability,extend,extending,102,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:167,Modifiability,extend,extend,167,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:235,Modifiability,extend,extend,235,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:112,Performance,load,loads,112,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:158,Performance,load,load,158,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:252,Performance,load,load,252,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:139,Modifiability,extend,extend,139,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:179,Modifiability,rewrite,rewrite,179,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:194,Modifiability,extend,extend,194,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:218,Modifiability,extend,extend,218,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Performance,load,load,116,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:146,Performance,load,load,146,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:201,Performance,load,load,201,"// Prefer sign extensions to zero extensions as sign-extensions tend to be; // more expensive. Don't do this if the load is already a zero-extend load; // though, otherwise we'll rewrite a zero-extend load into a sign-extend; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:169,Energy Efficiency,reduce,reduced,169,// This is potentially target specific. We've chosen the largest type; // because G_TRUNC is usually free. One potential catch with this is that; // some targets have a reduced number of larger registers than smaller; // registers and this choice potentially increases the live-range for the; // larger value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:49,Modifiability,extend,extend,49,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:84,Modifiability,extend,extends,84,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:279,Modifiability,extend,extend,279,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:16,Performance,load,loads,16,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:121,Performance,load,load,121,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:147,Performance,load,load,147,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:350,Performance,load,load,350,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:393,Performance,perform,performance,393,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:244,Safety,safe,safe,244,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,Performance,load,loads,48,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:81,Performance,load,load,81,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:174,Performance,perform,perform,174,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:256,Performance,load,load,256,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:125,Security,access,accesses,125,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:11,Energy Efficiency,power,power-of-,11,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:128,Modifiability,extend,extending,128,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:82,Performance,load,loads,82,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:138,Performance,load,loads,138,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:46,Modifiability,extend,extends,46,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Modifiability,extend,extending,93,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:122,Modifiability,extend,extending,122,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:181,Modifiability,extend,extend,181,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:282,Modifiability,extend,extend,282,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:313,Modifiability,extend,extend,313,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:132,Performance,load,load,132,"// Find the preferred type aside from the any-extends (unless it's the only; // one) and non-extending ops. We'll emit an extending load to that type and; // and emit a variant of (extend (trunc X)) for the others according to the; // relative type sizes. At the same time, pick an extend to use based on the; // extend involved in the chosen type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:17,Modifiability,extend,extends,17,// There were no extends,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:39,Modifiability,extend,extend,39,// It should be impossible to chose an extend without selecting a different; // type since by definition the result of an extend is larger.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:122,Modifiability,extend,extend,122,// It should be impossible to chose an extend without selecting a different; // type since by definition the result of an extend is larger.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:34,Modifiability,extend,extending,34,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Performance,load,load,15,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Performance,load,load,44,// Rewrite the load to the chosen extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all the uses to fix up the types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Modifiability,extend,extend,10,// If the extend is compatible with the preferred extend then we should fix; // up the type and extend so that it uses the preferred use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:50,Modifiability,extend,extend,50,// If the extend is compatible with the preferred extend then we should fix; // up the type and extend so that it uses the preferred use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:96,Modifiability,extend,extend,96,// If the extend is compatible with the preferred extend then we should fix; // up the type and extend so that it uses the preferred use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Modifiability,extend,extend,93,"// If the use has the same type as the preferred use, then merge; // the vregs and erase the extend. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s32) = G_ANYEXT %1(s8); // ... = ... %3(s32); // rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // ... = ... %2(s32)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:228,Modifiability,rewrite,rewrites,228,"// If the use has the same type as the preferred use, then merge; // the vregs and erase the extend. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s32) = G_ANYEXT %1(s8); // ... = ... %3(s32); // rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // ... = ... %2(s32)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:51,Modifiability,extend,extend,51,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:62,Modifiability,extend,extend,62,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:96,Modifiability,extend,extending,96,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:240,Modifiability,rewrite,rewrites,240,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:106,Performance,load,load,106,"// If the preferred size is smaller, then keep the extend but extend; // from the result of the extending load. For example:; // %1:_(s8) = G_LOAD ...; // %2:_(s32) = G_SEXT %1(s8); // %3:_(s64) = G_ANYEXT %1(s8); // ... = ... %3(s64); /// rewrites to:; // %2:_(s32) = G_SEXTLOAD ...; // %3:_(s64) = G_ANYEXT %2:_(s32); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:189,Modifiability,rewrite,rewrites,189,"// If the preferred size is large, then insert a truncate. For; // example:; // %1:_(s8) = G_LOAD ...; // %2:_(s64) = G_SEXT %1(s8); // %3:_(s32) = G_ZEXT %1(s8); // ... = ... %3(s32); /// rewrites to:; // %2:_(s64) = G_SEXTLOAD ...; // %4:_(s8) = G_TRUNC %2:_(s32); // %3:_(s64) = G_ZEXT %2:_(s8); // ... = ... %3(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:90,Deployability,update,update,90,// The use is (one of) the uses of the preferred use we chose earlier.; // We're going to update the load to def this value later so just erase; // the old extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:156,Modifiability,extend,extend,156,// The use is (one of) the uses of the preferred use we chose earlier.; // We're going to update the load to def this value later so just erase; // the old extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:101,Performance,load,load,101,// The use is (one of) the uses of the preferred use we chose earlier.; // We're going to update the load to def this value later so just erase; // the old extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:20,Modifiability,extend,extend,20,// The use isn't an extend. Truncate back to the type we originally loaded.; // This is free on many targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:68,Performance,load,loaded,68,// The use isn't an extend. Truncate back to the type we originally loaded.; // This is free on many targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:39,Availability,mask,mask,39,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:118,Availability,mask,mask,118,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:85,Performance,load,load,85,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:179,Performance,load,load,179,"// If we have the following code:; // %mask = G_CONSTANT 255; // %ld = G_LOAD %ptr, (load s16); // %and = G_AND %ld, %mask; //; // Try to fold it into; // %ld = G_ZEXTLOAD %ptr, (load s8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Availability,mask,mask,7,"// The mask may not be larger than the in-memory type, as it might cover sign; // extended bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:82,Modifiability,extend,extended,82,"// The mask may not be larger than the in-memory type, as it might cover sign; // extended bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Availability,mask,mask,10,"// If the mask covers the whole destination register, there's nothing to; // extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:77,Modifiability,extend,extend,77,"// If the mask covers the whole destination register, there's nothing to; // extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:33,Performance,load,loads,33,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:96,Performance,load,loads,96,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:123,Performance,load,loads,123,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:103,Safety,Avoid,Avoid,103,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:27,Security,access,access,27,"// Don't modify the memory access size if this is atomic/volatile, but we can; // still adjust the opcode to indicate the high bit behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Energy Efficiency,reduce,reduced,44,// TODO: Could check if it's legal with the reduced or original memory size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:85,Modifiability,extend,extend,85,"// If the source is a G_SEXTLOAD from the same bit width, then we don't; // need any extend at all, just a truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:40,Modifiability,extend,extended,40,"// If truncating more than the original extended value, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:56,Safety,abort,abort,56,"// If truncating more than the original extended value, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Modifiability,extend,extend,15,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Modifiability,extend,extends,22,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:61,Performance,load,load,61,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:102,Performance,load,load,102,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:169,Performance,load,load,169,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:150,Safety,Avoid,Avoid,150,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:31,Energy Efficiency,power,power-,31,"// Don't bother creating a non-power-2 sextload, it will likely be broken up; // anyway for most targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:27,Security,access,access,27,"// Don't modify the memory access size if this is atomic/volatile, but we can; // still adjust the opcode to indicate the high bit behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Energy Efficiency,reduce,reduced,44,// TODO: Could check if it's legal with the reduced or original memory size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:53,Performance,load,load,53,"// If we have the following:; // %ld = G_LOAD %ptr, (load 2); // %ext = G_SEXT_INREG %ld, 8; // ==>; // %ld = G_SEXTLOAD %ptr (load 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:127,Performance,load,load,127,"// If we have the following:; // %ld = G_LOAD %ptr, (load 2); // %ext = G_SEXT_INREG %ld, 8; // ==>; // %ld = G_SEXTLOAD %ptr (load 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,Performance,load,load,29,/// Return true if 'MI' is a load or a store that may be fold it's address; /// operand into the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:97,Performance,load,load,97,/// Return true if 'MI' is a load or a store that may be fold it's address; /// operand into the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:55,Performance,load,load,55,"// We're looking for the following pattern, for either load or store:; // %baseptr:_(p0) = ...; // G_STORE %val(s64), %baseptr(p0); // %offset:_(s64) = G_CONSTANT i64 -256; // %new_addr:_(p0) = G_PTR_ADD %baseptr, %offset(s64)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Safety,avoid,avoid,10,// Try to avoid exploding compile time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Performance,load,load,26,"// If the user is a later load/store that can be post-indexed, then don't; // combine this one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,Performance,load,load,36,// All use must be dominated by the load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing cross-block register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,Performance,load,load,36,"// All use must be dominated by the load/store.; // If Ptr may be folded in addressing mode of other use, then it's; // not profitable to do this transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:23,Performance,load,load,23,// Check if there is a load that defines the vector being extracted from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:30,Energy Efficiency,reduce,reduce,30,// Checking whether we should reduce the load width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:41,Performance,load,load,41,// Checking whether we should reduce the load width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:25,Performance,load,load,25,// Check if the defining load is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:33,Usability,simpl,simple,33,// Check if the defining load is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Performance,load,load,116,// If the vector element type is not a multiple of a byte then we are unable; // to correctly compute an address to load only the extracted element as a; // scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:20,Performance,load,load,20,// Check if the new load that we are going to create is legal; // if we are in the post-legalization phase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:133,Performance,load,load,133,// Finding the appropriate PtrInfo if offset is a known constant.; // This is required to create the memory operand for the narrowed load.; // This machine memory operand object helps us infer about legality; // before we proceed to combine the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:136,Modifiability,variab,variable,136,// Discard the pointer info except the address space because the memory; // operand can't represent this new access since the offset is variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:109,Security,access,access,109,// Discard the pointer info except the address space because the memory; // operand can't represent this new access since the offset is variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,Load,Load,3,// Load must be allowed and fast on the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:56,Performance,load,load,56,"// If the offset constant didn't happen to dominate the load/store, we can; // just clone it as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:201,Safety,avoid,avoiding,201,"// Check which instruction is first in the block so we don't break def-use; // deps by ""moving"" the instruction incorrectly. Also keep track of which; // instruction is first so we pick it's operands, avoiding use-before-def; // bugs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:394,Safety,predict,predictors,394,"// Try to match the following:; // bb1:; // G_BRCOND %c1, %bb2; // G_BR %bb3; // bb2:; // ...; // bb3:; // The above pattern does not have a fall through to the successor bb2, always; // resulting in a branch no matter which path is taken. Here we try to find; // and replace that pattern with conditional branch to bb3 and otherwise; // fallthrough to bb2. This is generally better for branch predictors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:46,Integrability,depend,depending,46,"// Convert `APFloat` to appropriate IEEE type depending on `DstTy`. Otherwise,; // `buildFConstant` will assert on size mismatch. Only `G_FSQRT`, and; // `G_FLOG2` reach here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:105,Testability,assert,assert,105,"// Convert `APFloat` to appropriate IEEE type depending on `DstTy`. Otherwise,; // `buildFConstant` will assert on size mismatch. Only `G_FSQRT`, and; // `G_FLOG2` reach here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:170,Performance,load,load,170,"// Check if the new combined immediate forms an illegal addressing mode.; // Do not combine if it was legal before but would get illegal.; // To do so, we need to find a load/store user of the pointer to get; // the access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:216,Security,access,access,216,"// Check if the new combined immediate forms an illegal addressing mode.; // Do not combine if it was legal before but would get illegal.; // To do so, we need to find a load/store user of the pointer to get; // the access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Usability,simpl,simple,15,// There is no simple replacement for a saturating unsigned left shift that; // exceeds the scalar size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Testability,log,logical,7,// Any logical shift that exceeds scalar size will produce zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:170,Testability,log,logic,170,"// We're trying to match the following pattern with any of; // G_SHL/G_ASHR/G_LSHR/G_USHLSAT/G_SSHLSAT shift instructions in combination; // with any of G_AND/G_OR/G_XOR logic instructions.; // %t1 = SHIFT %X, G_CONSTANT C0; // %t2 = LOGIC %t1, %Y; // %root = SHIFT %t2, G_CONSTANT C1; // -->; // %t3 = SHIFT %X, G_CONSTANT (C0+C1); // %t4 = SHIFT %Y, G_CONSTANT C1; // %root = LOGIC %t3, %t4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:234,Testability,LOG,LOGIC,234,"// We're trying to match the following pattern with any of; // G_SHL/G_ASHR/G_LSHR/G_USHLSAT/G_SSHLSAT shift instructions in combination; // with any of G_AND/G_OR/G_XOR logic instructions.; // %t1 = SHIFT %X, G_CONSTANT C0; // %t2 = LOGIC %t1, %Y; // %root = SHIFT %t2, G_CONSTANT C1; // -->; // %t3 = SHIFT %X, G_CONSTANT (C0+C1); // %t4 = SHIFT %Y, G_CONSTANT C1; // %root = LOGIC %t3, %t4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:378,Testability,LOG,LOGIC,378,"// We're trying to match the following pattern with any of; // G_SHL/G_ASHR/G_LSHR/G_USHLSAT/G_SSHLSAT shift instructions in combination; // with any of G_AND/G_OR/G_XOR logic instructions.; // %t1 = SHIFT %X, G_CONSTANT C0; // %t2 = LOGIC %t1, %Y; // %root = SHIFT %t2, G_CONSTANT C1; // -->; // %t3 = SHIFT %X, G_CONSTANT (C0+C1); // %t4 = SHIFT %Y, G_CONSTANT C1; // %root = LOGIC %t3, %t4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:27,Testability,log,logic,27,// Match a one-use bitwise logic op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Testability,Log,Logic,3,"// Logic ops are commutative, so check each operand for a match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:311,Safety,avoid,avoid,311,"// If LogicNonShiftReg is the same to Shift1Base, and shift1 const is the same; // to MatchInfo.Shift2 const, CSEMIRBuilder will reuse the old shift1 when; // build shift2. So, if we erase MatchInfo.Shift2 at the end, actually we; // remove old shift1. And it will cause crash later. So erase it earlier to; // avoid the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:6,Testability,Log,LogicNonShiftReg,6,"// If LogicNonShiftReg is the same to Shift1Base, and shift1 const is the same; // to MatchInfo.Shift2 const, CSEMIRBuilder will reuse the old shift1 when; // build shift2. So, if we erase MatchInfo.Shift2 at the end, actually we; // remove old shift1. And it will cause crash later. So erase it earlier to; // avoid the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Safety,safe,safe,28,// This was one use so it's safe to remove it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:9,Availability,down,down,9,// Break down the big constant in smaller ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Usability,simpl,simplify,116,"// G_ZEXT on vector applies to each lane, so it will; // affect all destinations. Therefore we won't be able; // to simplify the unmerge to just the first definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:23,Energy Efficiency,reduce,reduce,23,"// TODO: We could also reduce to 16 bits, but that's more target-dependent.; // Some targets like it, some don't, some only like it under certain; // conditions/processor versions, etc.; // A TL hook might be needed for this.; // Don't combine",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:65,Integrability,depend,dependent,65,"// TODO: We could also reduce to 16 bits, but that's more target-dependent.; // Some targets like it, some don't, some only like it under certain; // conditions/processor versions, etc.; // A TL hook might be needed for this.; // Don't combine",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:35,Performance,load,loads,35,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:158,Performance,load,load,158,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:236,Performance,load,load,236,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:376,Performance,load,loading,376,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:429,Performance,load,loads,429,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:396,Safety,safe,safe,396,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Performance,load,loads,28,"// If both instructions are loads or stores, they are equal only if both; // are dereferenceable invariant loads with the same number of bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:107,Performance,load,loads,107,"// If both instructions are loads or stores, they are equal only if both; // are dereferenceable invariant loads with the same number of bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:61,Safety,avoid,avoid,61,// Check for physical registers on the instructions first to avoid cases; // like this:; //; // %a = COPY $physreg; // ...; // SOMETHING implicit-def $physreg; // ...; // %b = COPY $physreg; //; // These copies are not equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Modifiability,Variab,Variable,3,// Variable index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Testability,log,logic,12,"// Matches: logic (hand x, ...), (hand y, ...) -> hand (logic x, y), ...; //; // Creates the new hand + logic instruction (but does not insert them.); //; // On success, MatchInfo is populated with the new instructions. These are; // inserted in applyHoistLogicOpWithSameOpcodeHands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:56,Testability,log,logic,56,"// Matches: logic (hand x, ...), (hand y, ...) -> hand (logic x, y), ...; //; // Creates the new hand + logic instruction (but does not insert them.); //; // On success, MatchInfo is populated with the new instructions. These are; // inserted in applyHoistLogicOpWithSameOpcodeHands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:104,Testability,log,logic,104,"// Matches: logic (hand x, ...), (hand y, ...) -> hand (logic x, y), ...; //; // Creates the new hand + logic instruction (but does not insert them.); //; // On success, MatchInfo is populated with the new instructions. These are; // inserted in applyHoistLogicOpWithSameOpcodeHands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Testability,log,logic,10,"// Match: logic (ext X), (ext Y) --> ext (logic X, Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:42,Testability,log,logic,42,"// Match: logic (ext X), (ext Y) --> ext (logic X, Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,Testability,log,logic,10,"// Match: logic (binop x, z), (binop y, z) -> binop (logic x, y), z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:53,Testability,log,logic,53,"// Match: logic (binop x, z), (binop y, z) -> binop (logic x, y), z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:75,Testability,log,logic,75,"// Record the steps to build the new instructions.; //; // Steps to build (logic x, y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:24,Testability,log,logic,24,"// Steps to build hand (logic x, y), ...z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:18,Availability,Mask,Mask,18,"// Check that x & Mask == x.; // x & 1 == x, always; // x & 0 == x, only if x is also 0; // Meaning Mask has no effect if every bit is either one in Mask or zero in x.; //; // Check if we can replace AndDst with the LHS of the G_AND",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Availability,Mask,Mask,100,"// Check that x & Mask == x.; // x & 1 == x, always; // x & 0 == x, only if x is also 0; // Meaning Mask has no effect if every bit is either one in Mask or zero in x.; //; // Check if we can replace AndDst with the LHS of the G_AND",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:149,Availability,Mask,Mask,149,"// Check that x & Mask == x.; // x & 1 == x, always; // x & 0 == x, only if x is also 0; // Meaning Mask has no effect if every bit is either one in Mask or zero in x.; //; // Check if we can replace AndDst with the LHS of the G_AND",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:18,Availability,Mask,Mask,18,"// Check that x | Mask == x.; // x | 0 == x, always; // x | 1 == x, only if x is also 1; // Meaning Mask has no effect if every bit is either zero in Mask or one in x.; //; // Check if we can replace OrDst with the LHS of the G_OR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Availability,Mask,Mask,100,"// Check that x | Mask == x.; // x | 0 == x, always; // x | 1 == x, only if x is also 1; // Meaning Mask has no effect if every bit is either zero in Mask or one in x.; //; // Check if we can replace OrDst with the LHS of the G_OR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:150,Availability,Mask,Mask,150,"// Check that x | Mask == x.; // x | 0 == x, always; // x | 1 == x, only if x is also 1; // Meaning Mask has no effect if every bit is either zero in Mask or one in x.; //; // Check if we can replace OrDst with the LHS of the G_OR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:32,Modifiability,extend,extended,32,"// If the input is already sign extended, just drop the extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:47,Energy Efficiency,power,power,47,/// The second source operand is known to be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:161,Modifiability,variab,variable,161,"// We know that one of the operands is a select of constants. Now verify that; // the other binary operator operand is either a constant, or we can handle a; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:79,Performance,load,loads,79,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:112,Performance,load,load,112,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:385,Performance,load,load,385,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:14,Safety,detect,detect,14,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:45,Performance,load,load,45,"// In the ""worst"" case, we're dealing with a load for each byte. So, there; // are at most #bytes - 1 ORs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Performance,load,load,100,"// If it's a G_OR, save it and continue to walk. If it's not, then it's; // something that may be a load + arithmetic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:59,Energy Efficiency,power,power-of-,59,"// We're going to try and merge each register into a wider power-of-2 type,; // so we ought to have an even number of registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,Performance,load,loading,100,"/// Helper function for findLoadOffsetsForLoadOrCombine.; ///; /// Check if \p Reg is the result of loading a \p MemSizeInBits wide value,; /// and then moving that value into a specific byte offset.; ///; /// e.g. x[i] << 24; ///; /// \returns The load instruction and the byte offset it is moved into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:249,Performance,load,load,249,"/// Helper function for findLoadOffsetsForLoadOrCombine.; ///; /// Check if \p Reg is the result of loading a \p MemSizeInBits wide value,; /// and then moving that value into a specific byte offset.; ///; /// e.g. x[i] << 24; ///; /// \returns The load instruction and the byte offset it is moved into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:31,Performance,load,loads,31,// TODO: Handle other types of loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:8,Performance,load,load,8,// Each load found for the pattern. There should be one for each RegsToVisit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:32,Performance,load,load,32,"// The lowest index used in any load. (The lowest ""i"" for each x[i].)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Performance,load,load,7,// The load which uses the lowest index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Performance,load,load,22,// Keeps track of the load indices we see. We shouldn't see any indices twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,Performance,load,load,15,// Ensure each load is in the same MBB.; // TODO: Support multiple MachineBasicBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:30,Performance,load,load,30,// Earliest instruction-order load in the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Performance,load,load,28,// Latest instruction-order load in the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,Performance,load,load,28,// Base pointer which every load should share.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:21,Performance,load,load,21,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:50,Performance,load,load,50,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:167,Performance,load,load,167,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:275,Performance,load,load,275,"// We want to find a load for each register. Each load should have some; // appropriate bit twiddling arithmetic. During this loop, we will also keep; // track of the load which uses the lowest index. Later, we will check if we; // can use its pointer in the final, combined load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Performance,load,load,12,"// Find the load, and find the position that it will end up in (e.g. a; // shifted) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:133,Performance,load,loads,133,// TODO: Handle multiple MachineBasicBlocks. Currently not handled because; // it is difficult to check for stores/calls/etc between loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:55,Performance,load,load,55,// Make sure that the MachineMemOperands of every seen load are compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:52,Performance,load,load,52,// Find out what the base pointer and index for the load is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:52,Performance,load,load,52,"// Don't combine things like a[i], a[i] -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:9,Performance,load,load,9,"// Every load must share the same base pointer; don't combine things like:; //; // a[i], b[i + 1] -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:110,Performance,load,load,110,"// Every load must share the same base pointer; don't combine things like:; //; // a[i], b[i + 1] -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:43,Performance,load,load,43,"// Keep track of the byte offset that this load ends up at. If we have seen; // the byte offset, then stop here. We do not want to combine:; //; // a[i] << 16, a[i + k] << 16 -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:187,Performance,load,load,187,"// Keep track of the byte offset that this load ends up at. If we have seen; // the byte offset, then stop here. We do not want to combine:; //; // a[i] << 16, a[i + k] << 16 -> a bigger load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:53,Performance,load,loads,53,// Keep track of the position of the earliest/latest loads in the pattern.; // We will check that there are no load fold barriers between them later; // on.; //; // FIXME: Is there a better way to check for load fold barriers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:111,Performance,load,load,111,// Keep track of the position of the earliest/latest loads in the pattern.; // We will check that there are no load fold barriers between them later; // on.; //; // FIXME: Is there a better way to check for load fold barriers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:207,Performance,load,load,207,// Keep track of the position of the earliest/latest loads in the pattern.; // We will check that there are no load fold barriers between them later; // on.; //; // FIXME: Is there a better way to check for load fold barriers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:14,Performance,load,load,14,// We found a load for each register. Let's check if each load satisfies the; // pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:58,Performance,load,load,58,// We found a load for each register. Let's check if each load satisfies the; // pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:65,Performance,load,loads,65,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:111,Performance,perform,perform,111,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:332,Performance,load,load,332,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:104,Safety,safe,safely,104,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:252,Testability,test,test,252,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:35,Performance,load,loads,35,"// We need to combine at least two loads into this type. Since the smallest; // possible load is into a byte, we need at least a 16-bit wide type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:89,Performance,load,load,89,"// We need to combine at least two loads into this type. Since the smallest; // possible load is into a byte, we need at least a 16-bit wide type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:90,Performance,load,loads,90,// We have a collection of non-OR instructions. Figure out how wide each of; // the small loads should be based off of the number of potential loads we; // found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:143,Performance,load,loads,143,// We have a collection of non-OR instructions. Figure out how wide each of; // the small loads should be based off of the number of potential loads we; // found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:52,Performance,load,load,52,"// Check if each register feeding into each OR is a load from the same; // base pointer + some arithmetic.; //; // e.g. a[0], a[1] << 8, a[2] << 16, etc.; //; // Also verify that each of these ends up putting a[i] into the same memory; // offset as a load into a wide type would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:251,Performance,load,load,251,"// Check if each register feeding into each OR is a load from the same; // base pointer + some arithmetic.; //; // e.g. a[0], a[1] << 8, a[2] << 16, etc.; //; // Also verify that each of these ends up putting a[i] into the same memory; // offset as a load into a wide type would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Performance,load,loads,22,"// We have a bunch of loads being OR'd together. Using the addresses + offsets; // we found before, check if this corresponds to a big or little endian byte; // pattern. If it does, then we can represent it using a load + possibly a; // BSWAP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:215,Performance,load,load,215,"// We have a bunch of loads being OR'd together. Using the addresses + offsets; // we found before, check if this corresponds to a big or little endian byte; // pattern. If it does, then we can represent it using a load + possibly a; // BSWAP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:22,Performance,load,load,22,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:163,Performance,load,load,163,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:187,Performance,load,load,187,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:233,Performance,load,load,233,// Make sure that the load from the lowest index produces offset 0 in the; // final value.; //; // This ensures that we won't combine something like this:; //; // load x[i] -> byte 2; // load x[i+1] -> byte 0 ---> wide_load x[i]; // load x[i+2] -> byte 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:37,Performance,load,load,37,// We wil reuse the pointer from the load which ends up at byte offset 0. It; // may not use index 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,Load,Load,3,// Load must be allowed and fast on the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:9,Modifiability,Extend,Extending,9,"// TODO: Extending a vector may be expensive, don't do this until heuristics; // are better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,Modifiability,extend,extend,44,"// Try to match a phi, whose only use is an extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:40,Modifiability,extend,extend,40,"// If the target is likely to fold this extend away, don't propagate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:34,Modifiability,extend,extends,34,// We don't want to propagate the extends unless there's a good chance that; // they'll be optimized in some way.; // Collect the unique incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:91,Performance,optimiz,optimized,91,// We don't want to propagate the extends unless there's a good chance that; // they'll be optimized in some way.; // Collect the unique incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:73,Modifiability,extend,extends,73,"// Don't try to propagate if there are too many places to create new; // extends, chances are it'll increase code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Modifiability,extend,extend,12,// Build an extend after each src inst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,Modifiability,extend,extended,29,// Create a new phi with the extended inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:164,Availability,mask,masked,164,"// This combine tries to find build_vector's which have every source element; // extracted using G_EXTRACT_VECTOR_ELT. This can happen when transforms like; // the masked load scalarization is run late in the pipeline. There's already; // a combine for a similar pattern starting from the extract, but that; // doesn't attempt to do it if there are multiple uses of the build_vector,; // which in this case is true. Starting the combine from the build_vector; // feels more natural than trying to find sibling nodes of extracts.; // E.g.; // %vec(<4 x s32>) = G_BUILD_VECTOR %s1(s32), %s2, %s3, %s4; // %ext1 = G_EXTRACT_VECTOR_ELT %vec, 0; // %ext2 = G_EXTRACT_VECTOR_ELT %vec, 1; // %ext3 = G_EXTRACT_VECTOR_ELT %vec, 2; // %ext4 = G_EXTRACT_VECTOR_ELT %vec, 3; // ==>; // replace ext{1,2,3,4} with %s{1,2,3,4}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:209,Deployability,pipeline,pipeline,209,"// This combine tries to find build_vector's which have every source element; // extracted using G_EXTRACT_VECTOR_ELT. This can happen when transforms like; // the masked load scalarization is run late in the pipeline. There's already; // a combine for a similar pattern starting from the extract, but that; // doesn't attempt to do it if there are multiple uses of the build_vector,; // which in this case is true. Starting the combine from the build_vector; // feels more natural than trying to find sibling nodes of extracts.; // E.g.; // %vec(<4 x s32>) = G_BUILD_VECTOR %s1(s32), %s2, %s3, %s4; // %ext1 = G_EXTRACT_VECTOR_ELT %vec, 0; // %ext2 = G_EXTRACT_VECTOR_ELT %vec, 1; // %ext3 = G_EXTRACT_VECTOR_ELT %vec, 2; // %ext4 = G_EXTRACT_VECTOR_ELT %vec, 3; // ==>; // replace ext{1,2,3,4} with %s{1,2,3,4}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:171,Performance,load,load,171,"// This combine tries to find build_vector's which have every source element; // extracted using G_EXTRACT_VECTOR_ELT. This can happen when transforms like; // the masked load scalarization is run late in the pipeline. There's already; // a combine for a similar pattern starting from the extract, but that; // doesn't attempt to do it if there are multiple uses of the build_vector,; // which in this case is true. Starting the combine from the build_vector; // feels more natural than trying to find sibling nodes of extracts.; // E.g.; // %vec(<4 x s32>) = G_BUILD_VECTOR %s1(s32), %s2, %s3, %s4; // %ext1 = G_EXTRACT_VECTOR_ELT %vec, 0; // %ext2 = G_EXTRACT_VECTOR_ELT %vec, 1; // %ext3 = G_EXTRACT_VECTOR_ELT %vec, 2; // %ext4 = G_EXTRACT_VECTOR_ELT %vec, 3; // ==>; // replace ext{1,2,3,4} with %s{1,2,3,4}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Usability,simpl,simplify,26,// Ignore vector types to simplify matching the two constants.; // TODO: do this for vectors and scalars via a demanded bits analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,Availability,mask,mask,36,"/// Form a G_UBFX from ""(a srl b) & mask"", where b and mask are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:55,Availability,mask,mask,55,"/// Form a G_UBFX from ""(a srl b) & mask"", where b and mask are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,Availability,mask,mask,7,// The mask is a mask of the low bits iff imm & (imm+1) == 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:17,Availability,mask,mask,17,// The mask is a mask of the low bits iff imm & (imm+1) == 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,Availability,mask,mask,29,"// If the shift subsumes the mask, emit the 0 directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:63,Availability,mask,mask,63,"// Check that ubfx can do the extraction, with no holes in the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Availability,redundant,redundant,93,"// This combine may end up running before ptrtoint/inttoptr combines; // manage to eliminate redundant conversions, so try to look through them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,Safety,redund,redundant,93,"// This combine may end up running before ptrtoint/inttoptr combines; // manage to eliminate redundant conversions, so try to look through them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:181,Performance,load,load,181,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:116,Testability,test,test,116,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:54,Modifiability,extend,extend,54,// set VReg will cause type mismatch if it comes from extend/trunc,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:47,Availability,mask,mask,47,"// Look for a binop feeding into an AND with a mask:; //; // %add = G_ADD %lhs, %rhs; // %and = G_AND %add, 000...11111111; //; // Check if it's possible to perform the binop at a narrower width and zext; // back to the original width like so:; //; // %narrow_lhs = G_TRUNC %lhs; // %narrow_rhs = G_TRUNC %rhs; // %narrow_add = G_ADD %narrow_lhs, %narrow_rhs; // %new_add = G_ZEXT %narrow_add; // %and = G_AND %new_add, 000...11111111; //; // This can allow later combines to eliminate the G_AND if it turns out; // that the mask is irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:525,Availability,mask,mask,525,"// Look for a binop feeding into an AND with a mask:; //; // %add = G_ADD %lhs, %rhs; // %and = G_AND %add, 000...11111111; //; // Check if it's possible to perform the binop at a narrower width and zext; // back to the original width like so:; //; // %narrow_lhs = G_TRUNC %lhs; // %narrow_rhs = G_TRUNC %rhs; // %narrow_add = G_ADD %narrow_lhs, %narrow_rhs; // %new_add = G_ZEXT %narrow_add; // %and = G_AND %new_add, 000...11111111; //; // This can allow later combines to eliminate the G_AND if it turns out; // that the mask is irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:157,Performance,perform,perform,157,"// Look for a binop feeding into an AND with a mask:; //; // %add = G_ADD %lhs, %rhs; // %and = G_AND %add, 000...11111111; //; // Check if it's possible to perform the binop at a narrower width and zext; // back to the original width like so:; //; // %narrow_lhs = G_TRUNC %lhs; // %narrow_rhs = G_TRUNC %rhs; // %narrow_add = G_ADD %narrow_lhs, %narrow_rhs; // %new_add = G_ZEXT %narrow_add; // %and = G_AND %new_add, 000...11111111; //; // This can allow later combines to eliminate the G_AND if it turns out; // that the mask is irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:80,Availability,mask,masking,80,"// Check if the LHS feeding the AND is impacted by the high bits that we're; // masking out.; //; // e.g. for 64-bit x, y:; //; // add_64(x, y) & 65535 == zext(add_16(trunc(x), trunc(y))) & 65535",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:12,Availability,mask,mask,12,// Find the mask on the RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,Usability,simpl,simpler,48,// If the sdiv has an 'exact' flag we can use a simpler lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:94,Modifiability,extend,extend,94,"// Calculate the multiplicative inverse modulo BW.; // 2^W requires W + 1 bits, so we have to extend and then truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,Integrability,contract,contractable,48,/// Checks if \p MI is TargetOpcode::G_FMUL and contractable either; /// due to global flags or MachineInstr flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,Integrability,contract,contractable,26,"// If the addition is not contractable, do not combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:14,Safety,unsafe,unsafe,14,// Completely unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,scalab,scalable,3,// scalable vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Performance,scalab,scalable,3,// scalable vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:54,Performance,scalab,scalable,54,// Ignores COPYs during conformance checks.; // FIXME scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:43,Performance,scalab,scalable,43,// Ignores COPYs during lookups.; // FIXME scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:28,Testability,assert,assert,28,// Should we check here and assert that the instruction has been fully; // constructed?; // FIXME: Any other checks required to be done here? Remove this method if; // none.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:47,Safety,avoid,avoid,47,/// We'll reuse the same UniqueMachineInstr to avoid the new; /// allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:31,Energy Efficiency,Allocate,Allocate,31,/// This is a new instruction. Allocate a new UniqueMachineInstr and; /// Insert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:12,Performance,perform,perform,12,"// For now, perform erase, followed by insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:33,Performance,cache,cache,33,"// For now, we only maintain the cache during one request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:3,Testability,Test,Test,3,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:42,Usability,simpl,simpler,42,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:53,Availability,Mask,Mask,53,"// Bitfield extract is computed as (Src >> Offset) & Mask, where Mask is; // created using Width. Use this function when the inputs are KnownBits; // objects. TODO: Move this KnownBits.h if this is usable in more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:65,Availability,Mask,Mask,65,"// Bitfield extract is computed as (Src >> Offset) & Mask, where Mask is; // created using Width. Use this function when the inputs are KnownBits; // objects. TODO: Move this KnownBits.h if this is usable in more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:198,Usability,usab,usable,198,"// Bitfield extract is computed as (Src >> Offset) & Mask, where Mask is; // created using Width. Use this function when the inputs are KnownBits; // objects. TODO: Move this KnownBits.h if this is usable in more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:440,Availability,down,down,440,"// Don't know anything; // Depth may get bigger than max depth if it gets passed to a different; // GISelKnownBits object.; // This may happen when say a generic part uses a GISelKnownBits object; // with some max depth, but then we hit TL.computeKnownBitsForTargetInstr; // which creates a new GISelKnownBits object with a different and smaller; // depth. If we just check for equality, we would never exit if the depth; // that is passed down to the target specific GISelKnownBits object is; // already bigger than its max depth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:79,Deployability,pipeline,pipeline,79,"// Destination registers should not have subregisters at this; // point of the pipeline, otherwise the main live-range will be; // defined more than once, which is against SSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:70,Deployability,update,updated,70,"// Record in the cache that we know nothing for MI.; // This will get updated later and in the meantime, if we reach that; // phi again, because of a loop, we will cut the search thanks to this; // cache entry.; // We could actually build up more information on the phi by not cutting; // the search, but that additional information is more a side effect; // than an intended choice.; // Therefore, for now, save on compile time until we derive a proper way; // to derive known bits for PHIs within loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:17,Performance,cache,cache,17,"// Record in the cache that we know nothing for MI.; // This will get updated later and in the meantime, if we reach that; // phi again, because of a loop, we will cut the search thanks to this; // cache entry.; // We could actually build up more information on the phi by not cutting; // the search, but that additional information is more a side effect; // than an intended choice.; // Therefore, for now, save on compile time until we derive a proper way; // to derive known bits for PHIs within loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:198,Performance,cache,cache,198,"// Record in the cache that we know nothing for MI.; // This will get updated later and in the meantime, if we reach that; // phi again, because of a loop, we will cut the search thanks to this; // cache entry.; // We could actually build up more information on the phi by not cutting; // the search, but that additional information is more a side effect; // than an intended choice.; // Therefore, for now, save on compile time until we derive a proper way; // to derive known bits for PHIs within loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:62,Modifiability,extend,extend,62,"// If the sign bit is known to be zero or one, then sext will extend; // it to the top bits, else it will just zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:128,Usability,clear,clearing,128,"// TODO: Should use maximum with source; // If a node is guaranteed to be aligned, set low zero bits accordingly as; // well as clearing one bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:8,Modifiability,extend,extend,8,// Sign extend the extracted value using shift left and arithmetic shift; // right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:3,Deployability,Update,Update,3,// Update the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:14,Performance,cache,cache,14,// Update the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:3,Testability,Test,Test,3,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:42,Usability,simpl,simpler,42,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:34,Modifiability,extend,extends,34,// Max of the input and what this extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:39,Availability,down,down,39,// Check if the sign bits of source go down as far as the truncated value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:139,Availability,avail,available,139,"// If compares returns 0/-1, all bits are sign bits.; // We know that we have an integer-based boolean since these operations; // are only available for integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:38,Availability,Mask,Mask,38,"// Okay, we know that the sign bit in Mask is set. Use CLO to determine; // the number of identical bits in the top of the input value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GlobalISel.cpp:437,Integrability,rout,routines,437,"//===-- llvm/CodeGen/GlobalISel/GlobalIsel.cpp --- GlobalISel ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; // This file implements the common initialization routines for the; // GlobalISel library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GlobalISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GlobalISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:23,Availability,failure,failure,23,// RC is unset only on failure. Return immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate a matching input constraint since the constraint it's; // matching to has already been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:110,Energy Efficiency,allocate,allocated,110,// No need to allocate a matching input constraint since the constraint it's; // matching to has already been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:142,Energy Efficiency,allocate,allocate,142,"// If this is a constraint for a specific physical register, but the type of; // the operand requires more than one register to be passed, we allocate the; // required amount of physical registers, starting from the selected physical; // register.; // For this, first retrieve a register iterator for the given register class",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:71,Security,access,accessed,71,"// If this is an indirect operand, the operand is a pointer to the; // accessed type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:38,Security,expose,expose,38,// The selected constraint type might expose new sideeffects,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:3,Usability,Simpl,Simple,3,// Simple Integer or Relocatable Constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:36,Modifiability,extend,extended,36,"// Boolean constants should be zero-extended, others are sign-extended",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:62,Modifiability,extend,extended,62,"// Boolean constants should be zero-extended, others are sign-extended",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:57,Testability,test,testing,57,"// In order not to crash when calling getAnalysis during testing with -run-pass; // we use the default opt level here instead of None, so that the addRequired(); // calls are made in getAnalysisUsage().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:50,Availability,failure,failures,50,// An optimization remark emitter. Used to report failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:6,Performance,optimiz,optimization,6,// An optimization remark emitter. Used to report failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:131,Testability,assert,assert,131,"// FIXME: We could introduce new blocks and will need to fix the outer loop.; // Until then, keep track of the number of blocks to assert that we don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:15,Availability,redundant,redundant,15,// Try to find redundant copies b/w vregs of the same register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:15,Safety,redund,redundant,15,// Try to find redundant copies b/w vregs of the same register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:149,Availability,error,error,149,// Print the function name explicitly if we don't have a debug location (which; // makes the diagnostic less useful) or if we're going to emit a raw error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:24,Integrability,message,message,24,// Only print the check message if we're actually checking it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:10,Energy Efficiency,allocate,allocate,10,// Always allocate at least one byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:90,Performance,load,loadimm,90,// Get or create a virtual register for each value.; // Unless the value is a Constant => loadimm cst?; // or inline constant each time?; // Creation of a virtual register needs to have a size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:359,Performance,perform,performance,359,"// If this is a series of conditions that are or'd or and'd together, emit; // this as a sequence of branches instead of setcc's with and/or operations.; // As long as jumps are not expensive (exceptions for multi-use logic ops,; // unpredictable branches, and vector extracts because those jumps are likely; // expensive for any target), this should improve performance.; // For example, instead of something like:; // cmp A, B; // C = seteq; // cmp D, E; // F = setle; // or C, F; // jnz foo; // Emit:; // cmp A, B; // je foo; // cmp D, E; // jle foo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:218,Testability,log,logic,218,"// If this is a series of conditions that are or'd or and'd together, emit; // this as a sequence of branches instead of setcc's with and/or operations.; // As long as jumps are not expensive (exceptions for multi-use logic ops,; // unpredictable branches, and vector extracts because those jumps are likely; // expensive for any target), this should improve performance.; // For example, instead of something like:; // cmp A, B; // C = seteq; // cmp D, E; // F = setle; // or C, F; // jnz foo; // Emit:; // cmp A, B; // je foo; // cmp D, E; // jle foo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:66,Usability,clear,clear,66,"// Okay, we decided not to do this, remove any inserted MBB's and clear; // SwitchCases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:17,Availability,avail,available,17,"// If BPI is not available, set the default probability as 1 / N, where N is; // the number of successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:75,Performance,optimiz,optimization,75,// Cluster adjacent cases with the same destination. We do this at all; // optimization levels because it's cheap to do and will make codegen faster; // if there are many clusters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:7,Performance,optimiz,optimized,7,"// For optimized builds, lower large range as a balanced binary tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting unnecessary branches to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Update,Update,3,// Update successor info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:10,Performance,Optimiz,Optimize,10,// FIXME: Optimize away range check based on pivot comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:142,Deployability,update,update,142,"// If the default statement is a target of the jump table, we evenly; // distribute the default probability to successors of CurMBB. Also; // update the probability on the edge from JumpMBB to Fallthrough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:37,Availability,mask,mask,37,// Ensure that the type will fit the mask value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:54,Availability,mask,masks,54,"// Switch table case range are encoded into series of masks.; // Just use pointer type, it's guaranteed to fit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting unnecessary branches to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Testability,Test,Testing,3,// Testing for a single bit; just compare the shift count with what it; // would need to be to shift a 1 bit in that position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:44,Testability,test,test,44,"// There is only one zero bit in the range, test for it directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:12,Testability,test,tests,12,// Emit bit tests and jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:63,Testability,test,test,63,// Record the fact that the IR edge from the header to the bit test target; // will go through our new block. Neeeded for PHIs to have nodes added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting unnecessary branches to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:10,Performance,Optimiz,Optimize,10,// FIXME: Optimize away range check based on pivot comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:11,Testability,test,test,11,// The bit test blocks haven't been inserted yet; insert them here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:23,Testability,test,test,23,"// If the cases in bit test don't form a contiguous range, we evenly; // distribute the probability on the edge to Fallthrough to two; // successors of CurMBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:45,Testability,test,test,45,"// If we're in the right place, emit the bit test header right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:34,Safety,Avoid,Avoid,34,// N = N + Idx * ElementSize;; // Avoid doing it for ElementSize of 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:13,Usability,simpl,simple,13,// Is this a simple intrinsic?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:16,Usability,simpl,simple,16,"// If this is a simple intrinsic (that is, we just need to add a def of; // a vreg, and uses for each arg operand, then translate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:81,Usability,Simpl,Simplest,81,// No target I know of cares about va_end. Certainly no in-tree target; // does. Simplest intrinsic ever!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:62,Energy Efficiency,reduce,reduce,62,"// We split the operation into a separate G_FADD/G_FMUL + the reduce,; // since the associativity doesn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:81,Performance,optimiz,optimize,81,"// We don't set HasCalls on MFI here yet because call lowering may decide to; // optimize into tail calls. Instead, we defer that to selection where a final; // scan is done to check if any instructions are calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:27,Deployability,patch,patchpoint,27,// FIXME: support invoking patchpoint and statepoint intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Update,Update,3,// Update successor info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:101,Safety,detect,detected,101,// Add a label to mark the beginning of the landing pad. Deletion of the; // landing pad can thus be detected via the MachineModuleInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:51,Modifiability,variab,variable,51,"// A dbg.declare describes the address of a source variable, so lower it; // into an indirect DBG_VALUE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:302,Performance,perform,perform,302,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:114,Testability,test,test,114,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:173,Testability,test,test,173,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:323,Testability,test,test,323,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:397,Testability,test,test,397,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:449,Testability,test,test,449,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:479,Testability,test,test,479,"// If all cases cover a contiguous range, it is not necessary to jump to; // the default block after the last bit test fails. This is because the; // range check during bit test header creation has guaranteed that every; // case here doesn't go outside the range. In this case, there is no need; // to perform the last bit test, as it will always be true. Instead, make; // the second-to-last bit-test fall through to the target of the last bit; // test, and delete the last bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:22,Testability,test,test,22,// Second-to-last bit-test with contiguous range: fall through to the; // target of the final bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:98,Testability,test,test,98,// Second-to-last bit-test with contiguous range: fall through to the; // target of the final bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:20,Testability,test,test,20,"// For the last bit test, fall through to Default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:43,Testability,test,test,43,"// Otherwise, fall through to the next bit test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:46,Testability,test,test,46,"// Since we're not going to use the final bit test, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:11,Availability,Failure,Failure,11,// CodeGen Failure MBB if we have not codegened it yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Usability,Clear,Clear,3,// Clear the Per-BB State.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:20,Performance,load,loads,20,// First create the loads to the guard/stack slot for the comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:20,Performance,load,load,20,// Generate code to load the content of the guard slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:238,Modifiability,variab,variable,238,"// This path is currently untestable on GlobalISel, since the only platform; // that needs this seems to be Windows, and we fall back on that currently.; // The code still lives here in case that changes.; // Silence warning about unused variable until the code below that uses; // 'GuardCheckFn' is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:49,Security,validat,validate,49,// The target provides a guard check function to validate the guard value.; // Generate a call to that function with the content of the guard slot as; // argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:100,Performance,load,load,100,"// If useLoadStackGuardNode returns true, generate LOAD_STACK_GUARD.; // Otherwise, emit a volatile load to retrieve the stack guard value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:9,Testability,test,test,9,// TODO: test using android subtarget when we support @llvm.thread.pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Performance,Perform,Perform,3,// Perform the comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:50,Availability,failure,failure,50,"// If the guard/stackslot do not equal, branch to failure MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Release,Release,3,// Release the memory used by the different maps we; // needed during the translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:83,Safety,avoid,avoid,83,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing free’d memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:146,Safety,avoid,avoid,146,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing free’d memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:89,Security,access,accessing,89,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing free’d memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:67,Usability,Clear,Clear,67,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing free’d memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Release,Release,3,"// Release the per-function state when we return, whether we succeeded or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Deployability,Update,Update,3,// Update the live-in information for the new entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:396,Integrability,interface,interface,396,"//===- lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp - Legalizer ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implement an interface to specify and query how an illegal operation on a; // given type should be expanded.; //; // Issues to be resolved:; // + Make it fast.; // + Support weird types like i3, <7 x i3>, ...; // + Operations with more than one type (ICMP, CMPXCHG, intrinsics, ...); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:102,Performance,load,load,102,// Set defaults.; // FIXME: these two (G_ANYEXT and G_TRUNC?) can be legalized to the; // fundamental load/store Jakob proposed. Once loads & stores are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:134,Performance,load,loads,134,// Set defaults.; // FIXME: these two (G_ANYEXT and G_TRUNC?) can be legalized to the; // fundamental load/store Jakob proposed. Once loads & stores are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:52,Energy Efficiency,adapt,adapt,52,"// For vector types, we assume that the best way to adapt the number; // of elements is to the next larger number of elements type for which; // the vector type is legal, unless there is no such type. In that case,; // legalize towards a vector type with a smaller number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:52,Modifiability,adapt,adapt,52,"// For vector types, we assume that the best way to adapt the number; // of elements is to the next larger number of elements type for which; // the vector type is legal, unless there is no such type. In that case,; // legalize towards a vector type with a smaller number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:361,Testability,assert,asserts,361,"// The following needs to be a loop, as for now, we do allow needing to; // go over ""Unsupported"" bit sizes before finding a legalizable bit size.; // e.g. (s8, WidenScalar), (s9, Unsupported), (s32, Legal). if Size==8,; // we need to iterate over s9, and then to s32 to return (s32, Legal).; // If we want to get rid of the below loop, we should have stronger asserts; // when building the SizeAndActionsVecs, probably not allowing; // ""Unsupported"" unless at the ends of the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:56,Performance,cache,cache,56,"// FIXME: speed up this search, e.g. by using a results cache for repeated; // queries?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp:543,Performance,optimiz,optimizations,543,"//===- lib/CodeGen/GlobalISel/LegalizerPredicates.cpp - Predicates --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A library of predicate factories to use for LegalityPredicate.; //; //===----------------------------------------------------------------------===//; // Enable optimizations to work around MSVC debug mode bug in 32-bit:; // https://developercommunity.visualstudio.com/content/problem/1179643/msvc-copies-overaligned-non-trivially-copyable-par.html; // FIXME: Remove this when the issue is closed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp:56,Performance,optimiz,optimizations,56,// We have to disable runtime checks in order to enable optimizations. This is; // done for the entire file because the problem is actually observed in STL; // template functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:499,Integrability,wrap,wrapper,499,"//===-- llvm/CodeGen/GlobalISel/Legalizer.cpp -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the LegalizerHelper class to legalize individual; /// instructions and the LegalizePass wrapper pass for the primary; /// legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:25,Deployability,release,release,25,// Always disable it for release builds by preventing the observer from being; // installed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:82,Deployability,install,installed,82,// Always disable it for release builds by preventing the observer from being; // installed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:131,Availability,down,down,131,"// Perform legalization bottom up so we can DCE as we legalize.; // Traverse BB in RPOT and within each basic block, add insts top down,; // so when we pop_back_val in the legalization process, we traverse bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:3,Performance,Perform,Perform,3,"// Perform legalization bottom up so we can DCE as we legalize.; // Traverse BB in RPOT and within each basic block, add insts top down,; // so when we pop_back_val in the legalization process, we traverse bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:37,Deployability,update,updated,37,// This observer keeps the worklists updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:123,Integrability,wrap,wrapper,123,// We want both WorkListObserver as well as all the auxiliary observers (e.g.; // CSEInfo) to observe all changes. Use the wrapper observer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:7,Deployability,install,install,7,// Now install the observer as the delegate to MF.; // This will keep all the observers notified about new insertions/deletions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:3,Availability,Error,Error,3,// Error out if we couldn't legalize this instruction. We may want to; // fall back to DAG ISel instead in the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:50,Safety,abort,aborting,50,// Move illegal artifacts to RetryList instead of aborting because; // legalizing InstList may generate artifacts that allow; // ArtifactCombiner to combine away them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:182,Integrability,wrap,wrapper,182,"// If for some reason CSE was not enabled, make sure that we invalidate the; // CSEInfo object (as we currently declare that the analysis is preserved).; // The next time get on the wrapper is called, it will force it to recompute; // the analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:504,Integrability,wrap,wrapper,504,"//===-- llvm/CodeGen/GlobalISel/LegalizerHelper.cpp -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the LegalizerHelper class to legalize; /// individual instructions and the LegalizeMachineIR wrapper pass for the; /// primary legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:17,Availability,down,down,17,"/// Try to break down \p OrigTy into \p NarrowTy sized pieces.; ///; /// Returns the number of \p NarrowTy elements needed to reconstruct \p OrigTy,; /// with any leftover piece as type \p LeftoverTy; ///; /// Returns -1 in the first element of the pair if the breakdown is not; /// satisfiable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating additional instructions if we're just adding additional; // copies of padding bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:15,Modifiability,extend,extend,15,"// In the sign extend padding case, re-use the first all-signbit merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Safety,safe,safe,12,// It's not safe to eliminate the sign / zero extension of the return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:89,Integrability,rout,routines,89,"// For MEMCPY/MOMMOVE/MEMSET these will be the first use (the dst), as the; // mempy/etc routines return the same parameter. For other it will be the; // returned value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:35,Security,validat,validated,35,// Skip over the COPY that we just validated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:303,Modifiability,variab,variable,303,"// Some library functions that read FP state (fegetmode, fegetenv) write the; // state into a region in memory. IR intrinsics that do the same operations; // (get_fpmode, get_fpenv) return the state as integer value. To implement these; // intrinsics via the library functions, we need to use temporary variable,; // for example:; //; // %0:_(s32) = G_GET_FPMODE; //; // is transformed to:; //; // %1:_(p0) = G_FRAME_INDEX %stack.0; // BL &fegetmode; // %0:_(s32) = G_LOAD % 1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Performance,load,load,12,// Create a load from the temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:28,Performance,load,load,28,// FIXME: Need to split the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:20,Energy Efficiency,power,power-of-two,20,// TODO: Handle non-power-of-two types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:61,Modifiability,extend,extending,61,// So long as the new type has more bits than the bits we're extending we; // don't need to break it apart.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:75,Modifiability,extend,extending,75,// We don't lose any non-extension bits by truncating the src and; // sign-extending the dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:159,Energy Efficiency,reduce,reduce,159,"// Widen SrcTy to WideTy. This does not affect the result, but since the; // user requested this size, it is probably better handled than SrcTy and; // should reduce the total number of legalization artifacts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,// Extend the source to a wider type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:74,Usability,simpl,simple,74,// Extracts from pointers can be handled only if they are really just; // simple integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid a shift in the degenerate case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:144,Energy Efficiency,efficient,efficient,144,"// We can convert this to:; // 1. Any extend iN to iM; // 2. SHL by M-N; // 3. [US][ADD|SUB|SHL]SAT; // 4. L/ASHR by M-N; //; // It may be more efficient to lower this to a min and a max operation in; // the higher precision arithmetic if the promoted operation isn't legal,; // but this decision is up to the target's lowering request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Modifiability,extend,extend,38,"// We can convert this to:; // 1. Any extend iN to iM; // 2. SHL by M-N; // 3. [US][ADD|SUB|SHL]SAT; // 4. L/ASHR by M-N; //; // It may be more efficient to lower this to a min and a max operation in; // the higher precision arithmetic if the promoted operation isn't legal,; // but this decision is up to the target's lowering request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:20,Modifiability,extend,extend,20,"// Shifts must zero-extend the RHS to preserve the unsigned quantity, and; // must not left shift the RHS to preserve the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:64,Modifiability,extend,extend,64,"// To determine if the result overflowed in the larger type, we extend the; // input to the larger type, do the multiply (checking if it overflows),; // then also check the high bits of the result to see if overflow happened; // there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:113,Modifiability,extend,extend,113,"// Overflow occurred if it occurred in the larger type, or if the high part; // of the result does not zero/sign-extend the low part. Check this second; // possibility first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:66,Modifiability,extend,extend,66,"// For signed, overflow occurred when the high part does not sign-extend; // the low part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:63,Modifiability,extend,extend,63,// Unsigned overflow occurred when the high part does not zero-extend the; // low part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:9,Modifiability,extend,extend,9,// First extend the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Perform,Perform,3,// Perform the operation at the larger size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Perform,Perform,3,"// Perform operation at larger width (any extension is fines here, high bits; // don't affect the result) and then truncate the result back to the; // original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Perform,Perform,3,"// Perform operation at larger width (any extension is fine here, high; // bits don't affect the result) and then truncate the result back to the; // original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:6,Safety,avoid,avoid,6,"// To avoid changing the bits of the constant due to extension to a larger; // type and then using G_FPTRUNC, we simply convert to a G_CONSTANT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:113,Usability,simpl,simply,113,"// To avoid changing the bits of the constant due to extension to a larger; // type and then using G_FPTRUNC, we simply convert to a G_CONSTANT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid changing the result vector type if the source element type was; // requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:4,Performance,Perform,Perform,4,"/// Perform a G_EXTRACT_VECTOR_ELT in a different sized vector element. If this; /// is casting to a vector with a smaller element size, perform multiple element; /// extracts and merge the results. If this is coercing to a vector with larger; /// elements, index the bitcasted vector and extract the target element with bit; /// operations. This is intended to force the indexing in the native register; /// size for architectures that can dynamically index the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:137,Performance,perform,perform,137,"/// Perform a G_EXTRACT_VECTOR_ELT in a different sized vector element. If this; /// is casting to a vector with a smaller element size, perform multiple element; /// extracts and merge the results. If this is coercing to a vector with larger; /// elements, index the bitcasted vector and extract the target element with bit; /// operations. This is intended to force the indexing in the native register; /// size for architectures that can dynamically index the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Energy Efficiency,power,powers,24,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:13,Integrability,depend,depends,13,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Usability,Clear,Clear,3,// Clear out the bits in the wide element,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:67,Availability,mask,masked,67,"// The value to insert has all zeros already, so stick it into the masked; // wide element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:4,Performance,Perform,Perform,4,"/// Perform a G_INSERT_VECTOR_ELT in a different sized vector element. If this; /// is increasing the element size, perform the indexing in the target element; /// type, and use bit operations to insert at the element position. This is; /// intended for architectures that can dynamically index the register file and; /// want to force indexing in the native register size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:116,Performance,perform,perform,116,"/// Perform a G_INSERT_VECTOR_ELT in a different sized vector element. If this; /// is increasing the element size, perform the indexing in the target element; /// type, and use bit operations to insert at the element position. This is; /// intended for architectures that can dynamically index the register file and; /// want to force indexing in the native register size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Energy Efficiency,power,powers,24,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:13,Integrability,depend,depends,13,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Performance,load,load,27,"// Promote to a byte-sized load if not loading an integral number of; // bytes. For example, promote EXTLOAD:i20 -> EXTLOAD:i24.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:39,Performance,load,loading,39,"// Promote to a byte-sized load if not loading an integral number of; // bytes. For example, promote EXTLOAD:i20 -> EXTLOAD:i24.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:29,Modifiability,extend,extending,29,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:39,Performance,load,load,39,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:106,Performance,load,load,106,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:89,Safety,avoid,avoid,89,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:87,Performance,load,load,87,"// The extra bits are guaranteed to be zero, since we stored them that; // way. A zext load from Wide thus automatically gives zext from MemVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:259,Availability,down,down,259,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:34,Energy Efficiency,power,power,34,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:155,Energy Efficiency,power,power-,155,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:561,Modifiability,extend,extend,561,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:8,Performance,load,load,8,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:51,Performance,load,loads,51,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:112,Performance,load,loads,112,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:309,Performance,load,load,309,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:361,Performance,load,load,361,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:34,Energy Efficiency,power,power,34,// This load needs splitting into power of 2 sized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:8,Performance,load,load,8,// This load needs splitting into power of 2 sized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:51,Performance,load,loads,51,// This load needs splitting into power of 2 sized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,Energy Efficiency,power,power,21,"// This is already a power of 2, but we still need to split this in half.; //; // Assume we're being asked to decompose an unaligned load.; // TODO: If this requires multiple splits, handle them all at once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:133,Performance,load,load,133,"// This is already a power of 2, but we still need to split this in half.; //; // Assume we're being asked to decompose an unaligned load.; // TODO: If this requires multiple splits, handle them all at once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:15,Energy Efficiency,power,power,15,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:189,Energy Efficiency,power,power,189,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:142,Modifiability,extend,extending,142,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:321,Modifiability,extend,extend,321,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating a store with a narrower source than result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,"// Extend to the next pow-2. If this store was itself the result of lowering,; // e.g. an s56 store being broken into s32 + s24, we might have a stored type; // that's wider than the stored size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:45,Modifiability,extend,extending,45,// Not sure how to interpret a bitcast of an extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:55,Performance,load,load,55,// Not sure how to interpret a bitcast of an extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Safety,detect,detected,38,"// For *signed* multiply, overflow is detected by checking:; // (hi != (lo >> bitwidth-1))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:189,Energy Efficiency,reduce,reduce,189,"// FIXME: We're missing a way to go back from LLT to llvm::Type to query the; // datalayout for the preferred alignment. Also there should be a target hook; // for this to allow targets to reduce the alignment and ignore the; // datalayout. e.g. AMDGPU should always use a 4-byte alignment, regardless of; // the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:102,Integrability,depend,depending,102,/// Operand \p Op is used on \p N sub-instructions. Fill \p Ops with \p N SrcOps; /// made from \p Op depending on operand type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,Performance,perform,perform,21,// Instructions that perform register split will be inserted in basic block; // where register is defined (basic block is in the next operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:191,Performance,perform,perform,191,// Requires compatible types. Otherwise SrcReg should have been defined by; // merge-like instruction that would get artifact combined. Most likely; // instruction that defines SrcReg has to perform more/fewer elements; // legalization compatible with NarrowTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:63,Performance,perform,perform,63,// Requires compatible types. Otherwise user of DstReg did not perform unmerge; // that should have been artifact combined. Most likely instruction that uses; // DstReg has to do more/fewer elements legalization compatible with NarrowTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:96,Testability,test,tests,96,// This attempts to lower part of LCMTy merge/unmerge sequence. Intended use; // is for old mir tests. Since the changes to more/fewer elements it should no; // longer be possible to generate MIR like this when starting from llvm-ir; // because LCMTy approach was replaced with merge/unmerge to vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:56,Availability,down,down,56,"// If the index is a constant, we can really break this down as you would; // expect, and index into the target size pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Safety,Avoid,Avoid,3,// Avoid out of bounds indexing the pieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:10,Modifiability,variab,variable,10,"// With a variable index, we can't perform the operation in a smaller type, so; // we're forced to expand this.; //; // TODO: We could emit a chain of compare/select to figure out which piece to; // index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:35,Performance,perform,perform,35,"// With a variable index, we can't perform the operation in a smaller type, so; // we're forced to expand this.; //; // TODO: We could emit a chain of compare/select to figure out which piece to; // index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:13,Performance,load,load,13,"// Split the load/store into PartTy sized pieces starting at Offset. If this; // is a load, return the new registers in ValRegs. For a store, each elements; // of ValRegs should be PartTy. Returns the next offset that needs to be; // handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:86,Performance,load,load,86,"// Split the load/store into PartTy sized pieces starting at Offset. If this; // is a load, return the new registers in ValRegs. For a store, each elements; // of ValRegs should be PartTy. Returns the next offset that needs to be; // handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:2,Availability,mask,mask,2,"/*mask,fpsem*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:19,Availability,mask,mask,19,"// Build a shuffle mask for the output, discovering on the fly which; // input vectors to use as shuffle operands (recorded in InputUsed).; // If building a suitable shuffle vector proves too hard, then bail; // out with useBuildVector set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,// The mask element. This indexes into the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:25,Availability,mask,mask,25,// The input vector this mask element indexes into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,// The mask element does not index into any input vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:11,Availability,mask,mask,11,// Add the mask index for the new shuffle vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,// The mask element. This indexes into the input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:25,Availability,mask,mask,25,// The input vector this mask element indexes into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,Availability,mask,mask,7,"// The mask element is ""undef"" or indexes off the end of the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:43,Energy Efficiency,reduce,reduce,43,// Generate a tree of scalar operations to reduce the critical path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:29,Energy Efficiency,power,powers,29,"// If the types involved are powers of 2, we can generate intermediate vector; // ops, before generating a final reduction operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:9,Performance,Optimiz,Optimize,9,// TODO: Optimize if constant shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:161,Modifiability,refactor,refactoring,161,"// TODO: the symmetric MoreTy works for targets like, e.g. NEON.; // For targets, like e.g. MVE, the result is a predicated vector (i1).; // This will need some refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:10,Availability,mask,mask,10,// Extend mask to match new destination vector size with; // undef values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,// Extend mask to match new destination vector size with; // undef values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Availability,mask,mask,12,// Readjust mask for new input vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:10,Availability,mask,mask,10,// Adjust mask based on new input vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:79,Modifiability,extend,extended,79,// OpSegStart is where this destination segment would start in OpReg if it; // extended infinitely in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:60,Modifiability,extend,extend,60,"// The leftover reg is smaller than NarrowTy, so we need to extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:79,Modifiability,extend,extended,79,// OpSegStart is where this destination segment would start in OpReg if it; // extended infinitely in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:50,Availability,mask,mask,50,"// For count in blocks of 8 bits we don't have to mask high 4 bits before; // addition since count value sits in range {0,...,8} and 4 bits are enough; // to hold such binary values. After addition high 4 bits still hold count; // of set bits in high 4 bit block, set them to zero and get 8 bit result.; // B8Count = { B4Count + (B4Count >> 4) } & 0x0F0F0F0F",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:15,Performance,optimiz,optimized,15,// FIXME: Emit optimized urem by constant instead of letting it expand later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:58,Safety,avoid,avoiding,58,// These operations approximately do the following (while avoiding undefined; // shifts by BW):; // G_FSHL: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // G_FSHR: (X << (BW - (Z % BW))) | (Y >> (Z % BW)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:23,Energy Efficiency,power,powers,23,"// This only works for powers of 2, fallback to shifts if it fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:20,Modifiability,extend,extend,20,"// The step between extend is too large, split it by creating an intermediate; // extend instruction",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:82,Modifiability,extend,extend,82,"// The step between extend is too large, split it by creating an intermediate; // extend instruction",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:114,Availability,avail,available,114,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:193,Energy Efficiency,efficient,efficiently,193,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:97,Integrability,depend,depending,97,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:139,Performance,optimiz,optimization,139,"// Insert canonicalizes if it's possible we need to quiet to get correct; // sNaN behavior.; // Note this must be done here, and not as an optimization combine in the; // absence of a dedicate quiet-snan instruction as we're using an; // omni-purpose G_FCANONICALIZE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:30,Safety,safe,safe,30,"// If there are no nans, it's safe to simply replace this with the non-IEEE; // version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Usability,simpl,simply,38,"// If there are no nans, it's safe to simply replace this with the non-IEEE; // version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:30,Modifiability,variab,variable,30,// We lose information with a variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,Security,access,access,21,// Unmerge and allow access to each Src element for the artifact combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:57,Safety,detect,detect,57,"// TODO: If SADDSAT/SSUBSAT is legal, compare results to detect overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,Availability,Mask,Mask,12,// AND with Mask leaves byte i unchanged and sets remaining bytes to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:55,Availability,Mask,Mask,55,// Low byte shifted left to place of high byte: (Src & Mask) << ShiftAmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:69,Availability,Mask,Mask,69,// High byte shifted right to place of low byte: (Src >> ShiftAmt) & Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:11,Availability,Mask,Mask,11,//{ (Src & Mask) >> N } | { (Src << N) & Mask },MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:41,Availability,Mask,Mask,41,//{ (Src & Mask) >> N } | { (Src << N) & Mask },MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Testability,test,test,27,// TODO: Try inverting the test with getInvertedFPClassTest like the DAG; // version,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:11,Availability,mask,masks,11,// Various masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Testability,Test,Tests,3,// Tests that involve more than one class should be processed first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Testability,test,test,27,// fcZero | fcSubnormal => test all exponent bits are 0; // TODO: Handle sign bit specific cases; // TODO: Handle inverted case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:53,Availability,mask,mask,53,// Turn the scalar condition into a vector condition mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,Modifiability,extend,extended,38,"// The condition was potentially zero extended before, but we want a sign; // extended boolean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:78,Modifiability,extend,extended,78,"// The condition was potentially zero extended before, but we want a sign; // extended boolean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,optimiz,optimize,24,"// On Darwin, -Os means optimize for size without hurting performance, so; // only really optimize for size when -Oz (MinSize) is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:58,Performance,perform,performance,58,"// On Darwin, -Os means optimize for size without hurting performance, so; // only really optimize for size when -Oz (MinSize) is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:90,Performance,optimiz,optimize,90,"// On Darwin, -Os means optimize for size without hurting performance, so; // only really optimize for size when -Oz (MinSize) is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:50,Performance,load,load,50,// FIXME: check for the largest legal type we can load/store to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:32,Performance,load,load,32,"// For now, only use non-vector load / store's for the left-over pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,Safety,safe,safety,27,// FIXME: check for mem op safety and legality of the types. Not all of; // SDAGisms map cleanly to GISel concepts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:127,Performance,load,load,127,"// If the new LLT cannot cover all of the remaining bits, then consider; // issuing a (or a pair of) unaligned and overlapping load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Modifiability,Extend,Extend,3,"// Extend the byte value to the larger type, and then multiply by a magic; // value 0x010101... in order to replicate it across every byte.; // Unless it's zero, in which case just emit a larger G_CONSTANT 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,load,load,24,// Issuing an unaligned load / store pair that overlaps with the previous; // pair. Adjust the offset accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:328,Integrability,depend,depending,328,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:33,Performance,load,load,33,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:123,Performance,load,load,123,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:253,Performance,load,loaded,253,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:294,Performance,load,loads,294,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,load,load,24,// Issuing an unaligned load / store pair that overlaps with the previous; // pair. Adjust the offset accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:26,Security,access,accesses,26,// Construct MMOs for the accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:14,Performance,load,load,14,// Create the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:28,Performance,perform,perform,28,"// Memmove requires that we perform the loads first before issuing the stores.; // Apart from that, this loop is pretty much doing the same thing as the; // memcpy codegen function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:40,Performance,load,loads,40,"// Memmove requires that we perform the loads first before issuing the stores.; // Apart from that, this loop is pretty much doing the same thing as the; // memcpy codegen function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:25,Performance,load,load,25,// Construct MMO for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:14,Performance,load,load,14,// Create the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,Performance,load,loaded,24,// Now store the values loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:16,Performance,optimiz,optimize,16,// Don't try to optimize volatile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:396,Integrability,interface,interface,396,"//===- lib/CodeGen/GlobalISel/LegalizerInfo.cpp - Legalizer ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implement an interface to specify and query how an illegal operation on a; // given type should be expanded.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:24,Modifiability,variab,variable,24,"// G_UNMERGE_VALUES has variable number of operands, but there is only; // one source type and one destination type as all destinations must be the; // same type. So, get the last operand if TypeIdx == 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:33,Performance,cache,cache,33,// FIXME: probably we'll need to cache the results here somehow?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:113,Availability,down,down,113,// We must only record actions once for each TypeIdx; otherwise we'd; // try to legalize operands multiple times down the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:7,Performance,Load,LoadStoreOpt,7,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:51,Performance,optimiz,optimizations,51,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:416,Performance,Load,LoadStoreOpt,416,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:429,Performance,optimiz,optimization,429,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:20,Usability,simpl,simple,20,// Just recognize a simple case for now. In future we'll need to match; // indexing patterns for base + index + constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:126,Performance,load,load,126,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:137,Performance,scalab,scalable,137,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:25,Security,access,access,25,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:113,Security,access,access,113,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:149,Testability,test,tests,149,"// Try to prove that there is aliasing, or that there is no aliasing. Either; // way, we can return now. If nothing can be proved, proceed with more tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:59,Safety,hazard,hazard,59,/// Returns true if the instruction creates an unavoidable hazard that; /// forces a boundary between store merge candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:3,Performance,Perform,Perform,3,// Perform the actual merging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:226,Availability,avail,available,226,"// We know that all the stores are consecutive and there are no aliasing; // operations in the range. However, the values that are being stored may be; // generated anywhere before each store. To ensure we have the values; // available, we materialize the wide value and new store at the place of the; // final store in the merge sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:133,Performance,load,loads,133,"// Mimic the SDAG behaviour here and don't try to do anything for unknown; // values. In future, we should also support the cases of loads and; // extracted vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:164,Performance,load,load,164,"// We know that the stores in the candidate are adjacent.; // Now we need to check if any potential aliasing instructions recorded; // during the search alias with load/stores added to the candidate after.; // For example, if we have the candidate:; // C.Stores = [ST1, ST2, ST3, ST4]; // and after seeing ST2 we saw a load LD1, which did not alias with ST1 or; // ST2, then we would have recorded it into the PotentialAliases structure; // with the associated index value of ""1"". Then we see ST3 and ST4 and add; // them to the candidate group. We know that LD1 does not alias with ST1 or; // ST2, since we already did that check. However we don't yet know if it; // may alias ST3 and ST4, so we perform those checks now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:319,Performance,load,load,319,"// We know that the stores in the candidate are adjacent.; // Now we need to check if any potential aliasing instructions recorded; // during the search alias with load/stores added to the candidate after.; // For example, if we have the candidate:; // C.Stores = [ST1, ST2, ST3, ST4]; // and after seeing ST2 we saw a load LD1, which did not alias with ST1 or; // ST2, then we would have recorded it into the PotentialAliases structure; // with the associated index value of ""1"". Then we see ST3 and ST4 and add; // them to the candidate group. We know that LD1 does not alias with ST1 or; // ST2, since we already did that check. However we don't yet know if it; // may alias ST3 and ST4, so we perform those checks now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:697,Performance,perform,perform,697,"// We know that the stores in the candidate are adjacent.; // Now we need to check if any potential aliasing instructions recorded; // during the search alias with load/stores added to the candidate after.; // For example, if we have the candidate:; // C.Stores = [ST1, ST2, ST3, ST4]; // and after seeing ST2 we saw a load LD1, which did not alias with ST1 or; // ST2, then we would have recorded it into the PotentialAliases structure; // with the associated index value of ""1"". Then we see ST3 and ST4 and add; // them to the candidate group. We know that LD1 does not alias with ST1 or; // ST2, since we already did that check. However we don't yet know if it; // may alias ST3 and ST4, so we perform those checks now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:34,Safety,hazard,hazards,34,"// Now we've checked for aliasing hazards, merge any stores left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding volatile or ordered stores to the candidate. We already have a; // check for this in instMayAlias() but that only get's called later between; // potential aliasing hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:180,Safety,hazard,hazards,180,// Avoid adding volatile or ordered stores to the candidate. We already have a; // check for this in instMayAlias() but that only get's called later between; // potential aliasing hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:26,Usability,simpl,simple,26,// We only handle merging simple stores of 1-4 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:89,Safety,hazard,hazard,89,// We do a simple search for mergeable stores prior to this one.; // Any potential alias hazard along the way terminates the search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:11,Usability,simpl,simple,11,// We do a simple search for mergeable stores prior to this one.; // Any potential alias hazard along the way terminates the search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:13,Safety,safe,safe,13,// This is a safe instruction we can look past.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:11,Performance,cache,cached,11,// Already cached sizes for this address space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:99,Deployability,pipeline,pipeline,99,"// Since the IRTranslator only emits constants into the entry block, and the; // rest of the GISel pipeline generally emits constants close to their users,; // we only localize instructions in the entry block here. This might change if; // we start doing CSE across blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:10,Performance,Tune,Tune,10,// FIXME: Tune this more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:3,Deployability,Update,Update,3,// Update the user reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:99,Availability,down,down,99,"// For each already-localized instruction which has multiple users, then we; // scan the block top down from the current position until we hit one of them.; // FIXME: Consider doing inst duplication if live ranges are very long due to; // many users, but this case may be better served by regalloc improvements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:114,Energy Efficiency,reduce,reduce,114,// Keep track of the instructions we localized. We'll do a second pass of; // intra-block localization to further reduce live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LostDebugLocObserver.cpp:409,Availability,checkpoint,checkpoints,409,"//===----- llvm/CodeGen/GlobalISel/LostDebugLocObserver.cpp -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// Tracks DebugLocs between checkpoints and verifies that they are transferred.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LostDebugLocObserver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LostDebugLocObserver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp:37,Usability,usab,usable,37,// Insert $noreg if we didn't find a usable constant and had to drop it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp:39,Performance,load,load,39,// This may be a size or type changing load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,Availability,repair,repair,40,// By default we assume we will have to repair something.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:24,Availability,down,down,24,"// Each part of a break down needs to end up in a different register.; // In other word, Reg assignment does not match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:32,Usability,simpl,simple,32,"// Reg is free of assignment, a simple assignment will make the; // register bank to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:43,Availability,repair,repairing,43,// An empty range of new register means no repairing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:17,Availability,repair,repairing,17,"// Assume we are repairing a use and thus, the original reg will be; // the source of the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:90,Availability,repair,repairing,90,"// Assume we are repairing a use and thus, the original reg will be; // the source of the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:9,Availability,repair,repair,9,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:74,Availability,repair,repairing,74,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:33,Availability,repair,repair,33,"// Build the instruction used to repair, then clone it at the right; // places. Avoiding buildCopy bypasses the check that Src and Dst have the; // same types because the type is a placeholder when this function is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:80,Safety,Avoid,Avoiding,80,"// Build the instruction used to repair, then clone it at the right; // places. Avoiding buildCopy bypasses the check that Src and Dst have the; // same types because the type is a placeholder when this function is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:119,Availability,down,down,119,"// If MO does not have a register bank, we should have just been; // able to set one unless we have to break the value down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:326,Availability,avail,available,326,"// Def: Val <- NewDefs; // Same number of values: copy; // Different number: Val = build_sequence Defs1, Defs2, ...; // Use: NewSources <- Val.; // Same number of values: copy.; // Different number: Src1, Src2, ... =; // extract_value Val, Src1Begin, Src1Len, Src2Begin, Src2Len, ...; // We should remember that this value is available somewhere else to; // coalesce the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:9,Availability,repair,repair,9,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:74,Availability,repair,repairing,74,"// If we repair a definition, swap the source and destination for; // the repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:66,Availability,repair,repair,66,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:466,Availability,repair,repairing,466,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,Safety,avoid,avoid,40,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:306,Usability,simpl,simply,306,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,Availability,repair,repairing,40,// Return the legalization cost of that repairing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:120,Availability,repair,repairing,120,"// If none of the mapping worked that means they are all impossible.; // Thus, pick the first one and set an impossible repairing point.; // It will trigger the failed isel mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:93,Availability,repair,repairing,93,"// Splitting should only occur for PHIs or between terminators,; // because we only do local repairing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:15,Availability,repair,repair,15,// We split to repair the use of a phi or a terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:29,Availability,repair,repair,29,"// At this point, we need to repair a defintion of a terminator.; // Technically we need to fix the def of MI on all outgoing; // edges of MI to keep the repairing local. In other words, we; // will create several definitions of the same register. This; // does not work for SSA unless that definition is a physical; // register.; // However, there are other cases where we can get away with; // that while still keeping the repairing local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:154,Availability,repair,repairing,154,"// At this point, we need to repair a defintion of a terminator.; // Technically we need to fix the def of MI on all outgoing; // edges of MI to keep the repairing local. In other words, we; // will create several definitions of the same register. This; // does not work for SSA unless that definition is a physical; // register.; // However, there are other cases where we can get away with; // that while still keeping the repairing local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:425,Availability,repair,repairing,425,"// At this point, we need to repair a defintion of a terminator.; // Technically we need to fix the def of MI on all outgoing; // edges of MI to keep the repairing local. In other words, we; // will create several definitions of the same register. This; // does not work for SSA unless that definition is a physical; // register.; // However, there are other cases where we can get away with; // that while still keeping the repairing local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:45,Availability,repair,repair,45,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:943,Availability,repair,repairing,943,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1044,Availability,down,down,1044,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1081,Availability,repair,repairing,1081,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1501,Availability,repair,repairing,1501,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1614,Availability,repair,repairing,1614,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:1126,Deployability,patch,patch,1126,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:340,Testability,Assert,Assert,340,"// We are going to split every outgoing edges.; // Check that this is possible.; // FIXME: The machine representation is currently broken; // since it also several terminators in one basic block.; // Because of that we would technically need a way to get; // the targets of just one terminator to know which edges; // we have to split.; // Assert that we do not hit the ill-formed representation.; // If there are other terminators before that one, some of; // the outgoing edges may not be dominated by this definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:35,Availability,repair,repair,35,// We will split all the edges and repair there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:23,Availability,repair,repair,23,"// There is nothing to repair, but we may actually lie on; // the repairing cost because of the PHIs already proceeded; // as already stated.; // Though the code will be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:66,Availability,repair,repairing,66,"// There is nothing to repair, but we may actually lie on; // the repairing cost because of the PHIs already proceeded; // as already stated.; // Though the code will be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:27,Availability,repair,repairing,27,"// We need to do non-local repairing. Basically, patch all; // the uses (i.e., phis) that we already proceeded.; // For now, just say this mapping is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:49,Deployability,patch,patch,49,"// We need to do non-local repairing. Basically, patch all; // the uses (i.e., phis) that we already proceeded.; // For now, just say this mapping is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:190,Availability,repair,repairing,190,"// Moreover, to realize this mapping, the register bank of each operand must; // match this mapping. In other words, we may need to locally reassign the; // register banks. Account for that repairing cost as well.; // In this context, local means in the surrounding of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:36,Availability,repair,repairing,36,// Find the insertion point for the repairing code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:41,Availability,repair,repairing,41,// Check that the materialization of the repairing is possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:34,Availability,repair,repair,34,// Account for the split cost and repair cost.; // Unless the cost is already saturated or we do not care about the cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:37,Availability,repair,repairing,37,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:67,Availability,repair,repairing,67,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:151,Availability,down,down,151,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:245,Availability,repair,repairing,245,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:344,Availability,repair,repairing,344,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:515,Availability,repair,repairing,515,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:82,Integrability,depend,depends,82,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:28,Availability,repair,repair,28,// This is an impossible to repair cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:60,Availability,repair,repair,60,"// We should not need more than a couple of instructions to repair; // an assignment. In other words, the computation should not; // overflow because the repairing cost is free of basic block; // frequency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:154,Availability,repair,repairing,154,"// We should not need more than a couple of instructions to repair; // an assignment. In other words, the computation should not; // overflow because the repairing cost is free of basic block; // frequency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:38,Availability,repair,repair,38,"// Stop looking into what it takes to repair, this is already; // too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:80,Availability,repair,repairing,80,// No need to accumulate more cost information.; // We need to still gather the repairing information though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:20,Availability,repair,repairing,20,"// First, place the repairing code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:11,Modifiability,rewrite,rewrite,11,"// Second, rewrite the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:16,Availability,repair,repairing,16,// Remember the repairing placement for all the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:15,Deployability,pipeline,pipeline,15,"// If the ISel pipeline failed, do not bother running that pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:46,Availability,repair,repair,46,"// Default is, we are going to insert code to repair OpIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:3,Availability,Repair,Repairings,3,"// Repairings for definitions happen after MI, uses happen before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:6,Availability,repair,repair,6,"// We repair a use of a phi, we may need to split the related edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:23,Availability,repair,repairing,23,// We cannot hoist the repairing code in the predecessor.; // Split the edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:56,Deployability,update,update,56,"// Since we do not support splitting, we do not need to update; // liveness and such, so do not do anything with P.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:192,Deployability,update,update,192,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:368,Deployability,update,update,368,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:505,Deployability,update,update,505,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:578,Security,access,access,578,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:77,Integrability,depend,depending,77,"// Otherwise the insertion point is just the current or next; // instruction depending on Before. I.e., there is nothing to do; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:16,Availability,repair,repairing,16,"// If we end up repairing twice at the same place before materializing the; // insertion point, we may think we have to split an edge twice.; // We should have a factory for the insert point such that identical points; // are the same instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:223,Safety,avoid,avoid,223,"// At this point we know both costs hold sensible values.; // If both values have a different base frequency, there is no much; // we can do but to scale everything.; // However, if they have the same base frequency we can avoid making; // complicated computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:103,Safety,avoid,avoiding,103,// The base costs are comparable so we may only keep the relative; // value to increase our chances of avoiding overflows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:457,Deployability,pipeline,pipeline,457,"//===- llvm/CodeGen/GlobalISel/Utils.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file This file implements the utility functions used by the GlobalISel; /// pipeline.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:15,Testability,log,logical,15,// FIXME: This logical is mostly duplicated with; // DeadMachineInstructionElim::isDead. Why is LOCAL_ESCAPE not considered in; // MachineInstr::isLabel?; // Don't delete frame allocation labels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:149,Availability,error,error,149,// Print the function name explicitly if we don't have a debug location (which; // makes the diagnostic less useful) or if we're going to emit a raw error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:3,Performance,Perform,Perform,3,// Perform irregular split. Leftover is last element of RegPieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:35,Security,access,access,35,// Irregular split. Provide direct access to all elements for artifact; // combiner using unmerge to elements. Then build vectors with NumElts; // elements. Remaining element(s) will be (used to build vector) Leftover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:190,Integrability,wrap,wrapper,190,"// FIXME: These operations were unfortunately named. fminnum/fmaxnum do not; // follow the IEEE behavior for signaling nans and follow libm's fmin/fmax,; // and currently there isn't a nice wrapper in APFloat for the version with; // correct snan handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:123,Usability,simpl,simplify,123,"// If all elements are undefined, this shuffle can be considered a splat.; // Return 0 for better potential for callers to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1401,Availability,avail,available,1401,"------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2933,Energy Efficiency,efficient,efficient,2933," /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:578,Modifiability,variab,variable,578,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:765,Modifiability,variab,variable,765,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:816,Modifiability,variab,variable,816,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:847,Modifiability,variab,variable,847,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:973,Modifiability,variab,variable,973,"//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1123,Modifiability,variab,variable,1123,"----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the varia",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1321,Modifiability,variab,variable,1321,"------------------------------------------------===//; /// \file InstrRefBasedImpl.cpp; ///; /// This is a separate implementation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1439,Modifiability,variab,variable,1439,"mentation of LiveDebugValues, see; /// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1941,Modifiability,variab,variable,1941," /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2067,Modifiability,variab,variable,2067," /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2212,Modifiability,variab,variable,2212,"mplete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2340,Modifiability,Variab,Variables,2340,"ineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A mac",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2479,Modifiability,variab,variable,2479,"m two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2577,Modifiability,Variab,Variable,2577,"of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2651,Modifiability,variab,variable,2651,"of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3234,Modifiability,variab,variables,3234," value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3478,Modifiability,variab,variable,3478,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3525,Modifiability,variab,variable,3525,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3537,Modifiability,variab,variable,3537,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3617,Modifiability,variab,variable,3617,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3971,Modifiability,variab,variables,3971,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3990,Modifiability,variab,variable,3990,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:4059,Modifiability,variab,variable,4059,"the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for debugging this; /// Collect statistics; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1504,Performance,perform,perform,1504,"d VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1953,Performance,perform,perform,1953," /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3175,Performance,perform,perform,3175," value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:202,Energy Efficiency,consumption,consumption,202,"// Limit for the maximum number of stack slots we should track, past which we; // will ignore any spills. InstrRefBasedLDV gathers detailed information on all; // stack slots which leads to high memory consumption, and in some scenarios; // (such as asan with very many locals) the working set of the function can be; // very large, causing many spills. In these scenarios, it is very unlikely that; // the developer has hundreds of variables live at the same time that they're; // carefully thinking about -- instead, they probably autogenerated the code.; // When this happens, gracefully stop tracking excess spill slots, rather than; // consuming all the developer's memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:433,Modifiability,variab,variables,433,"// Limit for the maximum number of stack slots we should track, past which we; // will ignore any spills. InstrRefBasedLDV gathers detailed information on all; // stack slots which leads to high memory consumption, and in some scenarios; // (such as asan with very many locals) the working set of the function can be; // very large, causing many spills. In these scenarios, it is very unlikely that; // the developer has hundreds of variables live at the same time that they're; // carefully thinking about -- instead, they probably autogenerated the code.; // When this happens, gracefully stop tracking excess spill slots, rather than; // consuming all the developer's memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:937,Availability,avail,available,937,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:55,Modifiability,variab,variable,55,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:81,Modifiability,variab,variable,81,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:356,Modifiability,variab,variable,356,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:483,Modifiability,variab,variable,483,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:518,Modifiability,variab,variable,518,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:825,Modifiability,variab,variable,825,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1001,Modifiability,variab,variable,1001,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:291,Performance,load,loaded,291,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:961,Safety,detect,detect,961,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:29,Modifiability,variab,variable,29,"/// Record of all changes in variable locations at a block position. Awkwardly; /// we allow inserting either before or after the point: MBB != nullptr; /// indicates it's before, otherwise after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:116,Modifiability,variab,variable,116,"/// Local cache of what-value-is-in-what-LocIdx. Used to identify differences; /// between TransferTrackers view of variable locations and MLocTrackers. For; /// example, MLocTracker observes all clobbers, but TransferTracker lazily; /// does not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Performance,cache,cache,10,"/// Local cache of what-value-is-in-what-LocIdx. Used to identify differences; /// between TransferTrackers view of variable locations and MLocTrackers. For; /// example, MLocTracker observes all clobbers, but TransferTracker lazily; /// does not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Performance,cache,cache,14,/// Temporary cache of DBG_VALUEs to be entered into the Transfers collection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:100,Availability,avail,available,100,"/// Record of a use-before-def: created when a value that's live-in to the; /// current block isn't available in any machine location, but it will be; /// defined in this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:18,Modifiability,variab,variable,18,"/// Value of this variable, def'd in block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:21,Modifiability,variab,variable,21,/// Identity of this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:15,Modifiability,variab,variable,15,/// Additional variable properties.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:15,Modifiability,variab,variables,15,/// The set of variables that are in UseBeforeDefs and can become a location; /// once the relevant value is defined. An element being erased from this; /// collection prevents the use-before-def materializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variable,10,"/// For a variable \p Var with the live-in value \p Value, attempts to resolve; /// the DbgValue to a concrete DBG_VALUE, emitting that value and loading the; /// tracking information to track Var throughout the block.; /// \p ValueToLoc is a map containing the best known location for every; /// ValueIDNum that Value may use.; /// \p MBB is the basic block that we are loading the live-in value for.; /// \p DbgOpStore is the map containing the DbgOpID->DbgOp mapping needed to; /// determine the values used by Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:146,Performance,load,loading,146,"/// For a variable \p Var with the live-in value \p Value, attempts to resolve; /// the DbgValue to a concrete DBG_VALUE, emitting that value and loading the; /// tracking information to track Var throughout the block.; /// \p ValueToLoc is a map containing the best known location for every; /// ValueIDNum that Value may use.; /// \p MBB is the basic block that we are loading the live-in value for.; /// \p DbgOpStore is the map containing the DbgOpID->DbgOp mapping needed to; /// determine the values used by Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:371,Performance,load,loading,371,"/// For a variable \p Var with the live-in value \p Value, attempts to resolve; /// the DbgValue to a concrete DBG_VALUE, emitting that value and loading the; /// tracking information to track Var throughout the block.; /// \p ValueToLoc is a map containing the best known location for every; /// ValueIDNum that Value may use.; /// \p MBB is the basic block that we are loading the live-in value for.; /// \p DbgOpStore is the map containing the DbgOpID->DbgOp mapping needed to; /// determine the values used by Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:51,Availability,avail,available,51,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:243,Availability,avail,available,243,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:541,Availability,avail,available,541,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:591,Availability,recover,recover,591,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:662,Modifiability,variab,variable,662,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:591,Safety,recover,recover,591,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:49,Modifiability,variab,variable,49,"// If the value has no location, we can't make a variable location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:92,Modifiability,variab,variable,92,"// If we cannot produce a valid value for the LiveIn value within this; // block, skip this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Availability,avail,available,23,"// The LiveIn value is available at block entry, begin tracking and record; // the transfer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:29,Modifiability,variab,variable,29,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:141,Modifiability,variab,variable,141,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:181,Modifiability,variab,variable,181,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:216,Modifiability,variab,variables,216,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:332,Modifiability,variab,variable,332,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:4,Performance,Load,Load,4,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,"// Is there a variable that wants a location for this value? If not, skip.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Modifiability,variab,variables,11,// Now map variables to their picked LocIdxes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:61,Availability,avail,available,61,"/// Record that \p Var has value \p ID, a value that becomes available; /// later in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:115,Modifiability,variab,variable,115,"/// After the instruction at index \p Inst and position \p pos has been; /// processed, check whether it defines a variable value in a use-before-def.; /// If so, and the variable value hasn't changed since the start of the; /// block, create a DBG_VALUE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:171,Modifiability,variab,variable,171,"/// After the instruction at index \p Inst and position \p pos has been; /// processed, check whether it defines a variable value in a use-before-def.; /// If so, and the variable value hasn't changed since the start of the; /// block, create a DBG_VALUE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:113,Availability,avail,available,113,// Map of values to the locations that store them for every value used by; // the variables that may have become available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:82,Modifiability,variab,variables,82,// Map of values to the locations that store them for every value used by; // the variables that may have become available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:98,Modifiability,variab,variables,98,// Populate ValueToLoc with illegal default mappings for every value used by; // any UseBeforeDef variables for this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,"// Is there a variable that wants a location for this value? If not, skip.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:84,Modifiability,variab,variable,84,"// Using the map of values to locations, produce a final set of values for; // this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:63,Availability,avail,available,63,"// If at least one value used by this debug value is no longer available,; // i.e. one of the values was killed before we finished defining all of; // the values used by this variable, discard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:175,Modifiability,variab,variable,175,"// If at least one value used by this debug value is no longer available,; // i.e. one of the values was killed before we finished defining all of; // the values used by this variable, discard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Modifiability,variab,variable,11,"// Is this variable location a candidate to be an entry value. First,; // should we be trying this at all?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variable,10,"// Is the variable appropriate for entry values (i.e., is a parameter).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Modifiability,variab,variable,33,// Is the value assigned to this variable still the entry value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variable,10,// Emit a variable location using an entry value expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Modifiability,variab,variable,13,/// Change a variable value after encountering a DBG_VALUE inside a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Modifiability,variab,variable,23,"/// Handle a change in variable location within a block. Terminate the; /// variables current location, and record the value it now refers to, so; /// that we can detect location transfers later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:76,Modifiability,variab,variables,76,"/// Handle a change in variable location within a block. Terminate the; /// variables current location, and record the value it now refers to, so; /// that we can detect location transfers later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:163,Safety,detect,detect,163,"/// Handle a change in variable location within a block. Terminate the; /// variables current location, and record the value it now refers to, so; /// that we can detect location transfers later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Modifiability,variab,variable,16,"// Every active variable mapping for NewLoc will be cleared, no; // need to track individual variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,Modifiability,variab,variables,93,"// Every active variable mapping for NewLoc will be cleared, no; // need to track individual variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:52,Usability,clear,cleared,52,"// Every active variable mapping for NewLoc will be cleared, no; // need to track individual variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:124,Availability,recover,recover,124,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:273,Availability,recover,recovered,273,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:64,Modifiability,variab,variable,64,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:124,Safety,recover,recover,124,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:273,Safety,recover,recovered,273,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:20,Modifiability,variab,variable,20,// What was the old variable value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:156,Deployability,update,updated,156,/// Overload that takes an explicit value \p OldValue for when the value in; /// \p MLoc has changed and the TransferTracker's locations have not been; /// updated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,Availability,recover,recover,93,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Modifiability,variab,variable,25,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,Safety,recover,recover,93,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:61,Modifiability,variab,variable,61,"// If there is no location, and we weren't asked to make the variable; // explicitly undef, then stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Availability,recover,recover,11,// Try and recover a few more locations with entry values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Safety,recover,recover,11,// Try and recover a few more locations with entry values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:19,Modifiability,variab,variables,19,// Examine all the variables based on this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Integrability,depend,depends,58,"// If no new location has been found, every variable that depends on this; // MLoc is dead, so end their existing MLoc->Var mappings as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Modifiability,variab,variable,44,"// If no new location has been found, every variable that depends on this; // MLoc is dead, so end their existing MLoc->Var mappings as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Modifiability,variab,variable,16,"// Re-state the variable location: if there's no replacement then NewLoc; // is std::nullopt and a $noreg DBG_VALUE will be created. Otherwise, a; // DBG_VALUE identifying the alternative location will be emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Update,Update,3,// Update machine locations <=> variable locations maps. Defer updating; // ActiveMLocs to avoid invalidating the ActiveMLocIt iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:32,Modifiability,variab,variable,32,// Update machine locations <=> variable locations maps. Defer updating; // ActiveMLocs to avoid invalidating the ActiveMLocIt iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:91,Safety,avoid,avoid,91,// Update machine locations <=> variable locations maps. Defer updating; // ActiveMLocs to avoid invalidating the ActiveMLocIt iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,Modifiability,variab,variables,10,// Remove variables from ActiveMLocs if they no longer use any other MLocs; // due to being killed by this clobber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Modifiability,variab,variables,13,/// Transfer variables based on \p Src to be based on \p Dst. This handles; /// both register copies as well as spills and restores. Creates DBG_VALUEs; /// describing the movement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:108,Modifiability,variab,variable,108,"// Does Src still contain the value num we expect? If not, it's been; // clobbered in the meantime, and our variable locations are stale.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:142,Modifiability,variab,variables,142,// assert(ActiveMLocs[Dst].size() == 0);; //^^^ Legitimate scenario on account of un-clobbered slot being assigned to?; // Move set of active variables from one location to another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Testability,assert,assert,3,// assert(ActiveMLocs[Dst].size() == 0);; //^^^ Legitimate scenario on account of un-clobbered slot being assigned to?; // Move set of active variables from one location to another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:12,Modifiability,variab,variable,12,// For each variable based on Src; create a location at Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Update,Update,3,// Update all instances of Src in the variable's tracked values to Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:38,Modifiability,variab,variable,38,// Update all instances of Src in the variable's tracked values to Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:22,Availability,failure,failure,22,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Safety,Detect,Detect,3,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:56,Safety,avoid,avoids,56,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Availability,mask,mask,33,"// Don't clobber SP, even if the mask says it's clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:119,Deployability,update,update,119,"// If all locations are valid, accumulate them into our list of; // MachineOperands. For any spilled locations, either update the indirectness; // register or apply the appropriate transformations in the DIExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:17,Modifiability,variab,variables,17,"// TODO: support variables that are located in spill slots, with non-zero; // offsets from the start of the spill slot. It would require some more; // complex DIExpression calculations. This doesn't seem to be produced by; // LLVM right now, so don't try and support it.; // Accept no-subregister slots and subregisters where the offset is zero.; // The consumer should already have type information to work out how large; // the variable is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:430,Modifiability,variab,variable,430,"// TODO: support variables that are located in spill slots, with non-zero; // offsets from the start of the spill slot. It would require some more; // complex DIExpression calculations. This doesn't seem to be produced by; // LLVM right now, so don't try and support it.; // Accept no-subregister slots and subregisters where the offset is zero.; // The consumer should already have type information to work out how large; // the variable is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:100,Modifiability,variab,variables,100,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:206,Modifiability,Variab,Variables,206,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:351,Modifiability,variab,variable,351,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:560,Modifiability,variab,variable,560,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:676,Safety,avoid,avoid,676,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:428,Usability,simpl,simple,428,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Modifiability,variab,variable,34,"// This is something like an NRVO variable, where the pointer has been; // spilt to the stack. It should end up being a memory location, with; // the pointer to the variable loaded off the stack with a deref:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:165,Modifiability,variab,variable,165,"// This is something like an NRVO variable, where the pointer has been; // spilt to the stack. It should end up being a memory location, with; // the pointer to the variable loaded off the stack with a deref:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:174,Performance,load,loaded,174,"// This is something like an NRVO variable, where the pointer has been; // spilt to the stack. It should end up being a memory location, with; // the pointer to the variable loaded off the stack with a deref:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:153,Modifiability,variab,variable,153,"// TODO: Figure out how to handle deref size issues for variadic; // values.; // We're loading a value off the stack that's not the same size as the; // variable. Add / subtract stack offset, explicitly deref with a; // size, and add DW_OP_stack_value if not already present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:87,Performance,load,loading,87,"// TODO: Figure out how to handle deref size issues for variadic; // values.; // We're loading a value off the stack that's not the same size as the; // variable. Add / subtract stack offset, explicitly deref with a; // size, and add DW_OP_stack_value if not already present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:5,Modifiability,variab,variable,5,"// A variable with no size ambiguity, but with extra elements in it's; // expression. Manually dereference the stack location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:133,Performance,load,loaded,133,"// Where in the stack slot is this value defined -- i.e., what size of value; // is this? An important question, because it could be loaded into a register; // from the stack at some point. Happily the memory operand will tell us; // the size written to the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:120,Modifiability,variab,variable,120,"// That index is not tracked. This is suprising, and unlikely to ever; // occur, but the safe action is to indicate the variable is optimised out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,Safety,safe,safe,89,"// That index is not tracked. This is suprising, and unlikely to ever; // occur, but the safe action is to indicate the variable is optimised out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:96,Modifiability,variab,variable,96,"// If there are no instructions in this lexical scope, do no location tracking; // at all, this variable shouldn't get a legitimate location range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:47,Modifiability,variab,variables,47,"// If we're preparing for the second analysis (variables), the machine value; // locations are already solved, and we report this DBG_VALUE and the value; // it refers to to VLocTracker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Modifiability,variab,variable,23,"// Feed defVar the new variable location, or if this is a DBG_VALUE $noreg,; // feed defVar None.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Modifiability,variab,variable,58,"// If performing final tracking of transfers, report this variable definition; // to the TransferTracker too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,Performance,perform,performing,6,"// If performing final tracking of transfers, report this variable definition; // to the TransferTracker too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,Performance,optimiz,optimizations,11,"// Various optimizations may have happened to the value during codegen,; // recorded in the value substitution table. Apply any substitutions to; // the instruction / operand number in this DBG_INSTR_REF, and collect; // any subregister extractions performed during optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:249,Performance,perform,performed,249,"// Various optimizations may have happened to the value during codegen,; // recorded in the value substitution table. Apply any substitutions to; // the instruction / operand number in this DBG_INSTR_REF, and collect; // any subregister extractions performed during optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:266,Performance,optimiz,optimization,266,"// Various optimizations may have happened to the value during codegen,; // recorded in the value substitution table. Apply any substitutions to; // the instruction / operand number in this DBG_INSTR_REF, and collect; // any subregister extractions performed during optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:118,Performance,optimiz,optimized,118,"// Default machine value number is <None> -- if no instruction defines; // the corresponding value, it must have been optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:273,Modifiability,variab,variable,273,"// Permit the debug-info to be completely wrong: identifying a nonexistant; // operand, or one that is not a register definition, means something; // unexpected happened during optimisation. Broken debug-info, however,; // shouldn't crash the compiler -- instead leave the variable value as; // None, which will make it appear ""optimised out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:57,Modifiability,variab,variable,57,// Only handle this instruction when we are building the variable value; // transfer function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Modifiability,variab,variable,34,// Handled by doing nothing. This variable is never in scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:118,Performance,optimiz,optimized,118,"// Default machine value number is <None> -- if no instruction defines; // the corresponding value, it must have been optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:269,Availability,avail,available,269,"// We have a DbgOpID for every value or for none. Tell the variable value; // tracker about it. The rest of this LiveDebugValues implementation acts; // exactly the same for DBG_INSTR_REFs as DBG_VALUEs (just, the former can; // refer to values that aren't immediately available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:59,Modifiability,variab,variable,59,"// We have a DbgOpID for every value or for none. Tell the variable value; // tracker about it. The rest of this LiveDebugValues implementation acts; // exactly the same for DBG_INSTR_REFs as DBG_VALUEs (just, the former can; // refer to values that aren't immediately available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Modifiability,variab,variable,34,// Tell transfer tracker that the variable value has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Performance,optimiz,optimized,44,"// If the stack slot is dead, then this was optimized away.; // FIXME: stack slot colouring should account for slots that get merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:64,Safety,avoid,avoid,64,"// We might be able to find a value, but have chosen not to, to avoid; // tracking too much stack information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Testability,Test,Test,3,// Test whether we should ignore a def of this register due to it being part; // of the stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:105,Energy Efficiency,allocate,allocated,105,"// Find the regs killed by MI, and find regmasks of preserved regs.; // Max out the number of statically allocated elements in `DeadRegs`, as this; // prevents fallback to std::set::count() operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:122,Availability,recover,recover,122,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:19,Modifiability,variab,variable,19,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,Modifiability,variab,variable,134,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:122,Safety,recover,recover,122,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:49,Availability,mask,mask,49,// Look for any clobbers performed by a register mask. Only test locations; // that are actually being tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Performance,perform,performed,25,// Look for any clobbers performed by a register mask. Only test locations; // that are actually being tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:60,Testability,test,test,60,// Look for any clobbers performed by a register mask. Only test locations; // that are actually being tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:37,Performance,load,loads,37,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,Security,access,access,89,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:37,Performance,load,loads,37,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,Security,access,access,89,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Modifiability,variab,variable,102,"// First, if there are any DBG_VALUEs pointing at a spill slot that is; // written to, terminate that variable location. The value in memory; // will have changed. DbgEntityHistoryCalculator doesn't try to detect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:206,Safety,detect,detect,206,"// First, if there are any DBG_VALUEs pointing at a spill slot that is; // written to, terminate that variable location. The value in memory; // will have changed. DbgEntityHistoryCalculator doesn't try to detect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:208,Availability,recover,recover,208,"// We need to over-write the stack slot with something (here, a def at; // this instruction) to ensure no values are preserved in this stack slot; // after the spill. It also prevents TTracker from trying to recover the; // location and re-installing it in the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:240,Deployability,install,installing,240,"// We need to over-write the stack slot with something (here, a def at; // this instruction) to ensure no values are preserved in this stack slot; // after the spill. It also prevents TTracker from trying to recover the; // location and re-installing it in the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:208,Safety,recover,recover,208,"// We need to over-write the stack slot with something (here, a def at; // this instruction) to ensure no values are preserved in this stack slot; // after the spill. It also prevents TTracker from trying to recover the; // location and re-installing it in the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:62,Performance,load,load,62,"// Now find subregisters within the destination register, and load values; // from stack slot positions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,Availability,recover,recover,134,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Deployability,update,update,13,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:172,Modifiability,variab,variables,172,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,Safety,recover,recover,134,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:63,Modifiability,variab,variables,63,"// If ActiveMLocs isn't tracking this location or there are no variables; // using it, don't bother remembering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Availability,avail,available,44,"// Copy MTracker info, including subregs if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Modifiability,variab,variables,33,"// The copy might have clobbered variables based on the destination register.; // Tell TTracker about it, passing the old ValueIDNum to search for; // alternative locations (or else terminating those variables).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:200,Modifiability,variab,variables,200,"// The copy might have clobbered variables based on the destination register.; // Tell TTracker about it, passing the old ValueIDNum to search for; // alternative locations (or else terminating those variables).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:132,Energy Efficiency,reduce,reduces,132,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed debug instruction to analyze for; /// fragment usage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:41,Modifiability,variab,variable,41,"// If this is the first sighting of this variable, then we are guaranteed; // there are currently no overlapping fragments either. Initialize the set; // of seen fragments, record no overlaps for the current one, and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:22,Modifiability,Variab,Variable,22,"// If this particular Variable/Fragment pair already exists in the overlap; // map, it has already been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:56,Modifiability,variab,variable,56,"// Otherwise, examine all other seen fragments for this variable, with ""this""; // fragment being a previously unseen fragment. Record any pair of; // overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:46,Availability,mask,mask,46,"// Because we try to optimize around register mask operands by ignoring regs; // that aren't currently tracked, we set up something ugly for later: RegMask; // operands that are seen earlier than the first use of a register, still need; // to clobber that register in the transfer function. But this information; // isn't actively recorded. Instead, we track each RegMask used in each block,; // and accumulated the clobbered but untracked registers in each block into; // the following bitvector. Later, if new values are tracked, we can add; // appropriate clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:21,Performance,optimiz,optimize,21,"// Because we try to optimize around register mask operands by ignoring regs; // that aren't currently tracked, we set up something ugly for later: RegMask; // operands that are seen earlier than the first use of a register, still need; // to clobber that register in the transfer function. But this information; // isn't actively recorded. Instead, we track each RegMask used in each block,; // and accumulated the clobbered but untracked registers in each block into; // the following bitvector. Later, if new values are tracked, we can add; // appropriate clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:40,Availability,mask,masks,40,// Reserve one bit per register for the masks described above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:13,Deployability,update,update,13,// Insert-or-update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Availability,mask,mask,58,// Accumulate any bitmask operands into the clobbered reg mask for this; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Install,Install,3,"// Install a value representing the fact that this location is effectively; // written to in this block. As there's no reserved value, instead use; // a value number that is never generated. Pick the value number for the; // first instruction in the block, def'ing this location, which we know; // this block never used anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:237,Availability,redundant,redundant,237,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:237,Safety,redund,redundant,237,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:202,Testability,test,test,202,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,Testability,assert,assert,23,// FIXME: We don't use assert here to prevent instr-ref-unreachable.mir; // failing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Availability,redundant,redundant,102,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Safety,redund,redundant,102,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:68,Testability,test,test,68,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:108,Testability,test,test,108,// We're now examining a PHI to see whether it's un-necessary. Loop around; // the other live-in values and test whether they're all the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,Safety,avoid,avoid,6,"// To avoid repeatedly running the PHI placement algorithm, leverage the; // fact that a def of register MUST also def its register units. Find the; // units for registers, place PHIs for them, and then replicate them for; // aliasing registers. Some inputs that are never def'd (DBG_PHIs of; // arguments) don't lead to register units being tracked, just place PHIs for; // those registers directly. Stack slots have their own form of ""unit"",; // store them to one side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:22,Performance,load,loaded,22,"// Not all roots were loaded into the tracking map: this register; // isn't actually def'd anywhere, we only read from it. Generate PHIs; // for this reg, but don't iterate units.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:64,Usability,Clear,Clear,64,// Ask the SSA construction algorithm where we should put PHIs. Clear; // anything that might have been hanging around from earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Install,Install,3,// Install those PHI values into the live-in value array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:77,Deployability,install,install,77,"// For stack slots, calculate PHIs for the equivalent of the units, then; // install for each index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:48,Deployability,install,install,48,"// Find anything that aliases this stack index, install PHIs for it too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Install,Install,3,// Install those PHI values into the live-in value array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:24,Deployability,install,install,24,// Now find aliases and install PHIs for those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:144,Performance,queue,queue,144,"// We track what is on the current and pending worklist to avoid inserting; // the same thing twice. We could avoid this with a custom priority queue,; // but this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:59,Safety,avoid,avoid,59,"// We track what is on the current and pending worklist to avoid inserting; // the same thing twice. We could avoid this with a custom priority queue,; // but this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:110,Safety,avoid,avoid,110,"// We track what is on the current and pending worklist to avoid inserting; // the same thing twice. We could avoid this with a custom priority queue,; // but this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Availability,redundant,redundant,33,"// Propagate values to eliminate redundant PHIs. At the same time, this; // produces the table of Block x Location => Value for the entry to each; // block.; // The kind of PHIs we can eliminate are, for example, where one path in a; // conditional spills and restores a register, and the register still has; // the same value once control flow joins, unbeknowns to the PHI placement; // code. Propagating values allows us to identify such un-necessary PHIs and; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Safety,redund,redundant,33,"// Propagate values to eliminate redundant PHIs. At the same time, this; // produces the table of Block x Location => Value for the entry to each; // block.; // The kind of PHIs we can eliminate are, for example, where one path in a; // conditional spills and restores a register, and the register still has; // the same value once control flow joins, unbeknowns to the PHI placement; // code. Propagating values allows us to identify such un-necessary PHIs and; // remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Performance,Load,Load,3,// Load the current set of live-ins into MLocTracker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,Availability,redundant,redundant,78,"// Once all the live-ins don't change on mlocJoin(), we've eliminated all; // redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,Safety,redund,redundant,78,"// Once all the live-ins don't change on mlocJoin(), we've eliminated all; // redundant PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:47,Modifiability,variab,variable,47,"// Collect all the incoming DbgValues for this variable, from predecessor; // live-out values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:117,Safety,safe,safe,117,"// If there were no values, or one of the predecessors couldn't have a; // value, then give up immediately. It's not safe to produce a live-in; // value. Leave as whatever it was before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:83,Modifiability,variab,variable,83,"// All (non-entry) blocks have at least one non-backedge predecessor.; // Pick the variable value from the first of these, to compare against; // all others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:12,Modifiability,variab,variable,12,"// Scan for variable values that can never be resolved: if they have; // different DIExpressions, different indirectness, or are mixed constants /; // non-constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,Modifiability,variab,variable,33,"// VarLoc LiveDebugValues tracks variable locations that are defined in; // blocks not in scope. This is something we could legitimately ignore, but; // lets allow it for now for the sake of coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:49,Modifiability,variab,variable,49,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:83,Modifiability,variab,variables,83,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:293,Performance,Perform,Perform,293,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,Safety,avoid,avoid,6,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:128,Modifiability,variab,variables,128,"// This method is much like buildMLocValueMap: but focuses on a single; // LexicalScope at a time. Pick out a set of blocks and variables that are; // to have their value assignments solved, then run our dataflow algorithm; // until a fixedpoint is reached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate some vectors for storing the live ins and live outs. Large.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:18,Modifiability,variab,variable,18,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:189,Modifiability,variab,variable,189,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:228,Modifiability,variab,variable,228,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:168,Safety,avoid,avoids,168,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,Modifiability,variab,variables,78,"// Re-initialize live-ins and live-outs, to clear the remains of previous; // variables live-ins / live-outs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Usability,clear,clear,44,"// Re-initialize live-ins and live-outs, to clear the remains of previous; // variables live-ins / live-outs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:18,Modifiability,variab,variable,18,"// Place PHIs for variable values, using the LLVM IDF calculator.; // Collect the set of blocks where variables are def'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,Modifiability,variab,variables,102,"// Place PHIs for variable values, using the LLVM IDF calculator.; // Collect the set of blocks where variables are def'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:53,Modifiability,variab,variable,53,"// Request the set of PHIs we should insert for this variable. If there's; // only one value definition, things are very simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:121,Usability,simpl,simple,121,"// Request the set of PHIs we should insert for this variable. If there's; // only one value definition, things are very simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,Modifiability,variab,variable,58,// Insert PHIs into the per-block live-in tables for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:60,Modifiability,variab,variables,60,"// Iterate over all the blocks we selected, propagating the variables value.; // This loop does two things:; // * Eliminates un-necessary VPHIs in vlocJoin,; // * Evaluates the blocks transfer function (i.e. variable assignments) and; // stores the result to the blocks live-outs.; // Always evaluate the transfer function on the first iteration, and when; // the live-ins change thereafter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:208,Modifiability,variab,variable,208,"// Iterate over all the blocks we selected, propagating the variables value.; // This loop does two things:; // * Eliminates un-necessary VPHIs in vlocJoin,; // * Evaluates the blocks transfer function (i.e. variable assignments) and; // stores the result to the blocks live-outs.; // Always evaluate the transfer function on the first iteration, and when; // the live-ins change thereafter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Deployability,Update,Updates,34,"// Join values from predecessors. Updates LiveInIdx, and writes output; // into JoinedInLocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:113,Availability,avail,available,113,"// If this block's live-in value is a VPHI, try to pick a machine-value; // for it. This makes the machine-value available and propagated; // through all blocks by the time value propagation finishes. We can't; // do this any earlier as it needs to read the block live-outs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,// Insert new variable value; or overwrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:179,Availability,avail,available,179,"// Save live-ins to output vector. Ignore any that are still marked as being; // VPHIs with no location -- those are variables that we know the value of,; // but are not actually available in the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:117,Modifiability,variab,variables,117,"// Save live-ins to output vector. Ignore any that are still marked as being; // VPHIs with no location -- those are variables that we know the value of,; // but are not actually available in the register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:7,Modifiability,variab,variable,7,// Per-variable loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:42,Modifiability,variab,variable,42,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:298,Modifiability,variab,variable,298,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:402,Modifiability,variab,variable,402,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:526,Modifiability,variab,variables,526,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:103,Usability,simpl,simple,103,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variable,14,// Assign the variable value to entry to each dominated block that's in scope.; // Skip the definition block -- it's assigned the variable value in the middle; // of the block somewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:130,Modifiability,variab,variable,130,// Assign the variable value to entry to each dominated block that's in scope.; // Skip the definition block -- it's assigned the variable value in the middle; // of the block somewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:67,Modifiability,variab,variable,67,"// All blocks that aren't dominated have no live-in value, thus no variable; // value will be given to them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:26,Testability,test,test,26,"// As an expensive check, test whether there are any duplicate substitution; // sources in the collection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:17,Modifiability,variab,variable,17,// No scopes? No variable locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:104,Modifiability,variab,variable,104,"// Helper lambda for ejecting a block -- if nothing is going to use the block,; // we can translate the variable location information into DBG_VALUEs and then; // free all of InstrRefBasedLDV's data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:85,Deployability,install,installing,85,"// Prime the transfer-tracker, and then step through all the block; // instructions, installing transfers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Modifiability,variab,variable,25,// We don't need live-in variable values for this block either.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:291,Modifiability,variab,variable,291,"// We obesrve scopes with children twice here, once descending in, once; // ascending out of the scope nest. Use HighestDFSIn as a ratchet to ensure; // we don't process a scope twice. Additionally, ignore scopes that don't; // have a DILocation -- by proxy, this means we never tracked any variable; // assignments in that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:79,Modifiability,extend,extend,79,/// Calculate the liveness information for the given machine function and; /// extend ranges across basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate and initialize two array-of-arrays for the live-in and live-out; // machine values. The outer dimension is the block number; while the inner; // dimension is a LocIdx from MLocTracker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:215,Modifiability,variab,variable,215,"// Solve the machine value dataflow problem using the MLocTransfer function,; // storing the computed live-ins / live-outs into the array-of-arrays. We use; // both live-ins and live-outs for decision making in the variable value; // dataflow problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Deployability,Patch,Patch,3,"// Patch up debug phi numbers, turning unknown block-live-in values into; // either live-through machine values, or PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Modifiability,variab,variables,14,"// Number all variables in the order that they appear, to be used as a stable; // insertion order later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:40,Modifiability,variab,variables,40,// Map from one LexicalScope to all the variables in that scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,Modifiability,variab,variables,44,"// To mirror old LiveDebugValues, enumerate variables in RPOT order. Otherwise; // the order is unimportant, it just has to be stable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Modifiability,variab,variable,16,// Collect each variable with a DBG_VALUE in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:43,Modifiability,variab,variable,43,"// If we have an extremely large number of variable assignments and blocks,; // bail out at this point. We've burnt some time doing analysis already,; // however we should cut our losses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:25,Modifiability,variab,variable,25,"// Optionally, solve the variable value problem and emit to blocks by using; // a lexical-scope-depth search. It should be functionally identical to; // the ""else"" block of this condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:101,Availability,robust,robust,101,"// Pick a type to identify incoming block values as we construct SSA. We; // can't use anything more robust than an integer unfortunately, as SSAUpdater; // expects to zero-initialize the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:43,Deployability,update,updater,43,"/// Represents an SSA PHI node for the SSA updater class. Contains the block; /// this PHI is in, the value number it would have, and the expected incoming; /// values from parent blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:9,Integrability,wrap,wrapper,9,/// Thin wrapper around a block predecessor iterator. Only difference from a; /// normal block iterator is that it dereferences to an LDVSSABlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:40,Deployability,Update,Updater,40,/// Thin wrapper around a block for SSA Updater interface. Necessary because; /// we need to track the PHI value(s) that we may have observed as necessary; /// in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:9,Integrability,wrap,wrapper,9,/// Thin wrapper around a block for SSA Updater interface. Necessary because; /// we need to track the PHI value(s) that we may have observed as necessary; /// in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:48,Integrability,interface,interface,48,/// Thin wrapper around a block for SSA Updater interface. Necessary because; /// we need to track the PHI value(s) that we may have observed as necessary; /// in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:37,Integrability,interface,interface,37,"/// Utility class for the SSAUpdater interface: tracks blocks, PHIs and values; /// while SSAUpdater is exploring the CFG. It's passed as a handle / baton to; // SSAUpdaterTraits<LDVSSAUpdater>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:30,Integrability,wrap,wrapper,30,"/// For a given MBB, create a wrapper block for it. Stores it in the; /// LDVSSAUpdater block map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:47,Security,access,access,47,"/// Template specialization to give SSAUpdater access to CFG and value; /// information. SSAUpdater calls methods in these traits, passing in the; /// LDVSSAUpdater object, to learn about blocks and the values they define.; /// It also provides methods to create PHI nodes and track them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:176,Usability,learn,learn,176,"/// Template specialization to give SSAUpdater access to CFG and value; /// information. SSAUpdater calls methods in these traits, passing in the; /// LDVSSAUpdater object, to learn about blocks and the values they define.; /// It also provides methods to create PHI nodes and track them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:62,Integrability,wrap,wrapper,62,// Methods to access block successors -- dereferencing to our wrapper class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,Security,access,access,14,// Methods to access block successors -- dereferencing to our wrapper class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:138,Availability,recover,recover,138,"// If any DBG_PHIs referred to a location we didn't understand, don't try to; // compute a value. There might be scenarios where we could recover a value; // for some range of DBG_INSTR_REFs, but at this point we can have high; // confidence that we've seen a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:138,Safety,recover,recover,138,"// If any DBG_PHIs referred to a location we didn't understand, don't try to; // compute a value. There might be scenarios where we could recover a value; // for some range of DBG_INSTR_REFs, but at this point we can have high; // confidence that we've seen a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:287,Deployability,update,updater,287,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:413,Deployability,Update,Updater,413,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:396,Energy Efficiency,Adapt,Adapted,396,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:396,Modifiability,Adapt,Adapted,396,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:34,Deployability,Update,Updater,34,"// Otherwise, we must use the SSA Updater. It will identify the value number; // that we are to use, and the PHIs that must happen along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:295,Safety,abort,abort,295,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:404,Security,Validat,Validate,404,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:669,Security,validat,validated,669,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:701,Security,Validat,ValidatedValues,701,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:42,Security,Validat,ValidatedValues,42,// Define all the input DBG_PHI values in ValidatedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,Security,validat,validate,16,// Sort PHIs to validate into RPO-order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:24,Security,validat,validated,24,// Record this value as validated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:23,Testability,test,test,23,"// Forward dec of unit test class, so that we can peer into the LDV object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:80,Security,access,accessor,80,"/// A collection of ValueTables, one per BB in a function, with convenient; /// accessor methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:9,Integrability,wrap,wrapper,9,/// Thin wrapper around an integer -- designed to give more type safety to; /// spill location numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:65,Safety,safe,safety,65,/// Thin wrapper around an integer -- designed to give more type safety to; /// spill location numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:169,Safety,avoid,avoid,169,"/// TODO: Might pack better if we changed this to a Struct of Arrays, since; /// MachineOperand is width 32, making this struct width 33. We could also; /// potentially avoid storing the whole MachineOperand (sizeof=32), instead; /// choosing to store just the contents portion (sizeof=8) and a Kind enum,; /// since we already know it is some type of immediate value.; /// Stores a single debug operand, which can either be a MachineOperand for; /// directly storing immediate values, or a ValueIDNum representing some value; /// computed at some point in the program. IsConst is used as a discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:135,Energy Efficiency,reduce,reduce,135,"/// An ID used in the DbgOpIDMap (below) to lookup a stored DbgOp. This is used; /// in place of actual DbgOps inside of a DbgValue to reduce its size, as; /// DbgValue is very frequently used and passed around, and the actual DbgOp is; /// over 8x larger than this class, due to storing a MachineOperand. This ID; /// should be equal for all equal DbgOps, and also encodes whether the mapped; /// DbgOp is a constant, meaning that for simple equality or const-ness checks; /// it is not necessary to lookup this ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:436,Usability,simpl,simple,436,"/// An ID used in the DbgOpIDMap (below) to lookup a stored DbgOp. This is used; /// in place of actual DbgOps inside of a DbgValue to reduce its size, as; /// DbgValue is very frequently used and passed around, and the actual DbgOp is; /// over 8x larger than this class, due to storing a MachineOperand. This ID; /// should be equal for all equal DbgOps, and also encodes whether the mapped; /// DbgOp is a constant, meaning that for simple equality or const-ness checks; /// it is not necessary to lookup this ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:50,Modifiability,variab,variable,50,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:93,Modifiability,variab,variable,93,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:375,Modifiability,variab,variable,375,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:396,Performance,perform,performing,396,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:69,Modifiability,variab,variable,69,"// Returns an array of all the machine values used to calculate this variable; // value, or an empty list for an Undef or unjoined VPHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:1476,Availability,mask,mask,1476,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:526,Modifiability,layers,layers,526,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:486,Safety,avoid,avoid,486,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:583,Safety,avoid,avoid,583,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:1575,Safety,avoid,avoid,1575,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:29,Availability,mask,masks,29,"/// When clobbering register masks, we chose to not believe the machine model; /// and don't clobber SP. Do the same for SP aliases, and for efficiency,; /// keep a set of them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Performance,Cache,Cached,4,/// Cached local copy of the number of registers the target has.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:27,Availability,mask,mask,27,/// Collection of register mask operands that have been observed. Second part; /// of pair indicates the instruction that they happened in. Used to; /// reconstruct where defs happened if we start tracking a location later; /// on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:195,Usability,Simpl,Simplifies,195,"/// Iterator for locations and the values they contain. Dereferencing; /// produces a struct/pair containing the LocIdx key for this location,; /// and a reference to the value currently stored. Simplifies the process; /// of seeking a particular location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:87,Safety,safe,safety,87,/// Produce location ID number for a Register. Provides some small amount of; /// type safety.; /// \param Reg The register we're looking up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Performance,Load,Load,4,/// Load values for each location from array of ValueIDNums. Take current; /// bbnum just in case we read a value from a hitherto untouched register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:43,Performance,load,load,43,"// Iterate over all tracked locations, and load each locations live-in; // value into our local index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:155,Availability,Mask,Masks,155,"// We could reset all the location values too; however either loadFromArray; // or setMPhis should be called before this object is re-used. Just; // clear Masks, they're definitely not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:62,Performance,load,loadFromArray,62,"// We could reset all the location values too; however either loadFromArray; // or setMPhis should be called before this object is re-used. Just; // clear Masks, they're definitely not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:149,Usability,clear,clear,149,"// We could reset all the location values too; however either loadFromArray; // or setMPhis should be called before this object is re-used. Just; // clear Masks, they're definitely not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Usability,Clear,Clear,4,"/// Clear all data. Destroys the LocID <=> LocIdx map, which makes most of; /// the information in this pass uninterpretable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:138,Availability,mask,mask,138,"/// Create a LocIdx for an untracked register ID. Initialize it to either an; /// mphi value representing a live-in, or a recent register mask clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:144,Usability,clear,clears,144,/// Reset a register value to zero / empty. Needed to replicate the; /// VarLoc implementation where a copy to/from a register effectively; /// clears the contents of the source register. (Values can only have one; /// machine location in VarLocBasedImpl).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:112,Availability,mask,mask,112,"/// Record a RegMask operand being executed. Defs any register we currently; /// track, stores a pointer to the mask in case we have to account for it; /// later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:116,Modifiability,variab,variable,116,"/// Create a DBG_VALUE based on debug operands \p DbgOps. Qualify it with the; /// information in \pProperties, for variable Var. Don't insert it anywhere,; /// just return the builder for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:176,Energy Efficiency,reduce,reduce,176,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:32,Modifiability,variab,variable,32,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:88,Modifiability,variab,variable,88,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:136,Modifiability,variab,variable,136,"/// Types for recording sets of variable fragments that overlap. For a given; /// local variable, we record all other fragments of that variable that could; /// overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:81,Modifiability,variab,variable,81,"/// Collection of DBG_VALUEs observed when traversing a block. Records each; /// variable and the value the DBG_VALUE refers to. Requires the machine value; /// location dataflow algorithm to have run already, so that values can be; /// identified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:237,Modifiability,variab,variable,237,"/// Map DebugVariable to the latest Value it's defined to have.; /// Needs to be a MapVector because we determine order-in-the-input-MIR from; /// the order in this container.; /// We only retain the last DbgValue in each block for each variable, to; /// determine the blocks live-out variable value. The Vars container forms the; /// transfer function for this block, as part of the dataflow analysis. The; /// movement of values between locations inside of a block is handled at a; /// much later stage, in the TransferTracker class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:285,Modifiability,variab,variable,285,"/// Map DebugVariable to the latest Value it's defined to have.; /// Needs to be a MapVector because we determine order-in-the-input-MIR from; /// the order in this container.; /// We only retain the last DbgValue in each block for each variable, to; /// determine the blocks live-out variable value. The Vars container forms the; /// transfer function for this block, as part of the dataflow analysis. The; /// movement of values between locations inside of a block is handled at a; /// much later stage, in the TransferTracker class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:39,Modifiability,variab,variable,39,// Otherwise: terminate any overlapped variable locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:34,Modifiability,variab,variable,34,/// Live in/out structure for the variable values: a per-block map of; /// variables to their values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:75,Modifiability,variab,variables,75,/// Live in/out structure for the variable values: a per-block map of; /// variables to their values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:109,Modifiability,variab,variable,109,/// Vector (per block) of a collection (inner smallvector) of live-ins.; /// Used as the result type for the variable value dataflow problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:35,Modifiability,variab,variables,35,/// Mapping from lexical scopes to variables in that scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:48,Modifiability,variab,variables,48,"/// Mapping from lexical scopes to blocks where variables in that scope are; /// assigned. Such blocks aren't necessarily ""in"" the lexical scope, it's; /// just a block where an assignment happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Modifiability,Variab,Variable,4,/// Variable tracker -- listens to DBG_VALUEs occurring as InstrRefBasedImpl; /// steps through a block. Reads the values at each location from the; /// MLocTracker object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:195,Deployability,Update,Updater,195,/// Map from instruction numbers defined by DBG_PHIs to a record of what that; /// DBG_PHI read and where. Populated and edited during the machine value; /// location problem -- we use LLVMs SSA Updater to fix changes by; /// optimizations that destroy PHI instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:226,Performance,optimiz,optimizations,226,/// Map from instruction numbers defined by DBG_PHIs to a record of what that; /// DBG_PHI read and where. Populated and edited during the machine value; /// location problem -- we use LLVMs SSA Updater to fix changes by; /// optimizations that destroy PHI instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:22,Modifiability,variab,variable,22,// Map of overlapping variable fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:121,Modifiability,variab,variable,121,"/// Mapping of DBG_INSTR_REF instructions to their values, for those; /// DBG_INSTR_REFs that call resolveDbgPHIs. These variable references solve; /// a mini SSA problem caused by DBG_PHIs being cloned, this collection caches; /// the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:220,Performance,cache,caches,220,"/// Mapping of DBG_INSTR_REF instructions to their values, for those; /// DBG_INSTR_REFs that call resolveDbgPHIs. These variable references solve; /// a mini SSA problem caused by DBG_PHIs being cloned, this collection caches; /// the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Testability,Test,Tests,4,/// Tests whether this instruction is a spill to a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:247,Performance,optimiz,optimization,247,/// Decide if @MI is a spill instruction and return true if it is. We use 2; /// criteria to make this decision:; /// - Is this instruction a store to a spill slot?; /// - Is there a register operand that is both used and killed?; /// TODO: Store optimization can fold spills into other stores (including; /// other spills). We do not handle this yet (more than one memory operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Deployability,Install,Install,4,"/// Install PHI values into the live-in array for each block, according to; /// the IDF of each register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:14,Modifiability,variab,variable,14,/// Propagate variable values to blocks in the common case where there's; /// only one value assigned to the variable. This function has better; /// performance as it doesn't have to find the dominance frontier between; /// different assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:109,Modifiability,variab,variable,109,/// Propagate variable values to blocks in the common case where there's; /// only one value assigned to the variable. This function has better; /// performance as it doesn't have to find the dominance frontier between; /// different assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:149,Performance,perform,performance,149,/// Propagate variable values to blocks in the common case where there's; /// only one value assigned to the variable. This function has better; /// performance as it doesn't have to find the dominance frontier between; /// different assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:158,Modifiability,variab,variable,158,"/// Calculate the iterated-dominance-frontier for a set of defs, using the; /// existing LLVM facilities for this. Works for a single ""value"" or; /// machine/variable location.; /// \p AllBlocks Set of blocks where we might consume the value.; /// \p DefBlocks Set of blocks where the value/location is defined.; /// \p PHIBlocks Output set of blocks where PHIs must be placed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:426,Availability,down,downgrade,426,"/// Perform a control flow join (lattice value meet) of the values in machine; /// locations at \p MBB. Follows the algorithm described in the file-comment,; /// reading live-outs of predecessors from \p OutLocs, the current live ins; /// from \p InLocs, and assigning the newly computed live ins back into; /// \p InLocs. \returns two bools -- the first indicates whether a change; /// was made, the second whether a lattice downgrade occurred. If the latter; /// is true, revisiting this block is necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Performance,Perform,Perform,4,"/// Perform a control flow join (lattice value meet) of the values in machine; /// locations at \p MBB. Follows the algorithm described in the file-comment,; /// reading live-outs of predecessors from \p OutLocs, the current live ins; /// from \p InLocs, and assigning the newly computed live ins back into; /// \p InLocs. \returns two bools -- the first indicates whether a change; /// was made, the second whether a lattice downgrade occurred. If the latter; /// is true, revisiting this block is necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:171,Modifiability,variab,variables,171,"/// Produce a set of blocks that are in the current lexical scope. This means; /// those blocks that contain instructions ""in"" the scope, blocks where; /// assignments to variables in scope occur, and artificial blocks that are; /// successors to any of the earlier blocks. See https://llvm.org/PR48091 for; /// more commentry on what ""in scope"" means.; /// \p DILoc A location in the scope that we're fetching blocks for.; /// \p Output Set to put in-scope-blocks into.; /// \p AssignBlocks Blocks known to contain assignments of variables in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:531,Modifiability,variab,variables,531,"/// Produce a set of blocks that are in the current lexical scope. This means; /// those blocks that contain instructions ""in"" the scope, blocks where; /// assignments to variables in scope occur, and artificial blocks that are; /// successors to any of the earlier blocks. See https://llvm.org/PR48091 for; /// more commentry on what ""in scope"" means.; /// \p DILoc A location in the scope that we're fetching blocks for.; /// \p Output Set to put in-scope-blocks into.; /// \p AssignBlocks Blocks known to contain assignments of variables in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:14,Modifiability,variab,variable,14,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:328,Modifiability,variab,variable,328,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:409,Modifiability,variab,variable,409,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:583,Modifiability,variab,variables,583,"/// Solve the variable value dataflow problem, for a single lexical scope.; /// Uses the algorithm from the file comment to resolve control flow joins; /// using PHI placement and value propagation. Reads the locations of machine; /// values from the \p MInLocs and \p MOutLocs arrays (see buildMLocValueMap); /// and reads the variable values transfer function from \p AllTheVlocs.; /// Live-in and Live-out variable values are stored locally, with the live-ins; /// permanently stored to \p Output once a fixedpoint is reached.; /// \p VarsWeCareAbout contains a collection of the variables in \p Scope; /// that we should be tracking.; /// \p AssignBlocks contains the set of blocks that aren't in \p DILoc's; /// scope, but which do contain DBG_VALUEs, which VarLocBasedImpl tracks; /// locations through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:76,Deployability,install,install,76,"/// Take collections of DBG_VALUE instructions stored in TTracker, and; /// install them into their output blocks. Preserves a stable order of; /// DBG_VALUEs produced (which would otherwise cause nondeterminism) through; /// the AllVarsNumbering order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:188,Deployability,install,install,188,"/// Produce a map of the last lexical scope that uses a block, using the; /// scopes DFSOut number. Mapping is block-number to DFSOut.; /// \p EjectionMap Pre-allocated vector in which to install the built ma.; /// \p ScopeToDILocation Mapping of LexicalScopes to their DILocations.; /// \p AssignBlocks Map of blocks where assignments happen for a scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:159,Energy Efficiency,allocate,allocated,159,"/// Produce a map of the last lexical scope that uses a block, using the; /// scopes DFSOut number. Mapping is block-number to DFSOut.; /// \p EjectionMap Pre-allocated vector in which to install the built ma.; /// \p ScopeToDILocation Mapping of LexicalScopes to their DILocations.; /// \p AssignBlocks Map of blocks where assignments happen for a scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:31,Modifiability,variab,variable,31,"/// When determining per-block variable values and emitting to DBG_VALUEs,; /// this function explores by lexical scope depth. Doing so means that per; /// block information can be fully computed before exploration finishes,; /// allowing us to emit it and free data structures earlier than otherwise.; /// It's also good for locality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:134,Modifiability,variab,variable,134,"// Instruction must have a memory operand that's a stack slot, and isn't; // aliased, meaning it's a spill from regalloc instead of a variable.; // If it's aliased, we can't guarantee its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:65,Modifiability,extend,extends,65,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:86,Modifiability,variab,variable,86,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:225,Modifiability,variab,variable,225,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:368,Modifiability,variab,variable,368,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:626,Modifiability,variab,variable,626,"/// \file LiveDebugValues.cpp; ///; /// The LiveDebugValues pass extends the range of variable locations; /// (specified by DBG_VALUE instructions) from single blocks to successors; /// and any other code locations where the variable location is valid.; /// There are currently two implementations: the ""VarLoc"" implementation; /// explicitly tracks the location of a variable, while the ""InstrRef""; /// implementation tracks the values defined by instructions through locations.; ///; /// This file implements neither; it merely registers the pass, allows the; /// user to pick which implementation will be used to propagate variable; /// locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:94,Performance,perform,perform,94,"/// Generic LiveDebugValues pass. Calls through to VarLocBasedLDV or; /// InstrRefBasedLDV to perform location propagation, via the LDVImpl; /// base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:135,Deployability,pipeline,pipeline,135,"// Except for Wasm, all targets should be only using physical register at this; // point. Wasm only use virtual registers throught its pipeline, but its; // virtual registers don't participate in this LiveDebugValues analysis; only; // its target indices do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h:43,Integrability,interface,interfaces,43,// Expose a base class for LiveDebugValues interfaces to inherit from. This; // allows the generic LiveDebugValues pass handles to call into the; // implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h:57,Modifiability,inherit,inherit,57,// Expose a base class for LiveDebugValues interfaces to inherit from. This; // allows the generic LiveDebugValues pass handles to call into the; // implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h:3,Security,Expose,Expose,3,// Expose a base class for LiveDebugValues interfaces to inherit from. This; // allows the generic LiveDebugValues pass handles to call into the; // implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:455,Availability,avail,available,455,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:794,Availability,avail,availability,794,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1168,Availability,avail,available,1168," Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1332,Availability,avail,available,1332,"mpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1532,Availability,avail,available,1532,"and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1661,Availability,avail,available,1661,"and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2037,Availability,avail,available,2037,"lues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; /// ┬ ""Unknown""; /// |; /// v; /// True; /// |; /// v; /// ⊥ False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2902,Availability,avail,available,2902,"eded when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; /// ┬ ""Unknown""; /// |; /// v; /// True; /// |; /// v; /// ⊥ False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable loca",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5239,Availability,down,down,5239,"at variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5504,Deployability,install,installs,5504,"r DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with its bit not set in predecessor InLocs or; /// OutLocs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:626,Modifiability,variab,variable,626,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:735,Modifiability,variab,variable,735,"//===- VarLocBasedImpl.cpp - Tracking Debug Value MIs with VarLoc class----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1127,Modifiability,extend,extend,1127," Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1134,Modifiability,variab,variable,1134," Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file VarLocBasedImpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1419,Modifiability,variab,variable,1419,"mpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1476,Modifiability,variab,variable,1476,"mpl.cpp; ///; /// LiveDebugValues is an optimistic ""available expressions"" dataflow; /// algorithm. The set of expressions is the set of machine locations; /// (registers, spill slots, constants, and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1602,Modifiability,variab,variable,1602,"and target indices) that a variable; /// fragment might be located, qualified by a DIExpression and indirect-ness; /// flag, while each variable is identified by a DebugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:1740,Modifiability,variab,variable,1740,"bugVariable object. The; /// availability of an expression begins when a DBG_VALUE instruction specifies; /// the location of a DebugVariable, and continues until that location is; /// clobbered or re-specified by a different DBG_VALUE for the same; /// DebugVariable.; ///; /// The output of LiveDebugValues is additional DBG_VALUE instructions,; /// placed to extend variable locations as far they're available. This file; /// and the VarLocBasedLDV class is an implementation that explicitly tracks; /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verba",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2172,Modifiability,variab,variable,2172," /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; /// ┬ ""Unknown""; /// |; /// v; /// True; /// |; /// v; /// ⊥ False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2487,Modifiability,variab,variable,2487,"pressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; /// ┬ ""Unknown""; /// |; /// v; /// True; /// |; /// v; /// ⊥ False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// funct",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:3851,Modifiability,variab,variable,3851,"ssion is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4201,Modifiability,variab,variable,4201,"zed to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4348,Modifiability,variab,variable,4348,"igns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4432,Modifiability,variab,variable,4432,"igns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5041,Modifiability,variab,variable,5041,". This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function can",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5203,Modifiability,Extend,ExtendRanges,5203,"at variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5382,Modifiability,variab,variable,5382,"ntifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:6179,Modifiability,variab,variable,6179,"r DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with its bit not set in predecessor InLocs or; /// OutLocs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2366,Performance,optimiz,optimization,2366," /// locations, using the VarLoc class.; ///; /// The canonical ""available expressions"" problem doesn't have expression; /// clobbering, instead when a variable is re-assigned, any expressions using; /// that variable get invalidated. LiveDebugValues can map onto ""available; /// expressions"" by having every register represented by a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; /// ┬ ""Unknown""; /// |; /// v; /// True; /// |; /// v; /// ⊥ False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5684,Safety,avoid,avoid,5684,"r DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with its bit not set in predecessor InLocs or; /// OutLocs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:2645,Testability,test,testing,2645," a variable, which is; /// used in an expression that becomes available at a DBG_VALUE instruction.; /// When the register is clobbered, its variable is effectively reassigned, and; /// expressions computed from it become unavailable. A similar construct is; /// needed when a DebugVariable has its location re-specified, to invalidate; /// all other locations for that DebugVariable.; ///; /// Using the dataflow analysis to compute the available expressions, we create; /// a DBG_VALUE at the beginning of each block where the expression is; /// live-in. This propagates variable locations into every basic block where; /// the location can be determined, rather than only having DBG_VALUEs in blocks; /// where locations are specified due to an assignment or some optimization.; /// Movements of values between registers and spill slots are annotated with; /// DBG_VALUEs too to track variable values bewteen locations. All this allows; /// DbgEntityHistoryCalculator to focus on only the locations within individual; /// blocks, facilitating testing and improving modularity.; ///; /// We follow an optimisic dataflow approach, with this lattice:; ///; /// \verbatim; /// ┬ ""Unknown""; /// |; /// v; /// True; /// |; /// v; /// ⊥ False; /// \endverbatim With ""True"" signifying that the expression is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:3793,Usability,Intuit,Intuitively,3793,"ssion is available (and; /// thus a DebugVariable's location is the corresponding register), while; /// ""False"" signifies that the expression is unavailable. ""Unknown""s never; /// survive to the end of the analysis (see below).; ///; /// Formally, all DebugVariable locations that are live-out of a block are; /// initialized to \top. A blocks live-in values take the meet of the lattice; /// value for every predecessors live-outs, except for the entry block, where; /// all live-ins are \bot. The usual dataflow propagation occurs: the transfer; /// function for a block assigns an expression for a DebugVariable to be ""True""; /// if a DBG_VALUE in the block specifies it; ""False"" if the location is; /// clobbered; or the live-in value if it is unaffected by the block. We; /// visit each block in reverse post order until a fixedpoint is reached. The; /// solution produced is maximal.; ///; /// Intuitively, we start by assuming that every expression / variable location; /// is at least ""True"", and then propagate ""False"" from the entry block and any; /// clobbers until there are no more changes to make. This gives us an accurate; /// solution because all incorrect locations will have a ""False"" propagated into; /// them. It also gives us a solution that copes well with loops by assuming; /// that variable locations are live-through every loop, and then removing those; /// that are not through dataflow.; ///; /// Within LiveDebugValues: each variable location is represented by a; /// VarLoc object that identifies the source variable, the set of; /// machine-locations that currently describe it (a single location for; /// DBG_VALUE or multiple for DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:100,Safety,avoid,avoid,100,"/// If \p Op is a stack or frame register return true, otherwise return false.; /// This is used to avoid basing the debug entry values on the registers, since; /// we do not support it at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:36,Energy Efficiency,allocate,allocated,36,"// Max out the number of statically allocated elements in DefinedRegsSet, as; // this prevents fallback to std::set::count() operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:116,Energy Efficiency,efficient,efficiently,116,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:200,Energy Efficiency,efficient,efficiently,200,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:465,Performance,perform,performance-critical,465,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:3,Usability,Simpl,Simple,3,// Simple Set for storing all the VarLoc Indices at a Location bucket.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:20,Modifiability,variab,variable,20,/// A pair of debug variable and value location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:35,Modifiability,variab,variable,35,// The location at which a spilled variable resides. It consists of a; // register and an offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:20,Modifiability,variab,variable,20,/// Identity of the variable at this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:45,Safety,avoid,avoid,45,/// The value location. Stored separately to avoid repeatedly; /// extracting it from MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:55,Modifiability,variab,variable,55,"/// The set of machine locations used to determine the variable's value, in; /// conjunction with Expr. Initially populated with MI's debug operands,; /// but may be transformed independently afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:209,Security,access,accessed,209,/// Used to map the index of each location in Locs back to the index of its; /// original debug operand in MI. Used when multiple location operands are; /// coalesced and the original MI's operands need to be accessed while; /// emitting a debug value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable and machine-location in DBG_VALUE MI, and build an; /// entry location using the given expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable and machine-location from the DBG_VALUE (from the; /// function entry), and build an entry value backup location. The backup; /// location will turn into the normal location if the backup is valid at; /// the time of the primary location clobbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable and machine-location from the DBG_VALUE (from the; /// function entry), and build a copy of an entry value backup location by; /// setting the register location to NewReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,"/// Take the variable described by DBG_VALUE* MI, and create a VarLoc; /// locating it in the specified spill location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:83,Modifiability,variab,variable-specific,83,"/// Create a DBG_VALUE representing this VarLoc in the given function.; /// Copies variable-specific information such as DILocalVariable and; /// inlining information from the original DBG_VALUE instruction, which may; /// have been several transfers ago.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:56,Deployability,update,updated,56,"// An entry value is a register location -- but with an updated; // expression. The register location of such DBG_VALUE is always the; // one from the entry DBG_VALUE, it does not matter if the entry value; // was copied in to another register due to some optimizations.; // Non-entry value register locations are like the source; // DBG_VALUE, but with the register number from this VarLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:256,Performance,optimiz,optimizations,256,"// An entry value is a register location -- but with an updated; // expression. The register location of such DBG_VALUE is always the; // one from the entry DBG_VALUE, it does not matter if the entry value; // was copied in to another register due to some optimizations.; // Non-entry value register locations are like the source; // DBG_VALUE, but with the register number from this VarLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described by register \p Reg holding the entry; /// value, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described by register \p Reg holding a copy of the; /// entry value, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p Reg, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p Reg, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by 1 or more registers,; /// add each of them to \p Regs and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p SpillLocation,; /// return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p SpillLocation,; /// return the index .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// If this variable is described in whole or part by \p WasmLocation,; /// return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:56,Modifiability,Variab,Variable,56,/// This operator guarantees that VarLocs are sorted by Variable first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:173,Energy Efficiency,reduce,reduce,173,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:31,Modifiability,variab,variable,31,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:86,Modifiability,variab,variable,86,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:134,Modifiability,variab,variable,134,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:372,Integrability,depend,depending,372,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:242,Modifiability,variab,variable,242,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:564,Performance,perform,perform,564,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:71,Security,access,access,71,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:4,Testability,Test,Tests,4,/// Tests whether this instruction is a spill to a stack location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:247,Performance,optimiz,optimization,247,/// Decide if @MI is a spill instruction and return true if it is. We use 2; /// criteria to make this decision:; /// - Is this instruction a store to a spill slot?; /// - Is there a register operand that is both used and killed?; /// TODO: Store optimization can fold spills into other stores (including; /// other spills). We do not handle this yet (more than one memory operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:28,Integrability,message,message,28,/// Print to ostream with a message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:12,Modifiability,variab,variable,12,"/// Erase a variable from the set of open ranges, and additionally erase any; /// fragments that may overlap it. If the VarLoc is a backup location, erase; /// the variable from the EntryValuesBackupVars set, indicating we should stop; /// tracking its backup entry location. Otherwise, if the VarLoc is primary; /// location, erase the variable from the Vars set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:164,Modifiability,variab,variable,164,"/// Erase a variable from the set of open ranges, and additionally erase any; /// fragments that may overlap it. If the VarLoc is a backup location, erase; /// the variable from the EntryValuesBackupVars set, indicating we should stop; /// tracking its backup entry location. Otherwise, if the VarLoc is primary; /// location, erase the variable from the Vars set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:337,Modifiability,variab,variable,337,"/// Erase a variable from the set of open ranges, and additionally erase any; /// fragments that may overlap it. If the VarLoc is a backup location, erase; /// the variable from the EntryValuesBackupVars set, indicating we should stop; /// tracking its backup entry location. Otherwise, if the VarLoc is primary; /// location, erase the variable from the Vars set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:13,Modifiability,variab,variable,13,// Erase the variable/fragment that ends here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:83,Modifiability,variab,variable,83,"/// Return the Loc ID of an entry value backup location, if it exists for the; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:331,Modifiability,variab,variable,331,"/// Create new TransferDebugPair and insert it in \p Transfers. The VarLoc; /// with \p OldVarID should be deleted form \p OpenRanges and replaced with; /// new VarLoc. If \p NewReg is different than default zero value then the; /// new location will be register location created by the copy like instruction,; /// otherwise it is variable's location on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:14,Modifiability,variab,variable,14,// Close this variable's previous location range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:64,Performance,perform,performance,64,"// Erase VarLocs which reside in one of the dead registers. For performance; // reasons, it's critical to not iterate over the full set of open VarLocs.; // Iterate over the set of dying/used regs instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:54,Availability,mask,masks,54,"// Remove ranges of all clobbered registers. Register masks don't usually; // list SP as preserved. Assume that call instructions never clobber SP,; // because some backends (e.g., AArch64) never list SP in the regmask.; // While the debug info may be off for an instruction or two around; // callee-cleanup calls, transferring the DEBUG_VALUE across the call is; // still a better user experience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:382,Usability,user experience,user experience,382,"// Remove ranges of all clobbered registers. Register masks don't usually; // list SP as preserved. Assume that call instructions never clobber SP,; // because some backends (e.g., AArch64) never list SP in the regmask.; // While the debug info may be off for an instruction or two around; // callee-cleanup calls, transferring the DEBUG_VALUE across the call is; // still a better user experience.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:58,Modifiability,variab,variable,58,"// Find the target indices killed by MI, and delete those variable locations; // from the open range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:172,Availability,down,down,172,// Check whether next instruction kills the spilled register.; // FIXME: Current solution does not cover search for killed register in; // bundles and instructions further down the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:84,Modifiability,variab,variable,84,"/// A spilled register may indicate that we have to end the current range of; /// a variable and create a new one for the spill location.; /// A restored register may indicate the reverse situation.; /// We don't want to insert any instructions in process(), so we just create; /// the DBG_VALUE without inserting it and keep track of it in \p Transfers.; /// It will be inserted into the BB when we're done iterating over the; /// instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:102,Modifiability,variab,variable,102,"// First, if there are any DBG_VALUEs pointing at a spill slot that is; // written to, then close the variable location. The value in memory; // will have changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:77,Modifiability,variab,variable,77,// Try to recognise spill and restore instructions that may create a new; // variable location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:132,Energy Efficiency,reduce,reduces,132,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed DEBUG_VALUE instruction to analyze for; /// fragment usage.; /// \param SeenFragments Map from DILocalVariable to all fragments of that; /// Variable which are known to exist.; /// \param OverlappingFragments The overlap map being constructed, from one; /// Var/Fragment pair to a vector of fragments known to overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:459,Modifiability,Variab,Variable,459,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed DEBUG_VALUE instruction to analyze for; /// fragment usage.; /// \param SeenFragments Map from DILocalVariable to all fragments of that; /// Variable which are known to exist.; /// \param OverlappingFragments The overlap map being constructed, from one; /// Var/Fragment pair to a vector of fragments known to overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:41,Modifiability,variab,variable,41,"// If this is the first sighting of this variable, then we are guaranteed; // there are currently no overlapping fragments either. Initialize the set; // of seen fragments, record no overlaps for the current one, and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:22,Modifiability,Variab,Variable,22,"// If this particular Variable/Fragment pair already exists in the overlap; // map, it has already been accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:56,Modifiability,variab,variable,56,"// Otherwise, examine all other seen fragments for this variable, with ""this""; // fragment being a previously unseen fragment. Record any pair of; // overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:9,Integrability,rout,routine,9,/// This routine creates OpenRanges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:9,Integrability,rout,routine,9,/// This routine joins the analysis results of all incoming edges in @MBB by; /// inserting a new DBG_VALUE instruction at the start of the @MBB - if the same; /// source variable in all the predecessors of @MBB reside in the same location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:171,Modifiability,variab,variable,171,/// This routine joins the analysis results of all incoming edges in @MBB by; /// inserting a new DBG_VALUE instruction at the start of the @MBB - if the same; /// source variable in all the predecessors of @MBB reside in the same location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:31,Modifiability,variab,variables,31,// TODO: Add support for local variables that are expressed in terms of; // parameters entry values.; // TODO: Add support for modified arguments that can be expressed; // by using its entry value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:107,Usability,simpl,simple,107,// TODO: Add support for parameters that have a pre-existing debug expressions; // (e.g. fragments).; // A simple deref expression is equivalent to an indirect debug value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:9,Integrability,rout,routine,9,"/// This routine records the entry values of function parameters. The values; /// could be used as backup values. If we loose the track of some unmodified; /// parameters, the backup values will be used as a primary locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:79,Modifiability,extend,extend,79,/// Calculate the liveness information for the given machine function and; /// extend ranges across basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:22,Modifiability,variab,variable,22,// Map of overlapping variable fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:88,Performance,perform,perform,88,"// This is a standard ""union of predecessor outs"" dataflow problem.; // To solve it, we perform join() and process() using the two worklist method; // until the ranges converge.; // Ranges have converged when both worklists are empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:132,Performance,queue,queue,132,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but this; // is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:47,Safety,avoid,avoid,47,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but this; // is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:98,Safety,avoid,avoid,98,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but this; // is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:31,Modifiability,extend,extend,31,"// Now that we have started to extend ranges across BBs we need to; // examine spill, copy and restore instructions to see whether they; // operate with registers that correspond to user variables.; // First load any pending inlocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:187,Modifiability,variab,variables,187,"// Now that we have started to extend ranges across BBs we need to; // examine spill, copy and restore instructions to see whether they; // operate with registers that correspond to user variables.; // First load any pending inlocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:208,Performance,load,load,208,"// Now that we have started to extend ranges across BBs we need to; // examine spill, copy and restore instructions to see whether they; // operate with registers that correspond to user variables.; // First load any pending inlocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp:58,Deployability,update,updated,58,/// Skip the leading whitespace characters and return the updated cursor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp:39,Deployability,update,updated,39,/// Skip a line comment and return the updated cursor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp:9,Usability,simpl,simple,9,// Try a simple unquoted name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper struct around the 'MachineOperand' struct that includes a source; /// range and other attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,Availability,error,error,14,/// Report an error at the current location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:59,Integrability,message,message,59,/// Report an error at the current location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,Availability,error,error,14,/// Report an error at the given location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:57,Integrability,message,message,57,/// Report an error at the given location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:107,Availability,error,error,107,/// Convert the integer literal in the current token into an unsigned integer.; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:97,Availability,error,error,97,/// Convert the integer literal in the current token into an uint64.; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:101,Availability,error,error,101,"/// If the current token is of the given kind, consume it and return false.; /// Otherwise report an error and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error when multiple same attributes are specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error when both name and ir block are specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,Availability,mask,mask,14,// Parse lane mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:102,Availability,mask,mask,102,// We can't verify call instructions as they can contain arbitrary implicit; // register and register mask operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:9,Availability,redundant,redundant,9,// Try a redundant low-level type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:9,Safety,redund,redundant,9,// Try a redundant low-level type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error if the same register is used more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error if the same register is used more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error when using a duplicate bit target flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:43,Performance,load,load,43,// Optional 'store' for operands that both load and store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:12,Integrability,synchroniz,synchronization,12,// Optional synchronization scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:62,Availability,failure,failure,62,// Up to two atomic orderings (cmpxchg provides guarantees on failure).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,Availability,error,error,19,// TODO: Report an error on duplicate metadata nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:294,Testability,test,test,294,"// FIXME: Currently we can't recognize temporary or local symbols and call all; // of the appropriate forms to create them. However, this handles basic cases; // well as most of the special aspects are recognized by a prefix on their; // name, and the input names should already be unique. For test cases, keeping; // the symbol name out of the symbol table isn't terribly important.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:14,Availability,error,error,14,/// Report an error with the given message at unknown location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:35,Integrability,message,message,35,/// Report an error with the given message at unknown location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:14,Availability,error,error,14,/// Report an error with the given message at the given location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:35,Integrability,message,message,35,/// Report an error with the given message at the given location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:19,Availability,error,error,19,/// Report a given error with the location translated from the location in an; /// embedded string literal to a location in the MIR file.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:118,Availability,error,error,118,/// Try to parse the optional LLVM module and the machine functions in the MIR; /// file.; ///; /// Return null if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:94,Availability,error,error,94,/// Parse the machine function in the current YAML document.; ///; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:113,Availability,error,error,113,/// Initialize the machine function to the state that's described in the MIR; /// file.; ///; /// Return true if error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:3,Performance,Load,Load,3,// Load any substitutions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:3,Safety,Avoid,Avoid,3,// Avoid clearing state if we're using the same subtarget again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:9,Usability,clear,clearing,9,// Avoid clearing state if we're using the same subtarget again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:124,Integrability,depend,depend,124,"// Note this is called after the initial constructor of the; // MachineFunctionInfo based on the MachineFunction, which may depend on the; // IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:64,Availability,error,error,64,/// Verify that given node is of a certain type. Return true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:33,Availability,error,error,33,// Translate the location of the error from the location in the MI string to; // the corresponding location in the MIR file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:33,Availability,error,error,33,// Translate the location of the error from the location in the llvm IR string; // to the corresponding location in the MIR file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:696,Security,expose,exposed,696,"//===- DAGCombiner.cpp - Implement a DAG node combiner --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines dag nodes to form fewer, simpler DAG nodes. It can be run; // both before and after the DAG is legalized.; //; // This pass is not a substitute for the LLVM IR instcombine pass. This pass is; // primarily intended to handle simplification opportunities that are implicit; // in the LLVM IR and exposed by the various codegen lowering phases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:427,Usability,simpl,simpler,427,"//===- DAGCombiner.cpp - Implement a DAG node combiner --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines dag nodes to form fewer, simpler DAG nodes. It can be run; // both before and after the DAG is legalized.; //; // This pass is not a substitute for the LLVM IR instcombine pass. This pass is; // primarily intended to handle simplification opportunities that are implicit; // in the LLVM IR and exposed by the various codegen lowering phases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:626,Usability,simpl,simplification,626,"//===- DAGCombiner.cpp - Implement a DAG node combiner --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines dag nodes to form fewer, simpler DAG nodes. It can be run; // both before and after the DAG is legalized.; //; // This pass is not a substitute for the LLVM IR instcombine pass. This pass is; // primarily intended to handle simplification opportunities that are implicit; // in the LLVM IR and exposed by the various codegen lowering phases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,load,33,"/// Hidden option to stress test load slicing, i.e., when this option; /// is enabled, load slicing bypasses most of its profitability guards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,Performance,load,load,87,"/// Hidden option to stress test load slicing, i.e., when this option; /// is enabled, load slicing bypasses most of its profitability guards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Testability,test,test,28,"/// Hidden option to stress test load slicing, i.e., when this option; /// is enabled, load slicing bypasses most of its profitability guards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Usability,simpl,simplified,49,/// Worklist of all of the nodes that need to be simplified.; ///; /// This must behave as a stack -- new nodes to process are pushed onto the; /// back and when processing we pop off of the back.; ///; /// The worklist will not contain duplicates but may contain null entries; /// due to nodes being deleted from the underlying DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,Availability,reliab,reliably,97,/// Set of nodes which have been combined (at least once).; ///; /// This is used to allow us to reliably add any operands of a DAG node; /// which have not yet been combined to the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Integrability,depend,dependence,182,"/// Map from candidate StoreNode to the pair of RootNode and count.; /// The count is used to track how many times we have seen the StoreNode; /// with the same RootNode bail out in dependence check. If we have seen; /// the bail out for the same pair many times over a limit, we won't; /// consider the StoreNode with the same RootNode as store merging; /// candidate again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,// AA - Used for DAG load/store alias analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Usability,simpl,simplified,27,"/// When an instruction is simplified, add all users of the instruction to; /// the work lists because they might get more simplified now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,Usability,simpl,simplified,123,"/// When an instruction is simplified, add all users of the instruction to; /// the work lists because they might get more simplified now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Integrability,rout,routine,27,/// Call the node-specific routine that folds each particular type of node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:85,Performance,scalab,scalable,85,"// We use the minimum store size here, since that's all we can guarantee; // for the scalable vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Safety,avoid,avoid,73,// Not in the worklist.; // Null out the entry rather than erasing it to avoid a linear operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Usability,simpl,simplified,63,"/// Check the specified integer node value to see if it can be simplified or; /// if things it uses can be simplified by bit propagation.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Usability,simpl,simplified,107,"/// Check the specified integer node value to see if it can be simplified or; /// if things it uses can be simplified by bit propagation.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Usability,simpl,simplified,62,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the; /// elements. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:106,Usability,simpl,simplified,106,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the; /// elements. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Usability,simpl,simplified,43,// TODO: For now just pretend it cannot be simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:80,Performance,load,load,80,"// Looks up the chain to find a unique (unaliased) store feeding the passed; // load. If no such store is found, returns a nullptr.; // Note: This will look past a CALLSEQ_START if the load is chained to it so; // so that it can find stack stores for byval params.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:185,Performance,load,load,185,"// Looks up the chain to find a unique (unaliased) store feeding the passed; // load. If no such store is found, returns a nullptr.; // Note: This will look past a CALLSEQ_START if the load is chained to it so; // so that it can find stack stores for byval params.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:375,Availability,failure,failure,375,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:70,Performance,load,load,70,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:262,Performance,load,load,262,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:293,Performance,load,load,293,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Integrability,rout,routine,27,"/// Call the node-specific routine that knows how to fold each; /// particular type of node. If that doesn't do anything, try the; /// target-specific DAG combines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Modifiability,extend,extended,189,/// This is a helper function for visitAND and visitZERO_EXTEND. Returns; /// true if the (and (load x) c) pattern matches an extload. ExtVT returns; /// the type of the loaded value to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Performance,load,load,96,/// This is a helper function for visitAND and visitZERO_EXTEND. Returns; /// true if the (and (load x) c) pattern matches an extload. ExtVT returns; /// the type of the loaded value to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:170,Performance,load,loaded,170,/// This is a helper function for visitAND and visitZERO_EXTEND. Returns; /// true if the (and (load x) c) pattern matches an extload. ExtVT returns; /// the type of the loaded value to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Energy Efficiency,reduce,reduced,86,/// Helper function to calculate whether the given Load/Store can have its; /// width reduced to ExtVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Performance,Load,Load,51,/// Helper function to calculate whether the given Load/Store can have its; /// width reduced to ExtVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Performance,load,loads,52,/// Used by BackwardsPropagateMask to find suitable loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Performance,load,load,50,/// Attempt to propagate a given AND node back to load leaves so that they; /// can be combined into narrow loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Performance,load,loads,108,/// Attempt to propagate a given AND node back to load leaves so that they; /// can be combined into narrow loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,Integrability,depend,dependency,94,/// Helper function for mergeConsecutiveStores. Checks if candidate stores; /// have indirect dependency through their operands. RootNode is the; /// predecessor to all stores calculated by getStoreMergeCandidates and is; /// used to prune the dependency check. \return True if safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:244,Integrability,depend,dependency,244,/// Helper function for mergeConsecutiveStores. Checks if candidate stores; /// have indirect dependency through their operands. RootNode is the; /// predecessor to all stores calculated by getStoreMergeCandidates and is; /// used to prune the dependency check. \return True if safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:278,Safety,safe,safe,278,/// Helper function for mergeConsecutiveStores. Checks if candidate stores; /// have indirect dependency through their operands. RootNode is the; /// predecessor to all stores calculated by getStoreMergeCandidates and is; /// used to prune the dependency check. \return True if safe to merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:121,Performance,load,loaded,121,/// This is a helper function for mergeConsecutiveStores. It is used for; /// store chains that are composed entirely of loaded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:68,Performance,optimiz,optimization,68,/// Merge consecutive store operations into a wide store.; /// This optimization uses wide integers or vectors when possible.; /// \return true if stores were merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Integrability,wrap,wrapper,16,/// Convenience wrapper around TargetLowering::getSetCCResultType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Availability,mask,mask,17,// Make sure the mask of OpVal is true mask or is same as Root's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Availability,mask,mask,39,// Make sure the mask of OpVal is true mask or is same as Root's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Availability,Mask,MaskOp,77,"// Specialize based on number of operands.; // TODO emit VP intrinsics where MaskOp/VectorLenOp != null; // SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT) { return; // DAG.getNode(Opcode, DL, VT); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:165,Performance,load,load,165,"// For an operand generating multiple values, one of the values may; // become dead allowing further simplification (e.g. split index; // arithmetic from an indexed load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:101,Usability,simpl,simplification,101,"// For an operand generating multiple values, one of the values may; // become dead allowing further simplification (e.g. split index; // arithmetic from an indexed load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Modifiability,extend,extends,83,"// APInts must be the same size for most operations, this helper; // function zero extends the shorter of the pair so that they match.; // We provide an Offset so that we can create bitwidths that won't overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:295,Usability,simpl,simplifies,295,"// Return true if this node is a setcc, or is a select_cc; // that selects between the target values used for true and false, making it; // equivalent to a setcc. Also, set the incoming LHS, RHS, and CC references to; // the appropriate nodes based on the type of node we are checking. This; // simplifies life a bit for the callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Performance,load,load,32,// Determine if this an indexed load with an opaque target constant index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:226,Performance,load,load,226,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:280,Performance,load,load,280,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:324,Performance,load,load,324,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:372,Performance,load,load,372,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Usability,undo,undo,48,"// Currently this only tries to ensure we don't undo the GEP splits done by; // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,; // we check if the following transformation would be problematic:; // (load/store (add, (add, x, offset1), offset2)) ->; // (load/store (add, x, offset1+offset2)).; // (load/store (add, (add, x, y), offset2)) ->; // (load/store (add, (add, x, offset2), y)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:181,Performance,load,load,181,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Testability,test,test,116,// Is x[offset2] already not a legal addressing mode? If so then; // reassociating the constants breaks nothing (we test offset2 because; // that's the one we hope to fold into the load or store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Testability,log,logic,30,// Check for repeated operand logic simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Usability,simpl,simplifications,36,// Check for repeated operand logic simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,Safety,avoid,avoid,75,"// if Op (Op N00, N1), N01 already exist; // we need to stop reassciate to avoid dead loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,Safety,avoid,avoid,75,"// if Op (Op N01, N1), N00 already exist; // we need to stop reassciate to avoid dead loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,Performance,optimiz,optimizations,277,"// Reassociate the operands from (OR/AND (OR/AND(N00, N001)), N1) to (OR/AND; // (OR/AND(N00, N1)), N01) when N00 and N1 are comparisons with the same; // predicate or to (OR/AND (OR/AND(N1, N01)), N00) when N01 and N1 are; // comparisons with the same predicate. This enables optimizations as the; // following one:; // CMP(A,C)||CMP(B,C) => CMP(MIN/MAX(A,B), C); // CMP(A,C)&&CMP(B,C) => CMP(MIN/MAX(A,B), C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Usability,simpl,simplified,131,"// Finally, if the node is now dead, remove it from the graph. The node; // may not be dead if the replacement process recursively simplified to; // something else needing this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Usability,simpl,simplified,63,"/// Check the specified integer node value to see if it can be simplified or if; /// things it uses can be simplified by bit propagation. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Usability,simpl,simplified,107,"/// Check the specified integer node value to see if it can be simplified or if; /// things it uses can be simplified by bit propagation. If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Usability,simpl,simplified,62,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the elements.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:106,Usability,simpl,simplified,106,"/// Check the specified vector node value to see if it can be simplified or; /// if things it uses can be simplified as it only uses some of the elements.; /// If so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:295,Performance,load,load,295,"// We are always replacing N0/N1's use in N and only need additional; // replacements if there are additional uses.; // Note: We are checking uses of the *nodes* (SDNode) rather than values; // (SDValue) here because the node may reference multiple values; // (for example, the chain value of a load node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,Integrability,rout,routines,57,"// set the instance variables, so that the various visit routines may use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Modifiability,variab,variables,20,"// set the instance variables, so that the various visit routines may use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:156,Energy Efficiency,reduce,reduced,156,"// If N has no uses, it is dead. Make sure to revisit all N's operands once; // N is deleted from the DAG, since they too may now be dead or may have a; // reduced number of uses, allowing other xforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:134,Performance,optimiz,optimized,134,"// Push the new node and any users onto the worklist. Omit this if the; // new node is the EntryToken (e.g. if a store managed to get optimized; // out), because re-visiting the EntryToken and its users will not uncover; // any additional opportunities, but there may be a large number of such; // users, potentially causing compile time explosion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Usability,simpl,simplified,131,"// Finally, if the node is now dead, remove it from the graph. The node; // may not be dead if the replacement process recursively simplified to; // something else needing this node. This will also take care of adding any; // operands which have lost a user to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Deployability,update,update,49,"// If the root changed (e.g. it was a dead load, update the root).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Performance,load,load,43,"// If the root changed (e.g. it was a dead load, update the root).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Security,Expose,Expose,3,// Expose the DAG combiner to the target combiner impls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Availability,redundant,redundant,100,"// If N has two operands, where one has an input chain equal to the other,; // the 'other' chain is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Safety,redund,redundant,100,"// If N has two operands, where one has an input chain equal to the other,; // the 'other' chain is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Usability,simpl,simplify,9,// Don't simplify token factors if optnone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Usability,simpl,simplify,9,// Don't simplify the token factor if the node itself has too many operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:148,Performance,optimiz,optimizations,148,"// If the sole user is a token factor, we should make sure we have a; // chance to merge them together. This prevents TF chains from inhibiting; // optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Safety,avoid,avoid,39,"// Limit number of nodes to inline, to avoid quadratic compile times.; // We have to add the outstanding Token Factors to Ops, otherwise we might; // drop Ops from the resulting Token Factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Availability,redundant,redundant,65,// Entry tokens don't need to be added to the list. They are; // redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Safety,redund,redundant,65,// Entry tokens don't need to be added to the list. They are; // redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Queue,Queue,3,// Queue up for processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Safety,safe,safely,182,"// Replacing results may cause a different MERGE_VALUES to suddenly; // be CSE'd with N, and carry its uses with it. Iterate until no; // uses remain, to ensure that the node can be safely deleted.; // First add the users of this node to the work list so that they; // can be tried again once they have new operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Safety,avoid,avoid,33,// Do as a single replacement to avoid rewalking use lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:200,Safety,avoid,avoid,200,"// isTruncateOf - If N is a truncate of some other value, return true, record; // the value being truncated in Op and which of Op's bits are zero/one in Known.; // This function computes KnownBits to avoid a duplicated call to; // computeKnownBits in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,load,load,30,/// Return true if 'Use' is a load or a store that uses N as its base pointer; /// and that N may be folded in the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:115,Performance,load,load,115,/// Return true if 'Use' is a load or a store that uses N as its base pointer; /// and that N may be folded in the load / store addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:234,Availability,mask,masked,234,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Modifiability,variab,variable,58,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:144,Modifiability,variab,variable,144,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,Performance,load,load,178,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Safety,safe,safe,59,"// This transform increases uses of N0, so freeze it to be safe.; // binop N0, (vselect Cond, IDC, FVal) --> vselect Cond, N0, (binop N0, FVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Testability,log,logical,78,"// We need a constant operand for the add/sub, and the other operand is a; // logical shift right: add (srl), C or sub C, (srl).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:221,Performance,optimiz,optimization,221,"// Reassociate (add (or x, c), y) -> (add add(x, y), c)) if (or x, c) is; // equivalent to (add x, c).; // Reassociate (add (xor x, c), y) -> (add add(x, y), c)) if (xor x, c) is; // equivalent to (add x, c).; // Do this optimization only when adding c does not introduce instructions; // for adding carries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Availability,mask,mask,44,"// If N0's type does not split or is a sign mask, it does not introduce; // add carry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Integrability,wrap,wrap,51,// Limit this to after legalization if the add has wrap flags,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Availability,mask,masked,20,"// If the result is masked, then no matter what kind of bool it is we can; // return. If it isn't, then we need to make sure the bool type is either 0 or; // 1 and not other values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Availability,mask,masked,81,"/// Given the operands of an add/sub operation, see if the 2nd operand is a; /// masked 0/1 whose source operand is actually known to be 0/-1. If so, invert; /// the opcode and bypass the mask operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:188,Availability,mask,mask,188,"/// Given the operands of an add/sub operation, see if the 2nd operand is a; /// masked 0/1 whose source operand is actually known to be 0/-1. If so, invert; /// the opcode and bypass the mask operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Testability,Assert,AssertSext,17,"// add N0, (and (AssertSext X, i1), 1) --> sub N0, X; // sub N0, (and (AssertSext X, i1), 1) --> add N0, X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:71,Testability,Assert,AssertSext,71,"// add N0, (and (AssertSext X, i1), 1) --> sub N0, X; // sub N0, (and (AssertSext X, i1), 1) --> add N0, X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Integrability,wrap,wrap,51,// Limit this to after legalization if the add has wrap flags,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Safety,avoid,avoid,14,"// We want to avoid useless duplication.; // TODO: This is done automatically for binary operations. As UADDO_CARRY is; // not a binary operation, this is not really possible to leverage this; // existing mechanism for it. However, if more operations require the same; // deduplication logic, then it may be worth generalize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:286,Testability,log,logic,286,"// We want to avoid useless duplication.; // TODO: This is done automatically for binary operations. As UADDO_CARRY is; // not a binary operation, this is not really possible to leverage this; // existing mechanism for it. However, if more operations require the same; // deduplication logic, then it may be worth generalize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:317,Performance,optimiz,optimize,317,"/**; * If we are facing some sort of diamond carry propapagtion pattern try to; * break it up to generate something like:; * (uaddo_carry X, 0, (uaddo_carry A, B, Z):Carry); *; * The end result is usually an increase in operation required, but because the; * carry is now linearized, other transforms can kick in and optimize the DAG.; *; * Patterns typically look something like; * (uaddo A, B); * / \; * Carry Sum; * | \; * | (uaddo_carry *, 0, Z); * | /; * \ Carry; * | /; * (uaddo_carry X, *, *); *; * But numerous variation exist. Our goal is to identify A, B, X and Z and; * produce a combine with a single path for carry propagation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:196,Integrability,depend,dependency,196,"// Iff the flag result is dead:; // (uaddo_carry (add|uaddo X, Y), 0, Carry) -> (uaddo_carry X, Y, Carry); // Don't do this if the Carry comes from the uaddo. It won't remove the uaddo; // or the dependency between the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,perform,performing,58,"// Attempt to create a USUBSAT(LHS, RHS) node with DstVT, performing a; // clamp/truncation if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Modifiability,extend,extended,22,// If the LHS is zero-extended then we can perform the USUBSAT as DstVT by; // clamping RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Performance,perform,perform,43,// If the LHS is zero-extended then we can perform the USUBSAT as DstVT by; // clamping RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Modifiability,Refactor,Refactor,35,"// fold (sub x, x) -> 0; // FIXME: Refactor this and xor and other similar operations together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:110,Testability,log,logical,110,// Right-shifting everything out but the sign bit followed by negation is; // the same as flipping arithmetic/logical shift type without the negation:; // -(X >>u 31) -> (X >>s 31); // -(X >>s 31) -> (X >>u 31),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Energy Efficiency,power,power-of-,42,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:307,Energy Efficiency,reduce,reduces,307,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:353,Energy Efficiency,power,power-of-,353,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:368,Energy Efficiency,power,power-of-,368,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Availability,mask,mask,73,"// Fold ((mul x, 0/undef) -> 0,; // (mul x, 1) -> x) -> x); // -> and(x, mask); // We can replace vectors with '0' and '1' factors with a clearing mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Availability,mask,mask,147,"// Fold ((mul x, 0/undef) -> 0,; // (mul x, 1) -> x) -> x); // -> and(x, mask); // We can replace vectors with '0' and '1' factors with a clearing mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Usability,clear,clearing,138,"// Fold ((mul x, 0/undef) -> 0,; // (mul x, 1) -> x) -> x); // -> and(x, mask); // We can replace vectors with '0' and '1' factors with a clearing mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,avail,available,37,/// Return true if divmod libcall is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Availability,avail,available,82,"// If DIVREM is going to get expanded into a libcall,; // but there is no libcall available, then don't combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:204,Modifiability,extend,extending,204,"// X / 1 -> X; // X % 1 -> 0; // If this is a boolean op (single-bit element type), we can't have; // division-by-zero or remainder-by-zero, so assume the divisor is 1.; // TODO: Similarly, if we're zero-extending a boolean divisor, then assume; // it's a 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Energy Efficiency,reduce,reduce,64,"// If we know the sign bits of both operands are zero, strength reduce to a; // udiv instead. Handles (X&15) /s 4 -> X&15 >> 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Deployability,update,update,47,"// If the corresponding remainder node exists, update its users with; // (Dividend - (Quotient * Divisor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:152,Testability,log,logic,152,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Usability,simpl,simplification,137,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Energy Efficiency,power,power-,47,// Helper for determining whether a value is a power-2 constant scalar or a; // vector of such elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:235,Energy Efficiency,efficient,efficiently,235,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Usability,simpl,simple,26,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:199,Usability,learn,learn,199,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Deployability,update,update,47,"// If the corresponding remainder node exists, update its users with; // (Dividend - (Quotient * Divisor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:152,Testability,log,logic,152,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Usability,simpl,simplification,137,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Energy Efficiency,power,power,59,"// fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,Safety,avoid,avoid,76,"// fold (urem X, -1) -> select(FX == -1, 0, FX); // Freeze the numerator to avoid a miscompile with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Energy Efficiency,reduce,reduce,64,"// If we know the sign bits of both operands are zero, strength reduce to a; // urem instead. Handles (X & 0x0FFFFFFF) %s 16 -> X&15",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:153,Safety,avoid,avoid,153,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Testability,log,logic,56,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,simpl,simplified,17,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,Usability,simpl,simplification,277,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:435,Usability,simpl,simplification,435,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Deployability,update,update,43,"// If the equivalent Div node also exists, update its users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.; // We don't have demanded bits support for MULHU so this just enables constant; // folding based on known bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:4,Performance,Perform,Perform,4,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Performance,optimiz,optimizations,12,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,Performance,perform,performed,143,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:176,Usability,simpl,simplification,176,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Usability,simpl,simplified,38,"// If the two computed results can be simplified separately, separate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:407,Usability,Simpl,SimplifySelectCC,407,"// Function to calculate whether the Min/Max pair of SDNodes (potentially; // swapped around) make a signed saturate pattern, clamping to between a signed; // saturate of -2^(BW-1) and 2^(BW-1)-1, or an unsigned saturate of 0 and 2^BW.; // Returns the node being clamped and the bitwidth of the clamp in BW. Should; // work with both SMIN/SMAX nodes and setcc/select combo. The operands are the; // same as SimplifySelectCC. N0<N1 ? N2 : N3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Testability,log,logic,25,"/// If this is a bitwise logic instruction and both operands have the same; /// opcode, try to sink the other opcode after the logic instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:127,Testability,log,logic,127,"/// If this is a bitwise logic instruction and both operands have the same; /// opcode, try to sink the other opcode after the logic instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,// Avoid infinite looping with PromoteIntBinOp.; // TODO: Should we apply desirable/legal constraints to all opcodes?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,Testability,log,logic,117,"// Be extra careful sinking truncate. If it's free, there's no benefit in; // widening a binop. Also, don't create a logic op on an illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Performance,perform,perform,78,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Performance,optimiz,optimization,91,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:306,Usability,undo,undo,306,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:177,Availability,mask,mask,177,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:618,Availability,mask,mask,618,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:342,Performance,load,loading,342,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:437,Performance,optimiz,optimizations,437,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:565,Performance,perform,perform,565,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Usability,Simpl,Simplify,83,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Availability,mask,mask,41,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Availability,mask,masks,51,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,Safety,avoid,avoid,190,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,Energy Efficiency,efficient,efficient,61,"/// Try to make (and/or setcc (LL, LR), setcc (RL, RR)) more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Testability,log,logic,42,"// If we're here post-legalization or the logic op type is not i1, the logic; // op type must match a setcc result type. Also, all folds require new; // operations on the left and right operands, so those types must match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:71,Testability,log,logic,71,"// If we're here post-legalization or the logic op type is not i1, the logic; // op type must match a setcc result type. Also, all folds require new; // operations on the left and right operands, so those types must match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Usability,clear,clear,12,// All bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,clear,clear,17,// All sign bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Usability,clear,clear,12,// Any bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,clear,clear,17,// Any sign bits clear?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Modifiability,variab,variable,18,// Match a shared variable operand and 2 non-opaque constant operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Performance,optimiz,optimization,7,"// The optimization cannot be applied for all the predicates because; // of the way FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle; // NaNs. For FMINNUM_IEEE/FMAXNUM_IEEE, the optimization cannot be; // applied at all if one of the operands is a signaling NaN.; // It is safe to use FMINNUM_IEEE/FMAXNUM_IEEE if all the operands; // are non NaN values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Performance,optimiz,optimization,182,"// The optimization cannot be applied for all the predicates because; // of the way FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle; // NaNs. For FMINNUM_IEEE/FMAXNUM_IEEE, the optimization cannot be; // applied at all if one of the operands is a signaling NaN.; // It is safe to use FMINNUM_IEEE/FMAXNUM_IEEE if all the operands; // are non NaN values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,Safety,safe,safe,277,"// The optimization cannot be applied for all the predicates because; // of the way FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle; // NaNs. For FMINNUM_IEEE/FMAXNUM_IEEE, the optimization cannot be; // applied at all if one of the operands is a signaling NaN.; // It is safe to use FMINNUM_IEEE/FMAXNUM_IEEE if all the operands; // are non NaN values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:246,Performance,optimiz,optimization,246,"// Both FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle quiet; // NaNs in the same way. But, FMINNUM/FMAXNUM and FMINNUM_IEEE/; // FMAXNUM_IEEE handle signaling NaNs differently. If we cannot prove; // that there are not any sNaNs, then the optimization is not valid; // for FMINNUM_IEEE/FMAXNUM_IEEE. In the presence of sNaNs, we apply; // the optimization using FMINNUM/FMAXNUM for the following cases. If; // we can prove that we do not have any sNaNs, then we can do the; // optimization using FMINNUM_IEEE/FMAXNUM_IEEE for the following; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:350,Performance,optimiz,optimization,350,"// Both FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle quiet; // NaNs in the same way. But, FMINNUM/FMAXNUM and FMINNUM_IEEE/; // FMAXNUM_IEEE handle signaling NaNs differently. If we cannot prove; // that there are not any sNaNs, then the optimization is not valid; // for FMINNUM_IEEE/FMAXNUM_IEEE. In the presence of sNaNs, we apply; // the optimization using FMINNUM/FMAXNUM for the following cases. If; // we can prove that we do not have any sNaNs, then we can do the; // optimization using FMINNUM_IEEE/FMAXNUM_IEEE for the following; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:484,Performance,optimiz,optimization,484,"// Both FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle quiet; // NaNs in the same way. But, FMINNUM/FMAXNUM and FMINNUM_IEEE/; // FMAXNUM_IEEE handle signaling NaNs differently. If we cannot prove; // that there are not any sNaNs, then the optimization is not valid; // for FMINNUM_IEEE/FMAXNUM_IEEE. In the presence of sNaNs, we apply; // the optimization using FMINNUM/FMAXNUM for the following cases. If; // we can prove that we do not have any sNaNs, then we can do the; // optimization using FMINNUM_IEEE/FMAXNUM_IEEE for the following; // cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:466,Performance,optimiz,optimization,466,"// Check if the operands of an and/or operation are comparisons and if they; // compare against the same value. Replace the and/or-cmp-cmp sequence with; // min/max cmp sequence. If LHS1 is equal to RHS1, then the or-cmp-cmp; // sequence will be replaced with min-cmp sequence:; // (LHS0 < LHS1) | (RHS0 < RHS1) -> min(LHS0, RHS0) < LHS1; // and and-cmp-cmp will be replaced with max-cmp sequence:; // (LHS0 < LHS1) & (RHS0 < RHS1) -> max(LHS0, RHS0) < LHS1; // The optimization does not work for `==` or `!=` .; // The two comparisons should have either the same predicate or the; // predicate of one of the comparisons is the opposite of the other one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Testability,test,tests,40,// Don't do this transform for sign bit tests. Let foldLogicOfSetCCs; // handle it using OR/AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:171,Testability,test,tested,171,"// Combine `(select c, (X & 1), 0)` -> `(and (zext c), X)`.; // We canonicalize to the `select` form in the middle end, but the `and` form; // gets better codegen and all tested targets (arm, x86, riscv)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Energy Efficiency,reduce,reduce,45,/// This contains all DAGCombine rules which reduce two values combined by; /// an And operation to a single value. This makes them reusable in the context; /// of visitSELECT(). Rules involving constants are not included as; /// visitSELECT() already handles those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Modifiability,Rewrite,Rewrite,9,// TODO: Rewrite this to return a new 'AND' instead of using CombineTo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Performance,load,loaded,81,// ZEXTLOAD will match without needing to change the size of the value being; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Performance,load,loads,51,// Do not change the width of a volatile or atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,loads,19,// Do not generate loads of non-round integer types since these can; // be expensive (and would be wrong if the type is not byte sized).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,loads,19,// Do not generate loads of non-round integer types since these can; // be expensive (and would be wrong if the type is not byte sized).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Performance,load,loads,50,// Don't change the width of a volatile or atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,scalab,scalable,30,"// Bail out when changing the scalable property, since we can't be sure that; // we're actually narrowing here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Performance,load,load,42,// Verify that we are actually reducing a load width here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Security,access,access,65,// Ensure that this isn't going to produce an unsupported memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Modifiability,extend,extended,47,// It's not possible to generate a constant of extended or untyped type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:79,Performance,load,load,79,"// Don't transform one with multiple uses, this would require adding a new; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:256,Availability,down,downstream,256,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Performance,load,load,38,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,Performance,load,loaded,87,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Performance,load,load,146,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:267,Testability,log,logic,267,"// For the transform to be legal, the load must produce only two values; // (the value loaded and the chain). Don't transform a pre-increment; // load, for example, which produces an extra value. Otherwise the; // transformation is not equivalent, and the downstream logic to replace; // uses gets things wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,// If the load that we're shrinking is an extload and we're not just; // discarding the extension we can't simply shrink the load. Bail.; // TODO: It would be possible to merge the extensions in some cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125,Performance,load,load,125,// If the load that we're shrinking is an extload and we're not just; // discarding the extension we can't simply shrink the load. Bail.; // TODO: It would be possible to merge the extensions in some cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Usability,simpl,simply,107,// If the load that we're shrinking is an extload and we're not just; // discarding the extension we can't simply shrink the load. Bail.; // TODO: It would be possible to merge the extensions in some cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Performance,load,loads,52,"// Recursively search for the operands, looking for loads which can be; // narrowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loads,33,// Use LE to convert equal sized loads to zext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Availability,mask,mask,40,// We can accept extending nodes if the mask is wider or an equal; // width to the original type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Modifiability,extend,extending,17,// We can accept extending nodes if the mask is wider or an equal; // width to the original type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Availability,mask,masked,29,// Allow one node which will masked along with any loads found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Performance,load,loads,51,// Allow one node which will masked along with any loads found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Availability,mask,masked,35,// Also ensure that the node to be masked only produces one data result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,load,53,// No need to do anything if the and directly uses a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,Availability,mask,masking,75,"// If it exists, fixup the single node we allow in the tree that needs; // masking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Performance,load,loads,17,// Create narrow loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125,Performance,perform,performance,125,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Testability,log,logical,23,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Testability,log,logical,65,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:84,Testability,log,logical,84,// Unfold; // x & (-1 'logical shift' y); // To; // (x 'opposite logical shift' y) 'logical shift' y; // if it is better for performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,mask,37,// Do we actually prefer shifts over mask?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Testability,log,logical,29,// Try to match (-1 '[outer] logical shift' y),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Testability,log,logical,21,// tmp = x 'opposite logical shift' y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Testability,log,logical,14,// ret = tmp 'logical shift' y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Availability,mask,mask,65,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Testability,log,logic,25,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Testability,test,tests,36,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Testability,test,test,108,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:141,Testability,test,test,141,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Usability,clear,clear,54,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,Testability,test,test,57,// Attempt to find a 'not' op.; // TODO: Should we favor test+set even without the 'not' op?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:140,Availability,mask,masking,140,"// Look though an optional truncation. The source operand may not be the; // same type as the original 'and', but that is ok because we are masking; // off everything but the low bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Testability,test,test,59,// Try again to find a 'not' op.; // TODO: Should we favor test+set even with two 'not' ops?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Availability,mask,mask,43,"// Turn this into a bit-test pattern using mask op + setcc:; // and (not (srl X, C)), 1 --> (and X, 1<<C) == 0; // and (srl (not X), C)), 1 --> (and X, 1<<C) == 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,Testability,test,test,24,"// Turn this into a bit-test pattern using mask op + setcc:; // and (not (srl X, C)), 1 --> (and X, 1<<C) == 0; // and (srl (not X), C)), 1 --> (and X, 1<<C) == 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Testability,log,logically,36,// xor/add with SMIN (signmask) are logically equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Testability,log,logic,20,"/// Given a bitwise logic operation N with a matching bitwise logic operand,; /// fold a pattern where 2 of the source operands are identically shifted; /// values. For example:; /// ((X0 << Y) | Z) | (X1 << Y) --> ((X0 | X1) << Y) | Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Testability,log,logic,62,"/// Given a bitwise logic operation N with a matching bitwise logic operand,; /// fold a pattern where 2 of the source operands are identically shifted; /// values. For example:; /// ((X0 << Y) | Z) | (X1 << Y) --> ((X0 | X1) << Y) | Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Testability,log,logic,25,// Match another bitwise logic op and a shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Testability,log,logic,43,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,Testability,LOG,LOGIC,102,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Testability,LOG,LOGIC,109,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Testability,LOG,LOGIC,146,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,Testability,LOG,LOGIC,157,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Testability,LOG,LOGIC,182,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Testability,LOG,LOGIC,189,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:226,Testability,LOG,LOGIC,226,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:237,Testability,LOG,LOGIC,237,"// Match another shift op inside the first logic operand. Handle both commuted; // possibilities.; // LOGIC (LOGIC (SH X0, Y), Z), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z; // LOGIC (LOGIC Z, (SH X0, Y)), (SH X1, Y) --> LOGIC (SH (LOGIC X0, X1), Y), Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Testability,log,logic,20,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Testability,LOG,LOGIC,59,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,Testability,LOG,LOGIC,66,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:80,Testability,LOG,LOGIC,80,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,Testability,LOG,LOGIC,190,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:197,Testability,LOG,LOGIC,197,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:220,Testability,LOG,LOGIC,220,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:254,Testability,LOG,LOGIC,254,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:265,Testability,LOG,LOGIC,265,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:285,Testability,LOG,LOGIC,285,"/// Given a tree of logic operations with shape like; /// (LOGIC (LOGIC (X, Y), LOGIC (Z, Y))); /// try to match and fold shift operations with the same shift amount.; /// For example:; /// LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W) -->; /// --> LOGIC (SH (LOGIC X0, X1), Y), (LOGIC Z, W)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Testability,LOG,LOGIC,47,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Testability,LOG,LOGIC,54,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Testability,LOG,LOGIC,77,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,Testability,LOG,LOGIC,102,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Testability,LOG,LOGIC,109,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:132,Testability,LOG,LOGIC,132,"// Try to match one of following patterns:; // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC (SH X1, Y), W); // LOGIC (LOGIC (SH X0, Y), Z), (LOGIC W, (SH X1, Y)); // Note that foldLogicOfShifts will handle commuted versions of the left hand; // itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,Availability,mask,masked,46,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Availability,mask,mask,96,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:124,Modifiability,extend,extended,124,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,load,53,// For this AND to be a zero extension of the masked load the elements; // of the BuildVec must mask the bottom bits of the extended element; // type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Usability,clear,clears,59,"// fold (and (any_ext V), c) -> (zero_ext V) if 'and' only clears top bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,load,load,27,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:80,Performance,load,load,80,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:218,Performance,load,load,218,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:124,Usability,clear,clears,124,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Modifiability,variab,variable,18,"// Make sure that variable 'Constant' is only set if 'SplatBitSize' is a; // multiple of 'BitWidth'. Otherwise, we could propagate a wrong value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,Availability,mask,mask,142,"// The splat value may be something like ""0x00FFFFFF"", which means 0 for; // the first vector value and FF for the rest, repeating. We need a mask; // that will apply equally to all members of the vector, so AND all the; // lanes of the constant together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Security,access,access,63,// Resize the constant to the same size as the original memory access before; // extension. If it is still the AllOnesValue then this AND is completely; // unneeded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,"// If the load type was an EXTLOAD, convert to ZEXTLOAD in order to; // preserve semantics once we get rid of the AND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,loads,16,// PRE/POST_INC loads have 3 values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Availability,mask,mask,29,// Try to convert a constant mask AND into a shuffle clear mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Availability,mask,mask,59,// Try to convert a constant mask AND into a shuffle clear mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Usability,clear,clear,53,// Try to convert a constant mask AND into a shuffle clear mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,// Avoid recheck of N.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,load,14,"// fold (and (load x), 255) -> (zextload x, i8); // fold (and (extload x, i16), 255) -> (zextload x, i8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:187,Modifiability,extend,extend,187,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,Performance,load,loads,76,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Performance,load,loads,109,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:152,Performance,Perform,Perform,152,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:238,Performance,load,loads,238,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify: (and (op x...), (op y...)) -> (op (and x, y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Availability,Mask,Masking,3,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Modifiability,extend,extended,63,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:203,Usability,Simpl,SimplifyDemandedBits,203,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:104,Performance,load,load,104,// fold (zext_inreg (extload x)) -> (zextload x); // fold (zext_inreg (sextload x)) -> (zextload x) iff load has one use,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Modifiability,extend,extended,31,"// If we zero all the possible extended bits, then we can turn this into; // a zextload if we are running before legalize or the operation is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:126,Availability,mask,mask,126,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:212,Energy Efficiency,power,power,212,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:136,Usability,clear,clears,136,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Safety,avoid,avoid,44,// Postpone until legalization completed to avoid interference with bswap; // folding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Usability,clear,clear,91,// Make sure everything beyond the low halfword gets set to zero since the SRL; // 16 will clear the top bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Availability,mask,masked,27,// If the left-shift isn't masked out then the only way this is a bswap is; // if all bits beyond the low 8 are 0. In that case the entire pattern; // reduces to a left shift anyway: leave it for other parts of the combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:151,Energy Efficiency,reduce,reduces,151,// If the left-shift isn't masked out then the only way this is a bswap is; // if all bits beyond the low 8 are 0. In that case the entire pattern; // reduces to a left shift anyway: leave it for other parts of the combiner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,masked,37,"// However, if the right shift isn't masked out then it might be because; // it's not needed. See if we can spot that too. If the high bits aren't; // demanded, we only need bits 23:16 to be zero. Otherwise, we need all; // upper bits to be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,mask,37,// SHL or SRL: look upstream for AND mask operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Usability,clear,clear,32,// In case demanded bits didn't clear the bits that will be shifted out.; // This is needed for X86.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Modifiability,rewrite,rewrite,103,"// Match this pattern:; // (or (and (shl (A, 8)), 0xff00ff00), (and (srl (A, 8)), 0x00ff00ff)); // And rewrite this to:; // (rotr (bswap A), 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Testability,test,tests,73,// TODO: this is too restrictive; lifting this restriction requires more tests,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Energy Efficiency,reduce,reduce,45,/// This contains all DAGCombine rules which reduce two values combined by; /// an Or operation to a single value \see visitANDLike().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,Availability,Mask,Mask,65,"// fold (or (shuf A, V_0, MA), (shuf B, V_0, MB)) -> (shuf A, B, Mask); // Do this only if the resulting type / shuffle is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify: (or (op x...), (op y...)) -> (op (or x, y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Safety,avoid,avoid,44,// Postpone until legalization completed to avoid interference with bswap; // folding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:285,Energy Efficiency,reduce,reduces,285,"// Return true if we can prove that, whenever Neg and Pos are both in the; // range [0, EltSize), Neg == (Pos == 0 ? 0 : EltSize - Pos). This means that; // for two opposing shifts shift1 and shift2 and a value X with OpBits bits:; //; // (or (shift1 X, Neg), (shift2 X, Pos)); //; // reduces to a rotate in direction shift2 by Pos or (equivalently) a rotate; // in direction shift1 by Neg. The range [0, EltSize) means that we only need; // to consider shift amounts with defined behavior.; //; // The IsRotate flag should be set when the LHS of both shifts is the same.; // Otherwise if matching a general funnel shift, it should be clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:635,Usability,clear,clear,635,"// Return true if we can prove that, whenever Neg and Pos are both in the; // range [0, EltSize), Neg == (Pos == 0 ? 0 : EltSize - Pos). This means that; // for two opposing shifts shift1 and shift2 and a value X with OpBits bits:; //; // (or (shift1 X, Neg), (shift2 X, Pos)); //; // reduces to a rotate in direction shift2 by Pos or (equivalently) a rotate; // in direction shift1 by Neg. The range [0, EltSize) means that we only need; // to consider shift amounts with defined behavior.; //; // The IsRotate flag should be set when the LHS of both shifts is the same.; // Otherwise if matching a general funnel shift, it should be clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1191,Availability,Mask,Mask,1191,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1320,Availability,Mask,Mask,1320,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Energy Efficiency,power,power,19,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:209,Energy Efficiency,power,power,209,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:798,Energy Efficiency,power,power,798,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Availability,Mask,Mask,86,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Availability,redundant,redundant,161,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Safety,redund,redundant,161,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Availability,Mask,Mask,59,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:85,Availability,Mask,Mask,85,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Availability,Mask,Mask,147,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:162,Availability,Mask,Mask,162,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Availability,Mask,Mask,189,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:151,Availability,Mask,Mask,151,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Availability,Mask,Mask,189,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:228,Availability,Mask,Mask,228,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:275,Availability,Mask,Mask,275,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:302,Availability,Mask,Mask,302,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:321,Availability,Mask,Mask,321,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:345,Availability,Mask,Mask,345,"// Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.; // Then the condition we want to prove becomes:; //; // (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask; //; // which, again because ""x & Mask"" is a truncation, becomes:; //; // NegC & Mask == (EltSize - PosC) & Mask; // EltSize & Mask == (NegC + PosC) & Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Availability,Mask,Mask,44,// Now we just need to check that EltSize & Mask == Width & Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Availability,Mask,Mask,60,// Now we just need to check that EltSize & Mask == Width & Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Availability,Mask,Mask,13,// EltSize & Mask is 0 since Mask is EltSize - 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Availability,Mask,Mask,29,// EltSize & Mask is 0 since Mask is EltSize - 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,Energy Efficiency,reduce,reduces,143,"// A subroutine of MatchRotate used once we have found an OR of two opposite; // shifts of Shifted. If Neg == <operand size> - Pos then the OR reduces; // to both (PosOpcode Shifted, Pos) and (NegOpcode Shifted, Neg), with the; // former being preferred if supported. InnerPos and InnerNeg are Pos and; // Neg with outer conversions stripped away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,Energy Efficiency,reduce,reduces,143,"// A subroutine of MatchRotate used once we have found an OR of two opposite; // shifts of N0 + N1. If Neg == <operand size> - Pos then the OR reduces; // to both (PosOpcode N0, N1, Pos) and (NegOpcode N0, N1, Neg), with the; // former being preferred if supported. InnerPos and InnerNeg are Pos and; // Neg with outer conversions stripped away.; // TODO: Merge with MatchRotatePosNeg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:398,Availability,down,down,398,"// InstCombine may have combined a constant shl, srl, mul, or udiv with one; // side of the rotate, so try to handle that here. In all cases we need to; // pass the matched shift from the opposite side to compute the opcode and; // needed shift amount to extract. We still want to do this if both sides; // matched a rotate half because one half may be a potential overshift that; // can be broken down (ie if InstCombine merged two shl or srl ops into a; // single one).; // Have LHS side of the rotate, try to extract the needed shift from the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:67,Modifiability,variab,variable,67,"// Even pre-legalization, we can't easily rotate/funnel-shift by a variable; // shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Availability,mask,mask,17,"// If there is a mask here, and we have a variable shift, we can't be sure; // that we're masking out the right stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:90,Availability,mask,masking,90,"// If there is a mask here, and we have a variable shift, we can't be sure; // that we're masking out the right stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Modifiability,variab,variable,42,"// If there is a mask here, and we have a variable shift, we can't be sure; // that we're masking out the right stuff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Modifiability,extend,extended,40,// If the shift amount is sign/zext/any-extended just peel it off.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:547,Performance,load,loads,547,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:595,Performance,load,load,595,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:727,Performance,Load,Load,727,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:754,Performance,Load,Load,754,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:897,Performance,load,loads,897,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1248,Performance,Load,LoadCombine,1248,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1324,Performance,load,loads,1324,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1437,Performance,load,load,1437,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1609,Performance,Load,LoadCombine,1609,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1640,Performance,load,loads,1640,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1787,Performance,LOAD,LOAD,1787,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1813,Performance,LOAD,LOAD,1813,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1818,Performance,LOAD,LOAD,1818,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1835,Performance,LOAD,LOAD,1835,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:907,Usability,simpl,simply,907,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Performance,load,load,59,// Only allow multiple uses if the instruction is a vector load (in which; // case we will use the load for every ExtractVectorElement),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:99,Performance,load,load,99,// Only allow multiple uses if the instruction is a vector load (in which; // case we will use the load for every ExtractVectorElement),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,Performance,LOAD,LOAD,57,// Fail to combine if we have encountered anything but a LOAD after handling; // an ExtractVectorElement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Usability,simpl,simply,161,"// Check to see if the position of the element in the vector corresponds; // with the byte we are trying to provide for. In the case of a vector of; // i8, this simply means the VectorIndex == StartingIndex. For non i8 cases,; // the element will provide a range of bytes. For example, if we have a; // vector of i16s, each element provides two bytes (V[1] provides byte 2 and; // 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Performance,load,load,23,"// If the width of the load does not reach byte we are trying to provide for; // and it is not a ZEXTLOAD, then the load does not provide for the byte in; // question",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Performance,load,load,116,"// If the width of the load does not reach byte we are trying to provide for; // and it is not a ZEXTLOAD, then the load does not provide for the byte in; // question",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,Performance,load,loaded,97,"// Check if the bytes offsets we are looking at match with either big or; // little endian value loaded. Return true for big endian, false for little; // endian, and std::nullopt if match failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Usability,simpl,simple,26,// We only handle merging simple stores of 1-4 bytes.; // TODO: Allow unordered atomics when wider type is legal (see D66309),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:297,Performance,load,loads,297,"// All stores must be the same size to ensure that we are writing all of the; // bytes in the wide value.; // This store should have exactly one use as a chain operand for another; // store in the merging set. If there are other chain uses, then the; // transform may not be safe because order of loads/stores outside of this; // set may not be preserved.; // TODO: We could allow multiple sizes by tracking each stored byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:275,Safety,safe,safe,275,"// All stores must be the same size to ensure that we are writing all of the; // bytes in the wide value.; // This store should have exactly one use as a chain operand for another; // store in the merging set. If there are other chain uses, then the; // transform may not be safe because order of loads/stores outside of this; // set may not be preserved.; // TODO: We could allow multiple sizes by tracking each stored byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simple,10,// Handle simple types only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:84,Modifiability,extend,extends,84,// Stores must share the same source value with different offsets.; // Truncate and extends should be stripped to get the single source value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:650,Deployability,update,updated,650,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Performance,load,loaded,54,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:84,Performance,load,loads,84,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:144,Performance,load,load,144,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:154,Performance,load,load,154,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:675,Performance,load,loads,675,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:783,Performance,load,load,783,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:897,Performance,load,load,897,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:918,Performance,load,load,918,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1069,Performance,load,load,1069,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1255,Performance,load,load,1255,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1279,Performance,load,load,1279,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Usability,simpl,simple,11,// Handles simple types only,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,load,loaded,58,// Check if all the bytes of the OR we are looking at are loaded from the same; // base address. Collect bytes offsets from Base address in ByteOffsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:74,Modifiability,extend,extend,74,"// It's OK for the N most significant bytes to be 0, we can just; // zero-extend the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:85,Performance,load,load,85,"// It's OK for the N most significant bytes to be 0, we can just; // zero-extend the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Performance,load,loads,7,// All loads must share the same chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Load,Loads,3,// Loads must share the same base address,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,loads,14,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,Performance,load,load,34,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:222,Performance,load,load,222,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:420,Performance,load,load,420,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:165,Security,access,accessing,165,"// For vector loads, the expected load combine pattern will have an; // ExtractElement for each index in the vector. While each of these; // ExtractElements will be accessing the same base address as determined; // by the load instruction, the actual bytes they interact with will differ; // due to different ExtractElement indices. To accurately determine the; // byte position of an ExtractElement, we offset the base load ptr with; // the index multiplied by the byte size of each element in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,load,load,27,// Remember the first byte load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,loads,53,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:106,Performance,load,loads,106,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:144,Performance,load,load,144,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:187,Performance,load,loads,187,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:99,Performance,load,load,99,// Check if the bytes of the OR we are looking at match with either big or; // little endian value load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loaded,33,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:70,Performance,load,load,70,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Performance,load,loaded,109,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Performance,load,load,131,// Ensure that the first byte is loaded from zero offset of the first load.; // So the combined value can be loaded from the first load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Modifiability,extend,extended,116,"// The node we are looking at matches with the pattern, check if we can; // replace it with a single (possibly zero-extended) load and bswap + shift if; // needed.; // If the load needs byte swap check if the target supports it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:126,Performance,load,load,126,"// The node we are looking at matches with the pattern, check if we can; // replace it with a single (possibly zero-extended) load and bswap + shift if; // needed.; // If the load needs byte swap check if the target supports it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:175,Performance,load,load,175,"// The node we are looking at matches with the pattern, check if we can; // replace it with a single (possibly zero-extended) load and bswap + shift if; // needed.; // If the load needs byte swap check if the target supports it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:271,Modifiability,extend,extending,271,// Before legalize we can introduce illegal bswaps which will be later; // converted to an explicit bswap sequence. This way we end up with a single; // load and byte shuffling instead of several loads and byte shuffling.; // We do not introduce illegal bswaps when zero-extending as this tends to; // introduce too many arithmetic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:153,Performance,load,load,153,// Before legalize we can introduce illegal bswaps which will be later; // converted to an explicit bswap sequence. This way we end up with a single; // load and byte shuffling instead of several loads and byte shuffling.; // We do not introduce illegal bswaps when zero-extending as this tends to; // introduce too many arithmetic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:196,Performance,load,loads,196,// Before legalize we can introduce illegal bswaps which will be later; // converted to an explicit bswap sequence. This way we end up with a single; // load and byte shuffling instead of several loads and byte shuffling.; // We do not introduce illegal bswaps when zero-extending as this tends to; // introduce too many arithmetic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Modifiability,extend,extend,32,"// If we need to bswap and zero extend, we have to insert a shift. Check that; // it is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,load,16,// Check that a load of the wide type is both allowed and fast on the target,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loads,33,// Transfer chain users from old loads to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Performance,load,load,50,// Transfer chain users from old loads to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Availability,mask,masked,91,"// If the target has andn, bsl, or a similar bit-select instruction,; // we want to unfold masked merge, with canonical pattern of:; // | A | |B|; // ((x ^ y) & m) ^ y; // | D |; // Into:; // (x & m) | (y & ~m); // If y is a constant, m is not a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // ~(~x & m) & (m | y); // If x is a constant, m is a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // (x | ~m) & ~(~m & ~y); // NOTE: we don't unfold the pattern if 'xor' is actually a 'not', because at; // the very least that breaks andnpd / andnps patterns, and because those; // patterns are simplified in IR and shouldn't be created in the DAG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:684,Usability,simpl,simplified,684,"// If the target has andn, bsl, or a similar bit-select instruction,; // we want to unfold masked merge, with canonical pattern of:; // | A | |B|; // ((x ^ y) & m) ^ y; // | D |; // Into:; // (x & m) | (y & ~m); // If y is a constant, m is not a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // ~(~x & m) & (m | y); // If x is a constant, m is a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // (x | ~m) & ~(~m & ~y); // NOTE: we don't unfold the pattern if 'xor' is actually a 'not', because at; // the very least that breaks andnpd / andnps patterns, and because those; // patterns are simplified in IR and shouldn't be created in the DAG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Availability,mask,mask,28,"// Don't do anything if the mask is constant. This should not be reachable.; // InstCombine should have already unfolded this pattern, and DAGCombiner; // probably shouldn't produce it, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify: xor (op x...), (op y...) -> (op (xor x, y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the expression using non-local knowledge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:232,Performance,throughput,throughput,232,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op. This is a; /// throughput improvement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Testability,log,logic,48,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op. This is a; /// throughput improvement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:207,Testability,log,logic,207,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op. This is a; /// throughput improvement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Testability,log,logic,27,// Match a one-use bitwise logic op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Testability,Log,Logic,3,"// Logic ops are commutative, so check each operand for a match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Testability,log,logic,10,"// shift (logic (shift X, C0), Y), C1 -> logic (shift X, C0+C1), (shift Y, C1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Testability,log,logic,41,"// shift (logic (shift X, C0), Y), C1 -> logic (shift X, C0+C1), (shift Y, C1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,Safety,avoid,avoid,123,"// fold (shl (zext (srl x, C)), C) -> (zext (shl (srl x, C), C)); // Only fold this if the inner zext has no other uses to avoid increasing; // the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Availability,MASK,MASK,60,"// fold (shl (srl x, c1), c2) -> (and (shl x, (sub c2, c1), MASK) or; // (and (srl x, (sub c1, c2), MASK); // Only fold this if the inner shift has no other uses -- if it does,; // folding this will increase the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Availability,MASK,MASK,100,"// fold (shl (srl x, c1), c2) -> (and (shl x, (sub c2, c1), MASK) or; // (and (srl x, (sub c1, c2), MASK); // Only fold this if the inner shift has no other uses -- if it does,; // folding this will increase the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,Energy Efficiency,power,power,178,"// fold (shl (add x, c1), c2) -> (add (shl x, c2), c1 << c2); // fold (shl (or x, c1), c2) -> (or (shl x, c2), c1 << c2); // Variant of version done on multiply, except mul by a power of 2 is turned; // into a shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:128,Testability,test,test,128,"// fold (shl (sext (add_nsw x, c1)), c2) -> (add (shl (sext x), c2), c1 << c2); // TODO: Add zext/add_nuw variant with suitable test coverage; // TODO: Should we limit this with isLegalAddImmediate?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Modifiability,extend,extend,36,// Both operands must be equivalent extend nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Modifiability,extend,extend,22,// Check that the two extend nodes are the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Modifiability,extend,extend,51,"// If the operation feeding into the MUL is a sign extend (sext),; // we use mulhs. Othewise, zero extends (zext) use mulhu.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:99,Modifiability,extend,extends,99,"// If the operation feeding into the MUL is a sign extend (sext),; // we use mulhs. Othewise, zero extends (zext) use mulhu.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Modifiability,extend,extend,77,"// If the shift is not a no-op (in which case this should be just a sign; // extend already), the truncated to type is legal, sign_extend is legal; // on that type, and the truncate to that type is both legal and free,; // perform the transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:223,Performance,perform,perform,223,"// If the shift is not a no-op (in which case this should be just a sign; // extend already), the truncated to type is legal, sign_extend is legal; // on that type, and the truncate to that type is both legal and free,; // perform the transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:165,Availability,mask,masking,165,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Usability,simpl,simple,13,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Usability,simpl,simple,137,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify, based on bits shifted out of the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,Safety,detect,detected,94,// Try to transform this shift into a multiply-high if; // it matches the appropriate pattern detected in combineShiftToMULH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Modifiability,extend,extending,59,// Attempt to convert a sra of a load into a narrower sign-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,load,33,// Attempt to convert a sra of a load into a narrower sign-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:69,Performance,load,load,69,// Attempt to convert a sra of a load into a narrower sign-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Availability,Mask,Mask,138,"// In the more general case, we can clear the high bits after the shift:; // srl (trunc (srl x, c1)), c2 --> trunc (and (srl x, (c1+c2)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Usability,clear,clear,36,"// In the more general case, we can clear the high bits after the shift:; // srl (trunc (srl x, c1)), c2 --> trunc (and (srl x, (c1+c2)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Availability,MASK,MASK,60,"// fold (srl (shl x, c1), c2) -> (and (shl x, (sub c1, c2), MASK) or; // (and (srl x, (sub c2, c1), MASK)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Availability,MASK,MASK,100,"// fold (srl (shl x, c1), c2) -> (and (shl x, (sub c1, c2), MASK) or; // (and (srl x, (sub c2, c1), MASK)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Availability,mask,mask,63,"// fold (srl (anyextend x), c) -> (and (anyextend (srl x, c)), mask); // TODO - support non-uniform vector shift amounts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Energy Efficiency,power,power,82,"// fold (srl (ctlz x), ""5"") -> x iff x has one bit set (the low bit), and x has a power; // of two bitwidth. The ""5"" represents (log2 (bitwidth x)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:172,Usability,clear,clear,172,"// Okay, we know that only that the single bit specified by UnknownBits; // could be set on input to the CTLZ node. If this bit is set, the SRL; // will return 0, if it is clear, it returns 1. Change the CTLZ/SRL pair; // to an SRL/XOR pair, which is likely to simplify more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:261,Usability,simpl,simplify,261,"// Okay, we know that only that the single bit specified by UnknownBits; // could be set on input to the CTLZ node. If this bit is set, the SRL; // will return 0, if it is clear, it returns 1. Change the CTLZ/SRL pair; // to an SRL/XOR pair, which is likely to simplify more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Modifiability,extend,extending,59,// Attempt to convert a srl of a load into a narrower zero-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,load,33,// Attempt to convert a srl of a load into a narrower zero-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:69,Performance,load,load,69,// Attempt to convert a srl of a load into a narrower zero-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Performance,optimiz,optimize,42,"// Here is a common situation. We want to optimize:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // However when after the source operand of SRL is optimized into AND, the SRL; // itself may not be optimized further. Look for it and add the BRCOND into; // the worklist.; //; // The also tends to happen for binary operations when SimplifyDemandedBits; // is involved.; //; // FIXME: This is unecessary if we process the DAG in topological order,; // which we plan to do. This workaround can be removed once the DAG is; // processed in topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:284,Performance,optimiz,optimized,284,"// Here is a common situation. We want to optimize:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // However when after the source operand of SRL is optimized into AND, the SRL; // itself may not be optimized further. Look for it and add the BRCOND into; // the worklist.; //; // The also tends to happen for binary operations when SimplifyDemandedBits; // is involved.; //; // FIXME: This is unecessary if we process the DAG in topological order,; // which we plan to do. This workaround can be removed once the DAG is; // processed in topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:334,Performance,optimiz,optimized,334,"// Here is a common situation. We want to optimize:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // However when after the source operand of SRL is optimized into AND, the SRL; // itself may not be optimized further. Look for it and add the BRCOND into; // the worklist.; //; // The also tends to happen for binary operations when SimplifyDemandedBits; // is involved.; //; // FIXME: This is unecessary if we process the DAG in topological order,; // which we plan to do. This workaround can be removed once the DAG is; // processed in topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:467,Usability,Simpl,SimplifyDemandedBits,467,"// Here is a common situation. We want to optimize:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // However when after the source operand of SRL is optimized into AND, the SRL; // itself may not be optimized further. Look for it and add the BRCOND into; // the worklist.; //; // The also tends to happen for binary operations when SimplifyDemandedBits; // is involved.; //; // FIXME: This is unecessary if we process the DAG in topological order,; // which we plan to do. This workaround can be removed once the DAG is; // processed in topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,Safety,detect,detected,94,// Try to transform this shift into a multiply-high if; // it matches the appropriate pattern detected in combineShiftToMULH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:191,Testability,test,test,191,"// fold (fshl ld1, ld0, c) -> (ld0[ofs]) iff ld0 and ld1 are consecutive.; // fold (fshr ld1, ld0, c) -> (ld0[ofs]) iff ld0 and ld1 are consecutive.; // TODO - bigendian support once we have test coverage.; // TODO - can we merge this with CombineConseutiveLoads/MatchLoadCombine?; // TODO - permit LHS EXTLOAD if extensions are shifted out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,load,19,// Replace the old load's chain with the new load's chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Performance,load,load,45,// Replace the old load's chain with the new load's chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:212,Safety,avoid,avoiding,212,"// fold (fshl N0, N0, N2) -> (rotl N0, N2); // fold (fshr N0, N0, N2) -> (rotr N0, N2); // TODO: Investigate flipping this rotate if only one is legal, if funnel shift; // is legal as well we might be better off avoiding non-constant (BW - N2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,"// Simplify, based on bits shifted out of N0/N1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:67,Modifiability,EXTEND,EXTEND,67,"// Given a ABS node, detect the following patterns:; // (ABS (SUB (EXTEND a), (EXTEND b))).; // (TRUNC (ABS (SUB (EXTEND a), (EXTEND b)))).; // Generates UABD/SABD instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:79,Modifiability,EXTEND,EXTEND,79,"// Given a ABS node, detect the following patterns:; // (ABS (SUB (EXTEND a), (EXTEND b))).; // (TRUNC (ABS (SUB (EXTEND a), (EXTEND b)))).; // Generates UABD/SABD instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:114,Modifiability,EXTEND,EXTEND,114,"// Given a ABS node, detect the following patterns:; // (ABS (SUB (EXTEND a), (EXTEND b))).; // (TRUNC (ABS (SUB (EXTEND a), (EXTEND b)))).; // Generates UABD/SABD instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:126,Modifiability,EXTEND,EXTEND,126,"// Given a ABS node, detect the following patterns:; // (ABS (SUB (EXTEND a), (EXTEND b))).; // (TRUNC (ABS (SUB (EXTEND a), (EXTEND b)))).; // Generates UABD/SABD instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Safety,detect,detect,21,"// Given a ABS node, detect the following patterns:; // (ABS (SUB (EXTEND a), (EXTEND b))).; // (TRUNC (ABS (SUB (EXTEND a), (EXTEND b)))).; // Generates UABD/SABD instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Modifiability,extend,extended,52,// Check if the operands of the sub are (zero|sign)-extended.; // TODO: Should we use ValueTracking instead?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Testability,log,logical-shift-by-,32,// Try to canonicalize bswap-of-logical-shift-by-8-bit-multiple as; // inverse-shift-of-bswap:; // bswap (X u<< C) --> (bswap X) u>> C; // bswap (X u>> C) --> (bswap X) u<< C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:154,Availability,mask,mask,154,"/// If a (v)select has a condition value that is a sign-bit test, try to smear; /// the condition operand sign-bit across the value width and use it as a mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Testability,test,test,60,"/// If a (v)select has a condition value that is a sign-bit test, try to smear; /// the condition operand sign-bit across the value width and use it as a mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,Availability,reliab,reliably,66,"// fold (select Cond, 0, 1) -> (xor Cond, 1); // We can't do this reliably if integer based booleans have different contents; // to floating point based booleans. This is because we can't tell whether we; // have an integer-based boolean or a floating-point-based boolean unless we; // can find the SETCC that produced it and inspect its operands. This is; // fairly easy if C is the SETCC node, but it can potentially be; // undiscoverable (or not reasonably discoverable). For example, it could be; // in another basic block or it could require searching a complicated; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Safety,avoid,avoid,39,"// Only do this before legalization to avoid conflicting with target-specific; // transforms in the other direction (create a select from a zext/sext). There; // is also a target-independent combine here in DAGCombiner in the other; // direction for (select Cond, -1, 0) when the condition is not i1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:79,Modifiability,extend,extend,79,"// For any constants that differ by 1, we can transform the select into; // an extend and add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,mask,37,"// If we have to invert the sign bit mask, only do that transform if the; // target has a bitwise 'and not' instruction (the invert is free).; // (Cond0 s< -0) ? 0 : N2 --> ~(Cond0 s>> BW-1) & N2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:475,Performance,optimiz,optimize,475,"// The code in this block deals with the following 2 equivalences:; // select(C0|C1, x, y) <=> select(C0, x, select(C1, x, y)); // select(C0&C1, x, y) <=> select(C0, select(C1, x, y), y); // The target can specify its preferred form with the; // shouldNormalizeToSelectSequence() callback. However we always transform; // to the right anyway if we find the inner select exists in the DAG anyway; // and we always transform to the left side if we know that we can further; // optimize the combination of the conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Availability,failure,failure,14,// Cleanup on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Availability,failure,failure,14,// Cleanup on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,optimiz,optimize,27,"// Otherwise see if we can optimize the ""and"" to a better pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,optimiz,optimize,27,// Otherwise see if we can optimize to a better pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Performance,optimiz,optimize,39,"// Use 'unsigned add with overflow' to optimize an unsigned saturating add.; // This is conservatively limited to pre-legal-operations to give targets; // a chance to reverse the transform if they want to do that. Also, it is; // unlikely that the pattern would be formed late, so it's probably not; // worth going through the other checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Availability,avail,available,13,// Any flags available in a select/setcc fold will be on the setcc as they; // migrated from fcmp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:8,Performance,perform,perform,8,// Only perform the transformation when existing operands can be reused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Modifiability,extend,extends,41,// It's always safe to look through zero extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Safety,safe,safe,15,// It's always safe to look through zero extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Modifiability,extend,extends,39,// It's only safe to look through sign extends when Index is signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Safety,safe,safe,13,// It's only safe to look through sign extends when Index is signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Availability,mask,mask,28,// Zap scatters with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Availability,mask,mask,28,// Zap scatters with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Availability,mask,masked,7,// Zap masked stores with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Availability,mask,mask,33,// Zap masked stores with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Availability,mask,masked,12,// Remove a masked store if base pointers and masks are equal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,Availability,mask,masks,46,// Remove a masked store if base pointers and masks are equal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Availability,mask,masked,16,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, compressing, or truncating stores?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Availability,mask,mask,45,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, compressing, or truncating stores?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Performance,load,load,23,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, compressing, or truncating stores?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Performance,load,load,73,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, compressing, or truncating stores?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,simpl,simplify,17,"// See if we can simplify the operation with; // SimplifyDemandedBits, which only works if the value has a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Usability,Simpl,SimplifyDemandedBits,49,"// See if we can simplify the operation with; // SimplifyDemandedBits, which only works if the value has a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:112,Usability,Simpl,SimplifyDemandedBits,112,"// Re-visit the store if anything changed and the store hasn't been merged; // with another node (N is deleted) SimplifyDemandedBits will add Value's; // node back to the worklist if necessary, but we also need to re-visit; // the Store node itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Availability,mask,masked,36,"// If this is a TRUNC followed by a masked store, fold this into a masked; // truncating store. We can do this even if this is already a masked; // truncstore.; // TODO: Try combine to masked compress store if possiable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:67,Availability,mask,masked,67,"// If this is a TRUNC followed by a masked store, fold this into a masked; // truncating store. We can do this even if this is already a masked; // truncstore.; // TODO: Try combine to masked compress store if possiable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Availability,mask,masked,137,"// If this is a TRUNC followed by a masked store, fold this into a masked; // truncating store. We can do this even if this is already a masked; // truncstore.; // TODO: Try combine to masked compress store if possiable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:185,Availability,mask,masked,185,"// If this is a TRUNC followed by a masked store, fold this into a masked; // truncating store. We can do this even if this is already a masked; // truncstore.; // TODO: Try combine to masked compress store if possiable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Availability,mask,mask,27,// Zap gathers with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Availability,mask,masked,7,// Zap masked loads with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Availability,mask,mask,32,// Zap masked loads with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,loads,14,// Zap masked loads with a zero mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Availability,mask,masked,16,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, expanding, or extending loads?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Availability,mask,mask,45,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, expanding, or extending loads?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:132,Modifiability,extend,extending,132,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, expanding, or extending loads?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Performance,load,load,23,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, expanding, or extending loads?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Performance,load,load,73,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, expanding, or extending loads?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,Performance,load,loads,142,"// If this is a masked load with an all ones mask, we can use a unmasked load.; // FIXME: Can we do this for indexed, expanding, or extending loads?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,load,36,// Try transforming N to an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,loads,19,// Combine strided loads with unit-stride to a regular VP load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,load,load,58,// Combine strided loads with unit-stride to a regular VP load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:90,Modifiability,variab,variable,90,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Performance,load,loads,146,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Safety,avoid,avoid,82,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Safety,avoid,avoid,131,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:68,Testability,log,logic,68,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Usability,simpl,simplified,49,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,Performance,load,load,157,// Check if we can use the condition value to increment/decrement a single; // constant value. This simplifies a select to an add and removes a constant; // load/materialization from the general case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Usability,simpl,simplifies,100,// Check if we can use the condition value to increment/decrement a single; // constant value. This simplifies a select to an add and removes a constant; // load/materialization from the general case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Usability,simpl,simplifications,11,// Further simplifications for the extra-special cases where the constants are; // all 0 or all -1 should be implemented as folds of these patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:181,Testability,log,logic,181,"// The general case for select-of-constants:; // vselect <N x i1> Cond, C1, C2 --> xor (and (sext Cond), (C1^C2)), C2; // ...but that only makes sense if a vselect is slower than 2 logic ops, so; // leave that to a machine-specific pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:163,Modifiability,extend,extended,163,"// If this select has a condition (setcc) with narrower operands than the; // select, try to widen the compare to match the select width.; // TODO: This should be extended to handle any constant.; // TODO: This could be extended to handle non-loading patterns, but that; // requires thorough testing to avoid regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:220,Modifiability,extend,extended,220,"// If this select has a condition (setcc) with narrower operands than the; // select, try to widen the compare to match the select width.; // TODO: This should be extended to handle any constant.; // TODO: This could be extended to handle non-loading patterns, but that; // requires thorough testing to avoid regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:243,Performance,load,loading,243,"// If this select has a condition (setcc) with narrower operands than the; // select, try to widen the compare to match the select width.; // TODO: This should be extended to handle any constant.; // TODO: This could be extended to handle non-loading patterns, but that; // requires thorough testing to avoid regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:303,Safety,avoid,avoid,303,"// If this select has a condition (setcc) with narrower operands than the; // select, try to widen the compare to match the select width.; // TODO: This should be extended to handle any constant.; // TODO: This could be extended to handle non-loading patterns, but that; // requires thorough testing to avoid regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:292,Testability,test,testing,292,"// If this select has a condition (setcc) with narrower operands than the; // select, try to widen the compare to match the select width.; // TODO: This should be extended to handle any constant.; // TODO: This could be extended to handle non-loading patterns, but that; // requires thorough testing to avoid regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Modifiability,extend,extended,73,"// Both compare operands can be widened for free. The LHS can use an; // extended load, and the RHS is a constant:; // vselect (ext (setcc load(X), C)), N1, N2 -->; // vselect (setcc extload(X), C'), N1, N2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Performance,load,load,82,"// Both compare operands can be widened for free. The LHS can use an; // extended load, and the RHS is a constant:; // vselect (ext (setcc load(X), C)), N1, N2 -->; // vselect (setcc extload(X), C'), N1, N2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:139,Performance,load,load,139,"// Both compare operands can be widened for free. The LHS can use an; // extended load, and the RHS is a constant:; // vselect (ext (setcc load(X), C)), N1, N2 -->; // vselect (setcc extload(X), C'), N1, N2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:134,Testability,log,logic,134,// Check if one of the arms of the VSELECT is vector with all bits set.; // If it's on the left side invert the predicate to simplify logic below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125,Usability,simpl,simplify,125,// Check if one of the arms of the VSELECT is vector with all bits set.; // If it's on the left side invert the predicate to simplify logic below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Testability,test,test,10,"// We can test against either of the addition operands.; // x <= x+y ? x+y : ~0 --> uaddsat x, y; // x+y >= x ? x+y : ~0 --> uaddsat x, y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,Testability,log,logic,123,// Check if one of the arms of the VSELECT is a zero vector. If it's on; // the left side invert the predicate to simplify logic below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:114,Usability,simpl,simplify,114,// Check if one of the arms of the VSELECT is a zero vector. If it's on; // the left side invert the predicate to simplify logic below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:177,Safety,safe,safe,177,"// Another special case: If C was a sign bit, the sub has been; // canonicalized into a xor.; // FIXME: Would it be better to use computeKnownBits to; // determine whether it's safe to decanonicalize the xor?; // x s< 0 ? x^C : 0 --> usubsat x, C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Usability,simpl,simpler,13,// Fold to a simpler select_cc,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:119,Availability,mask,mask,119,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:135,Availability,mask,mask,135,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,Energy Efficiency,power,power,277,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:375,Integrability,depend,depending,375,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Availability,mask,mask,49,// Get constant shift/rotate amount and possibly mask (if its shift+and; // variant).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Availability,mask,mask,14,// Check that mask and shift compliment eachother,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Availability,mask,mask,22,// Check that the and mask is correct for the shift,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Performance,Load,Load,59,"/// Check if N satisfies:; /// N is used once.; /// N is a Load.; /// The load is compatible with ExtOpcode. It means; /// If load has explicit zero/sign extension, ExpOpcode must have the same; /// extension.; /// Otherwise returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:74,Performance,load,load,74,"/// Check if N satisfies:; /// N is used once.; /// N is a Load.; /// The load is compatible with ExtOpcode. It means; /// If load has explicit zero/sign extension, ExpOpcode must have the same; /// extension.; /// Otherwise returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:126,Performance,load,load,126,"/// Check if N satisfies:; /// N is used once.; /// N is a Load.; /// The load is compatible with ExtOpcode. It means; /// If load has explicit zero/sign extension, ExpOpcode must have the same; /// extension.; /// Otherwise returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Performance,Load,LoadExt,7,"// Now LoadExt is either SEXTLOAD or ZEXTLOAD, ExtOpcode must have the same; // extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Performance,load,load,31,"/// Fold; /// (sext (select c, load x, load y)) -> (select c, sextload x, sextload y); /// (zext (select c, load x, load y)) -> (select c, zextload x, zextload y); /// (aext (select c, load x, load y)) -> (select c, extload x, extload y); /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Performance,load,load,39,"/// Fold; /// (sext (select c, load x, load y)) -> (select c, sextload x, sextload y); /// (zext (select c, load x, load y)) -> (select c, zextload x, zextload y); /// (aext (select c, load x, load y)) -> (select c, extload x, extload y); /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Performance,load,load,108,"/// Fold; /// (sext (select c, load x, load y)) -> (select c, sextload x, sextload y); /// (zext (select c, load x, load y)) -> (select c, zextload x, zextload y); /// (aext (select c, load x, load y)) -> (select c, extload x, extload y); /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Performance,load,load,116,"/// Fold; /// (sext (select c, load x, load y)) -> (select c, sextload x, sextload y); /// (zext (select c, load x, load y)) -> (select c, zextload x, zextload y); /// (aext (select c, load x, load y)) -> (select c, extload x, extload y); /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:185,Performance,load,load,185,"/// Fold; /// (sext (select c, load x, load y)) -> (select c, sextload x, sextload y); /// (zext (select c, load x, load y)) -> (select c, zextload x, zextload y); /// (aext (select c, load x, load y)) -> (select c, extload x, extload y); /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:193,Performance,load,load,193,"/// Fold; /// (sext (select c, load x, load y)) -> (select c, sextload x, sextload y); /// (zext (select c, load x, load y)) -> (select c, zextload x, zextload y); /// (aext (select c, load x, load y)) -> (select c, extload x, extload y); /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:261,Modifiability,extend,extends,261,/// Try to fold a sext/zext/aext dag node into a ConstantSDNode or; /// a build_vector of constants.; /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).; /// Vector extends are not folded if operations are legal; this is to; /// avoid introducing illegal build_vector dag nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:325,Safety,avoid,avoid,325,/// Try to fold a sext/zext/aext dag node into a ConstantSDNode or; /// a build_vector of constants.; /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).; /// Vector extends are not folded if operations are legal; this is to; /// avoid introducing illegal build_vector dag nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Modifiability,Extend,ExtendUsesToFormExtLoad,3,"// ExtendUsesToFormExtLoad - Trying to extend uses of a load to enable this:; // ""fold ({s|z|a}ext (load x)) -> ({s|z|a}ext (truncate ({s|z|a}extload x)))""; // transformation. Returns true if extension are possible and the above; // mentioned transformation is profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Modifiability,extend,extend,39,"// ExtendUsesToFormExtLoad - Trying to extend uses of a load to enable this:; // ""fold ({s|z|a}ext (load x)) -> ({s|z|a}ext (truncate ({s|z|a}extload x)))""; // transformation. Returns true if extension are possible and the above; // mentioned transformation is profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Performance,load,load,56,"// ExtendUsesToFormExtLoad - Trying to extend uses of a load to enable this:; // ""fold ({s|z|a}ext (load x)) -> ({s|z|a}ext (truncate ({s|z|a}extload x)))""; // transformation. Returns true if extension are possible and the above; // mentioned transformation is profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Performance,load,load,100,"// ExtendUsesToFormExtLoad - Trying to extend uses of a load to enable this:; // ""fold ({s|z|a}ext (load x)) -> ({s|z|a}ext (truncate ({s|z|a}extload x)))""; // transformation. Returns true if extension are possible and the above; // mentioned transformation is profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Modifiability,extend,extend,15,"// FIXME: Only extend SETCC N, N and SETCC N, c for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,Modifiability,extend,extend,61,"// If truncates aren't free and there are users we can't; // extend, it isn't worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Modifiability,extend,extended,23,// Both unextended and extended values are live out. There had better be; // a good reason for the transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Modifiability,Extend,Extend,3,// Extend SetCC uses if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Performance,load,load,15,"// fold (sext (load x)) to multiple smaller sextloads; same for zext.; // For example, on a target with legal v4i32, but illegal v8i32, turn:; // (v8i32 (sext (v8i16 (load x)))); // into:; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))); // Where uses of the original load, i.e.:; // (v8i16 (load x)); // are replaced with:; // (v8i16 (truncate; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))))); //; // This combine is only applicable to illegal, but splittable, vectors.; // All legal types, and illegal non-vector types, are handled elsewhere.; // This combine is controlled by TargetLowering::isVectorLoadExtDesirable.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:167,Performance,load,load,167,"// fold (sext (load x)) to multiple smaller sextloads; same for zext.; // For example, on a target with legal v4i32, but illegal v8i32, turn:; // (v8i32 (sext (v8i16 (load x)))); // into:; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))); // Where uses of the original load, i.e.:; // (v8i16 (load x)); // are replaced with:; // (v8i16 (truncate; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))))); //; // This combine is only applicable to illegal, but splittable, vectors.; // All legal types, and illegal non-vector types, are handled elsewhere.; // This combine is controlled by TargetLowering::isVectorLoadExtDesirable.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:302,Performance,load,load,302,"// fold (sext (load x)) to multiple smaller sextloads; same for zext.; // For example, on a target with legal v4i32, but illegal v8i32, turn:; // (v8i32 (sext (v8i16 (load x)))); // into:; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))); // Where uses of the original load, i.e.:; // (v8i16 (load x)); // are replaced with:; // (v8i16 (truncate; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))))); //; // This combine is only applicable to illegal, but splittable, vectors.; // All legal types, and illegal non-vector types, are handled elsewhere.; // This combine is controlled by TargetLowering::isVectorLoadExtDesirable.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:326,Performance,load,load,326,"// fold (sext (load x)) to multiple smaller sextloads; same for zext.; // For example, on a target with legal v4i32, but illegal v8i32, turn:; // (v8i32 (sext (v8i16 (load x)))); // into:; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))); // Where uses of the original load, i.e.:; // (v8i16 (load x)); // are replaced with:; // (v8i16 (truncate; // (v8i32 (concat_vectors (v4i32 (sextload x)),; // (v4i32 (sextload (x + 16))))))); //; // This combine is only applicable to illegal, but splittable, vectors.; // All legal types, and illegal non-vector types, are handled elsewhere.; // This combine is controlled by TargetLowering::isVectorLoadExtDesirable.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Availability,down,down,40,// Try to split the vector types to get down to legal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify TF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Performance,load,load,32,// Replace uses of the original load (before extension); // with a truncate of the concatenated sextloaded vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,load,36,"// fold (zext (and/or/xor (shl/shr (load x), cst), cst)) ->; // (and/or/xor (shl/shr (zextload x), (zext cst)), (zext cst))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,load,load,3,// load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Testability,log,logic,31,"// If the shift op is SHL, the logic op must be AND, otherwise the result; // will be wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:306,Energy Efficiency,efficient,efficient,306,"/// If we're narrowing or widening the result of a vector select and the final; /// size is the same size as a setcc (compare) feeding the select, then try to; /// apply the cast operation to the select's operands because matching vector; /// sizes for a select condition and other operands should be more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,load,19,"// fold ([s|z]ext (load x)) -> ([s|z]ext (truncate ([s|z]extload x))); // Only generate vector extloads when 1) they're legal, and 2) they are; // deemed desirable by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,"// If the load value is used only by N, replace it via CombineTo N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,Usability,Simpl,SimplifySelectCC,117,"// setge X, C is canonicalized to setgt, so we do not need to match that; // pattern. The setlt sibling is folded in SimplifySelectCC() because it does; // not require the 'not' op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:124,Performance,optimiz,optimize,124,// On some architectures (such as SSE/NEON/etc) the SETCC result type is; // the same size as the compared operands. Try to optimize sext(setcc()); // if this is the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:148,Modifiability,extend,extend,148,"// If the desired elements are smaller or larger than the source; // elements, we can use a matching integer vector type and then; // truncate/sign extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Modifiability,extend,extended,78,// We have an unsupported narrow vector compare op that would be legal; // if extended to the destination type. See if the compare operands; // can be freely extended to the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:158,Modifiability,extend,extended,158,// We have an unsupported narrow vector compare op that would be legal; // if extended to the destination type. See if the compare operands; // can be freely extended to the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Modifiability,extend,extended,23,"// Match a simple, non-extended load that can be converted to a; // legal {z/s}ext-load.; // TODO: Allow widening of an existing {z/s}ext-load?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Performance,load,load,32,"// Match a simple, non-extended load that can be converted to a; // legal {z/s}ext-load.; // TODO: Allow widening of an existing {z/s}ext-load?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Performance,load,load,83,"// Match a simple, non-extended load that can be converted to a; // legal {z/s}ext-load.; // TODO: Allow widening of an existing {z/s}ext-load?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Performance,load,load,138,"// Match a simple, non-extended load that can be converted to a; // legal {z/s}ext-load.; // TODO: Allow widening of an existing {z/s}ext-load?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Usability,simpl,simple,11,"// Match a simple, non-extended load that can be converted to a; // legal {z/s}ext-load.; // TODO: Allow widening of an existing {z/s}ext-load?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Modifiability,extend,extends,82,// Non-chain users of this value must either be the setcc in this; // sequence or extends that can be folded into the new {z/s}ext-load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Performance,load,load,131,// Non-chain users of this value must either be the setcc in this; // sequence or extends that can be folded into the new {z/s}ext-load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Modifiability,Extend,ExtendUsesToFormExtLoad,116,// Extra users must have exactly the same cast we are about to create.; // TODO: This restriction could be eased if ExtendUsesToFormExtLoad(); // is enhanced similarly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:149,Modifiability,enhance,enhanced,149,// Extra users must have exactly the same cast we are about to create.; // TODO: This restriction could be eased if ExtendUsesToFormExtLoad(); // is enhanced similarly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,Integrability,depend,depending,87,"// sext(setcc x, y, cc) -> (select (setcc x, y, cc), T, 0); // Here, T can be 1 or -1, depending on the type of the setcc and; // getBooleanContents().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:330,Integrability,depend,depends,330,"// To determine the ""true"" side of the select, we need to know the high bit; // of the value returned by the setcc if it evaluates to true.; // If the type of the setcc is i1, then the true case of the select is just; // sext(i1 1), that is, -1.; // If the type of the setcc is larger (say, i8) then the value of the high; // bit depends on getBooleanContents(), so ask TLI for a real ""true"" value; // of the appropriate width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Performance,load,load,25,"// fold (sext (truncate (load x))) -> (sext (smaller load x)); // fold (sext (truncate (srl (load x), c))) -> (sext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,load,53,"// fold (sext (truncate (load x))) -> (sext (smaller load x)); // fold (sext (truncate (srl (load x), c))) -> (sext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Performance,load,load,93,"// fold (sext (truncate (load x))) -> (sext (smaller load x)); // fold (sext (truncate (srl (load x), c))) -> (sext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125,Performance,load,load,125,"// fold (sext (truncate (load x))) -> (sext (smaller load x)); // fold (sext (truncate (srl (load x), c))) -> (sext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Modifiability,extend,extended,52,"// See if the value being truncated is already sign extended. If so, just; // eliminate the trunc/sext pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,load,load,26,// Try to simplify (sext (load x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simplify,10,// Try to simplify (sext (load x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Performance,load,load,15,// fold (sext (load x)) to multiple smaller sextloads.; // Only on illegal but splittable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simplify,10,// Try to simplify (sext (sextload x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,load,load,27,"// fold (sext (and/or/xor (load x), cst)) ->; // (and/or/xor (sextload x), (sext cst))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Modifiability,extend,extend,23,// Eliminate this sign extend by doing a negation in the destination type:; // sext i32 (0 - (zext i8 X to i32)) to i64 --> 0 - (zext i8 X to i64),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Modifiability,extend,extend,23,// Eliminate this sign extend by doing a decrement in the destination type:; // sext i32 ((zext i8 X to i32) + (-1)) to i64 --> (zext i8 X to i64) + (-1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:71,Modifiability,extend,extended,71,"// fold sext (not i1 X) -> add (zext i1 X), -1; // TODO: This could be extended to handle bool vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Modifiability,extend,extending,13,"/// Given an extending node with a pop-count operand, if the target does not; /// support a pop-count in the narrow source type but does support it in the; /// destination type, widen the pop-count to the destination type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:132,Modifiability,extend,extend,132,"// If we have (zext (abs X)) where X is a type that will be promoted by type; // legalization, convert to (abs (sext X)). But don't extend past a legal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Availability,mask,mask,39,"// fold (zext (truncate x)) -> (and x, mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Performance,load,load,25,"// fold (zext (truncate (load x))) -> (zext (smaller load x)); // fold (zext (truncate (srl (load x), c))) -> (zext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,load,53,"// fold (zext (truncate (load x))) -> (zext (smaller load x)); // fold (zext (truncate (srl (load x), c))) -> (zext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Performance,load,load,93,"// fold (zext (truncate (load x))) -> (zext (smaller load x)); // fold (zext (truncate (srl (load x), c))) -> (zext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125,Performance,load,load,125,"// fold (zext (truncate (load x))) -> (zext (smaller load x)); // fold (zext (truncate (srl (load x), c))) -> (zext (smaller load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Availability,mask,mask,10,"// Try to mask before the extension to avoid having to generate a larger mask,; // possibly over several sub-vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Availability,mask,mask,73,"// Try to mask before the extension to avoid having to generate a larger mask,; // possibly over several sub-vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Safety,avoid,avoid,39,"// Try to mask before the extension to avoid having to generate a larger mask,; // possibly over several sub-vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Safety,safe,safely,10,// We may safely transfer the debug info describing the truncate node over; // to the equivalent and operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,load,load,26,// Try to simplify (zext (load x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simplify,10,// Try to simplify (zext (load x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Performance,load,load,15,// fold (zext (load x)) to multiple smaller zextloads.; // Only on illegal but splittable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,load,load,27,"// fold (zext (and/or/xor (load x), cst)) ->; // (and/or/xor (zextload x), (zext cst)); // Unless (and (load x) cst) will match as a zextload already and has; // additional users, or the zext is already free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:104,Performance,load,load,104,"// fold (zext (and/or/xor (load x), cst)) ->; // (and/or/xor (zextload x), (zext cst)); // Unless (and (load x) cst) will match as a zextload already and has; // additional users, or the zext is already free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,load,36,"// fold (zext (and/or/xor (shl/shr (load x), cst), cst)) ->; // (and/or/xor (shl/shr (zextload x), (zext cst)), (zext cst))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simplify,10,// Try to simplify (zext (zextload x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Modifiability,extend,extend,146,// If the desired elements are smaller or larger than the source; // elements we can use a matching integer vector type and then; // truncate/any extend followed by zext_in_reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Availability,Mask,MaskedValueIsZero,103,"// If the original shl may be shifting out bits, do not perform this; // transformation.; // TODO: Add MaskedValueIsZero check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Performance,perform,perform,56,"// If the original shl may be shifting out bits, do not perform this; // transformation.; // TODO: Add MaskedValueIsZero check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Performance,load,load,25,"// fold (aext (truncate (load x))) -> (aext (smaller load x)); // fold (aext (truncate (srl (load x), c))) -> (aext (small load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,load,53,"// fold (aext (truncate (load x))) -> (aext (smaller load x)); // fold (aext (truncate (srl (load x), c))) -> (aext (small load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Performance,load,load,93,"// fold (aext (truncate (load x))) -> (aext (smaller load x)); // fold (aext (truncate (srl (load x), c))) -> (aext (small load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,Performance,load,load,123,"// fold (aext (truncate (load x))) -> (aext (smaller load x)); // fold (aext (truncate (srl (load x), c))) -> (aext (small load (x+c/n)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Performance,load,load,15,"// fold (aext (load x)) -> (aext (truncate (extload x))); // None of the supported targets knows how to perform load and any_ext; // on vectors in one instruction, so attempt to fold to zext instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:104,Performance,perform,perform,104,"// fold (aext (load x)) -> (aext (truncate (extload x))); // None of the supported targets knows how to perform load and any_ext; // on vectors in one instruction, so attempt to fold to zext instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:112,Performance,load,load,112,"// fold (aext (load x)) -> (aext (truncate (extload x))); // None of the supported targets knows how to perform load and any_ext; // on vectors in one instruction, so attempt to fold to zext instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,load,load,26,// Try to simplify (zext (load x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simplify,10,// Try to simplify (zext (load x)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,"// If the load value is used only by N, replace it via CombineTo N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Modifiability,extend,extend,146,// If the desired elements are smaller or larger than the source; // elements we can use a matching integer vector type and then; // truncate/any extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Testability,assert,assert,9,"// fold (assert?ext (assert?ext x, vt), vt) -> (assert?ext x, vt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Testability,assert,assert,21,"// fold (assert?ext (assert?ext x, vt), vt) -> (assert?ext x, vt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Testability,assert,assert,48,"// fold (assert?ext (assert?ext x, vt), vt) -> (assert?ext x, vt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Testability,assert,assert,14,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Testability,assert,assert,32,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:67,Testability,assert,assert,67,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Testability,assert,asserting,81,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Testability,assert,asserted,107,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,Testability,assert,assert,178,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,Testability,assert,assert,190,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:205,Testability,assert,assert,205,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:241,Testability,assert,assert,241,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:265,Testability,assert,assert,265,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:280,Testability,assert,assert,280,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:316,Testability,assert,assert,316,"// We have an assert, truncate, assert sandwich. Make one stronger assert; // by asserting on the smallest asserted type to the larger source type.; // This eliminates the later assert:; // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN; // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Testability,Assert,AssertZext,15,"// If we have (AssertZext (truncate (AssertSext X, iX)), iY) and Y is smaller; // than X. Just move the AssertZext in front of the truncate and drop the; // AssertSExt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Testability,Assert,AssertSext,37,"// If we have (AssertZext (truncate (AssertSext X, iX)), iY) and Y is smaller; // than X. Just move the AssertZext in front of the truncate and drop the; // AssertSExt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:104,Testability,Assert,AssertZext,104,"// If we have (AssertZext (truncate (AssertSext X, iX)), iY) and Y is smaller; // than X. Just move the AssertZext in front of the truncate and drop the; // AssertSExt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,Testability,Assert,AssertSExt,157,"// If we have (AssertZext (truncate (AssertSext X, iX)), iY) and Y is smaller; // than X. Just move the AssertZext in front of the truncate and drop the; // AssertSExt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Testability,assert,assertalign,9,"// Fold (assertalign (assertalign x, AL0), AL1) ->; // (assertalign x, max(AL0, AL1))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Testability,assert,assertalign,22,"// Fold (assertalign (assertalign x, AL0), AL1) ->; // (assertalign x, max(AL0, AL1))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Testability,assert,assertalign,56,"// Fold (assertalign (assertalign x, AL0), AL1) ->; // (assertalign x, max(AL0, AL1))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:92,Availability,down,down,92,"// In rare cases, there are trivial arithmetic ops in source operands. Sink; // this assert down to source operands so that those arithmetic ops could be; // exposed to the DAG combining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:158,Security,expose,exposed,158,"// In rare cases, there are trivial arithmetic ops in source operands. Sink; // this assert down to source operands so that those arithmetic ops could be; // exposed to the DAG combining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:85,Testability,assert,assert,85,"// In rare cases, there are trivial arithmetic ops in source operands. Sink; // this assert down to source operands so that those arithmetic ops could be; // exposed to the DAG combining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Availability,mask,masked,39,"/// If the result of a load is shifted/masked/truncated to an effectively; /// narrower type, try to transform the load to a narrower type and/or; /// use an extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:158,Modifiability,extend,extending,158,"/// If the result of a load is shifted/masked/truncated to an effectively; /// narrower type, try to transform the load to a narrower type and/or; /// use an extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Performance,load,load,23,"/// If the result of a load is shifted/masked/truncated to an effectively; /// narrower type, try to transform the load to a narrower type and/or; /// use an extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:115,Performance,load,load,115,"/// If the result of a load is shifted/masked/truncated to an effectively; /// narrower type, try to transform the load to a narrower type and/or; /// use an extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:168,Performance,load,load,168,"/// If the result of a load is shifted/masked/truncated to an effectively; /// narrower type, try to transform the load to a narrower type and/or; /// use an extending load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,Performance,load,loads,46,// This transformation isn't valid for vector loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Modifiability,variab,variable,13,// The ShAmt variable is used to indicate that we've consumed a right; // shift. I.e. we want to narrow the width of the load by skipping to load the; // ShAmt least significant bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:121,Performance,load,load,121,// The ShAmt variable is used to indicate that we've consumed a right; // shift. I.e. we want to narrow the width of the load by skipping to load the; // ShAmt least significant bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:141,Performance,load,load,141,// The ShAmt variable is used to indicate that we've consumed a right; // shift. I.e. we want to narrow the width of the load by skipping to load the; // ShAmt least significant bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:71,Availability,mask,masked,71,"// A special case is when the least significant bits from the load are masked; // away, but using an AND rather than a right shift. HasShiftedOffset is used; // to indicate that the narrowed load should be left-shifted ShAmt bits to get; // the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Performance,load,load,62,"// A special case is when the least significant bits from the load are masked; // away, but using an AND rather than a right shift. HasShiftedOffset is used; // to indicate that the narrowed load should be left-shifted ShAmt bits to get; // the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:191,Performance,load,load,191,"// A special case is when the least significant bits from the load are masked; // away, but using an AND rather than a right shift. HasShiftedOffset is used; // to indicate that the narrowed load should be left-shifted ShAmt bits to get; // the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Modifiability,extend,extended,77,// Special case: SIGN_EXTEND_INREG is basically truncating to ExtVT then; // extended to VT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Modifiability,extend,extending,56,"// Another special-case: SRL/SRA is basically zero/sign-extending a narrower; // value, or it may be shifting a higher subword, half or byte into the; // lowest bits.; // Only handle shift with constant shift amount, and the shiftee must be a; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:247,Performance,load,load,247,"// Another special-case: SRL/SRA is basically zero/sign-extending a narrower; // value, or it may be shifting a higher subword, half or byte into the; // lowest bits.; // Only handle shift with constant shift amount, and the shiftee must be a; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,Performance,load,loaded,94,// If the shift amount is larger than the memory type then we're not; // accessing any of the loaded bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Security,access,accessing,73,// If the shift amount is larger than the memory type then we're not; // accessing any of the loaded bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Performance,load,load,15,"// If original load is a SEXTLOAD then we can't simply replace it by a; // ZEXTLOAD (we could potentially replace it by a more narrow SEXTLOAD; // followed by a ZEXT, but that is not handled at the moment). Similarly if; // the original load is a ZEXTLOAD and we want to use a SEXTLOAD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:237,Performance,load,load,237,"// If original load is a SEXTLOAD then we can't simply replace it by a; // ZEXTLOAD (we could potentially replace it by a more narrow SEXTLOAD; // followed by a ZEXT, but that is not handled at the moment). Similarly if; // the original load is a ZEXTLOAD and we want to use a SEXTLOAD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Usability,simpl,simply,48,"// If original load is a SEXTLOAD then we can't simply replace it by a; // ZEXTLOAD (we could potentially replace it by a more narrow SEXTLOAD; // followed by a ZEXT, but that is not handled at the moment). Similarly if; // the original load is a ZEXTLOAD and we want to use a SEXTLOAD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Availability,mask,mask,26,// An AND with a constant mask is the same as a truncate + zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Modifiability,extend,extend,64,// An AND with a constant mask is the same as a truncate + zero-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,Availability,mask,masking,190,"// In case Opc==SRL we've already prepared ExtVT/ExtType/ShAmt based on doing; // a right shift. Here we redo some of those checks, to possibly adjust the; // ExtVT even further based on ""a masking AND"". We could also end up here for; // other reasons (e.g. based on Opc==TRUNCATE) and that is why some checks; // need to be done here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Availability,mask,masking,138,// Bail out when the SRL has more than one use. This is done for historical; // (undocumented) reasons. Maybe intent was to guard the AND-masking below; // check below? And maybe it could be non-profitable to do the transform in; // case the SRL has multiple uses and we get here with Opc!=ISD::SRL?; // FIXME: Can't we just skip this check for the Opc==ISD::SRL case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Usability,undo,undocumented,81,// Bail out when the SRL has more than one use. This is done for historical; // (undocumented) reasons. Maybe intent was to guard the AND-masking below; // check below? And maybe it could be non-profitable to do the transform in; // case the SRL has multiple uses and we get here with Opc!=ISD::SRL?; // FIXME: Can't we just skip this check for the Opc==ISD::SRL case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:79,Performance,load,load,79,"// Only handle shift with constant shift amount, and the shiftee must be a; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Performance,load,loaded,93,// If the shift amount is larger than the input type then we're not; // accessing any of the loaded bytes. If the load was a zextload/extload; // then the result of the shift+trunc is zero/undef (handled elsewhere).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:114,Performance,load,load,114,// If the shift amount is larger than the input type then we're not; // accessing any of the loaded bytes. If the load was a zextload/extload; // then the result of the shift+trunc is zero/undef (handled elsewhere).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:72,Security,access,accessing,72,// If the shift amount is larger than the input type then we're not; // accessing any of the loaded bytes. If the load was a zextload/extload; // then the result of the shift+trunc is zero/undef (handled elsewhere).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Modifiability,extend,extend,51,"// Because a SRL must be assumed to *need* to zero-extend the high bits; // (as opposed to anyext the high bits), we can't combine the zextload; // lowering of SRL and an sextload.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,Performance,load,load,61,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Performance,load,load,108,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:170,Performance,load,load,170,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:249,Performance,load,load,249,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:303,Performance,load,load,303,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Security,access,accessed,36,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,load,14,// Narrow the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Availability,mask,masking,32,"// If the SRL is only used by a masking AND, we may be able to adjust; // the ExtVT to make the AND redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Availability,redundant,redundant,100,"// If the SRL is only used by a masking AND, we may be able to adjust; // the ExtVT to make the AND redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Safety,redund,redundant,100,"// If the SRL is only used by a masking AND, we may be able to adjust; // the ExtVT to make the AND redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Availability,mask,mask,10,"// If the mask is smaller, recompute the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,"// If the load is shifted left (and the result isn't shifted back right), we; // can fold a truncate through the shift. The typical scenario is that N; // points at a TRUNCATE here so the attempted fold is:; // (truncate (shl (load x), c))) -> (shl (narrow load x), c); // ShLeftAmt will indicate how much a narrowed load should be shifted left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:227,Performance,load,load,227,"// If the load is shifted left (and the result isn't shifted back right), we; // can fold a truncate through the shift. The typical scenario is that N; // points at a TRUNCATE here so the attempted fold is:; // (truncate (shl (load x), c))) -> (shl (narrow load x), c); // ShLeftAmt will indicate how much a narrowed load should be shifted left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:257,Performance,load,load,257,"// If the load is shifted left (and the result isn't shifted back right), we; // can fold a truncate through the shift. The typical scenario is that N; // points at a TRUNCATE here so the attempted fold is:; // (truncate (shl (load x), c))) -> (shl (narrow load x), c); // ShLeftAmt will indicate how much a narrowed load should be shifted left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:317,Performance,load,load,317,"// If the load is shifted left (and the result isn't shifted back right), we; // can fold a truncate through the shift. The typical scenario is that N; // points at a TRUNCATE here so the attempted fold is:; // (truncate (shl (load x), c))) -> (shl (narrow load x), c); // ShLeftAmt will indicate how much a narrowed load should be shifted left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Performance,load,load,25,"// If we haven't found a load, we can't narrow it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:88,Energy Efficiency,reduce,reduce,88,"// Reducing the width of a volatile load is illegal. For atomics, we may be; // able to reduce the width provided we never widen again. (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,load,36,"// Reducing the width of a volatile load is illegal. For atomics, we may be; // able to reduce the width provided we never widen again. (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Performance,load,load,40,// We need to adjust the pointer to the load by ShAmt bits in order to load; // the correct bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:71,Performance,load,load,71,// We need to adjust the pointer to the load by ShAmt bits in order to load; // the correct bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Integrability,wrap,wrap,35,"// The original load itself didn't wrap, so an offset within it doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,load,16,"// The original load itself didn't wrap, so an offset within it doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,load,19,// Replace the old load's chain with the new load's chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Performance,load,load,45,// Replace the old load's chain with the new load's chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Usability,simpl,simply,161,"// If the shift amount is as large as the result size (but, presumably,; // no larger than the source) then the useful bits of the result are; // zero; we can't simply return the shortened shift, because the result; // of that operation is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Availability,mask,mask,25,"// We're using a shifted mask, so the load now has an offset. This means; // that data has been loaded into the lower bytes than it would have been; // before, so we need to shl the loaded data into the correct position in the; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Performance,load,load,38,"// We're using a shifted mask, so the load now has an offset. This means; // that data has been loaded into the lower bytes than it would have been; // before, so we need to shl the loaded data into the correct position in the; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Performance,load,loaded,96,"// We're using a shifted mask, so the load now has an offset. This means; // that data has been loaded into the lower bytes than it would have been; // before, so we need to shl the loaded data into the correct position in the; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Performance,load,loaded,182,"// We're using a shifted mask, so the load now has an offset. This means; // that data has been loaded into the lower bytes than it would have been; // before, so we need to shl the loaded data into the correct position in the; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Performance,load,loaded,18,// Return the new loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Modifiability,extend,extended,32,"// If the input is already sign extended, just drop the extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:191,Modifiability,extend,extending,191,// fold (sext_in_reg (sext x)) -> (sext x); // fold (sext_in_reg (aext x)) -> (sext x); // if x is small enough or if we know that x has more than 1 sign bit and the; // sign_extend_inreg is extending from one of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:177,Modifiability,extend,extending,177,// fold (sext_in_reg (*_extend_vector_inreg x)) -> (sext_vector_inreg x); // if x is small enough or if we know that x has more than 1 sign bit and the; // sign_extend_inreg is extending from one of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Modifiability,extend,extending,58,// fold (sext_in_reg (zext x)) -> (sext x); // iff we are extending the source sign bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Performance,load,load,22,"// fold (sext_in_reg (load x)) -> (smaller sextload x); // fold (sext_in_reg (srl (load x), c)) -> (smaller sextload (x+c/evtbits))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Performance,load,load,83,"// fold (sext_in_reg (load x)) -> (smaller sextload x); // fold (sext_in_reg (srl (load x), c)) -> (smaller sextload (x+c/evtbits))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Modifiability,extend,extended,77,// We can turn this into an SRA iff the input to the SRL is already sign; // extended enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:208,Modifiability,extend,extends,208,"// fold (sext_inreg (extload x)) -> (sextload x); // If sextload is not supported by target, we can only do the combine when; // load has one use. Doing otherwise can block folding the extload with other; // extends that the target does support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:129,Performance,load,load,129,"// fold (sext_inreg (extload x)) -> (sextload x); // If sextload is not supported by target, we can only do the combine when; // load has one use. Doing otherwise can block folding the extload with other; // extends that the target does support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Performance,load,load,54,// fold (sext_inreg (zextload x)) -> (sextload x) iff load has one use,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Availability,mask,masked,82,// fold (sext_inreg (masked_load x)) -> (sext_masked_load x); // ignore it if the masked load is already sign extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:110,Modifiability,extend,extended,110,// fold (sext_inreg (masked_load x)) -> (sext_masked_load x); // ignore it if the masked load is already sign extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:89,Performance,load,load,89,// fold (sext_inreg (masked_load x)) -> (sext_masked_load x); // ignore it if the masked load is already sign extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Modifiability,extend,extending,35,// Profitability check: we must be extending exactly one of it's operands.; // FIXME: this is probably overly restrictive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Modifiability,extend,extend,60,"// if the source is smaller than the dest, we still need an extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,Modifiability,extend,extend,66,"// if the source and dest are the same type, we can drop both the extend; // and the truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:268,Performance,optimiz,optimization,268,"// Fold extract-and-trunc into a narrow extract. For example:; // i64 x = EXTRACT_VECTOR_ELT(v2i64 val, i32 1); // i32 y = TRUNCATE(i64 x); // -- becomes --; // v16i8 b = BITCAST (v2i64 val); // i8 x = EXTRACT_VECTOR_ELT(v16i8 b, i32 8); //; // Note: We only run this optimization after type legalization (which often; // creates this pattern) and before operation legalization after which; // we need to be more careful about the vector instructions that we generate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating illegal types if running after type legalizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,load,19,"// fold (truncate (load x)) -> (smaller load x); // fold (truncate (srl (load x), c)) -> (smaller load (x+c/evtbits))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Performance,load,load,40,"// fold (truncate (load x)) -> (smaller load x); // fold (truncate (srl (load x), c)) -> (smaller load (x+c/evtbits))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Performance,load,load,73,"// fold (truncate (load x)) -> (smaller load x); // fold (truncate (srl (load x), c)) -> (smaller load (x+c/evtbits))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:98,Performance,load,load,98,"// fold (truncate (load x)) -> (smaller load x); // fold (truncate (srl (load x), c)) -> (smaller load (x+c/evtbits))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Performance,load,loaded,77,// Handle the case where the truncated result is at least as wide as the; // loaded type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:188,Safety,avoid,avoid,188,"// TODO: We already restricted this to pre-legalization, but for vectors; // we are extra cautious to not create an unsupported operation.; // Target-specific changes are likely needed to avoid regressions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,load,16,"/// build_pair (load, load) -> load; /// if load locations are consecutive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Performance,load,load,22,"/// build_pair (load, load) -> load; /// if load locations are consecutive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Performance,load,load,31,"/// build_pair (load, load) -> load; /// if load locations are consecutive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,"/// build_pair (load, load) -> load; /// if load locations are consecutive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Performance,load,load,146,"// A BUILD_PAIR is always having the least significant part in elt 0 and the; // most significant part in elt 1. So when combining into one large load, we; // need to consider the endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,Testability,log,logic,97,"// If this is not a bitcast to an FP type or if the target doesn't have; // IEEE754-compliant FP logic, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Testability,log,logic,35,"// This needs to be the inverse of logic in foldSignChangeInBitcast.; // FIXME: I don't think looking for bitcast intrinsically makes sense, but; // removing this would require more changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:242,Integrability,depend,depending,242,"// If the input is a BUILD_VECTOR with all constant elements, fold this now.; // Only do this before legalize types, unless both types are integer and the; // scalar type is legal. Only do this before legalize ops, since the target; // maybe depending on the bitcast.; // First check to see if this is all constant.; // TODO: Support FP bitcasts after legalize types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Testability,log,logicop,15,"// fold (conv (logicop (conv x), (c))) -> (logicop x, (conv c)); // iff the current bitwise logicop type isn't legal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Testability,log,logicop,43,"// fold (conv (logicop (conv x), (c))) -> (logicop x, (conv c)); // iff the current bitwise logicop type isn't legal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:92,Testability,log,logicop,92,"// fold (conv (logicop (conv x), (c))) -> (logicop x, (conv c)); // iff the current bitwise logicop type isn't legal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Performance,load,load,15,// fold (conv (load x)) -> (load (conv*)x); // If the resultant load doesn't need a higher alignment than the original!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Performance,load,load,28,// fold (conv (load x)) -> (load (conv*)x); // If the resultant load doesn't need a higher alignment than the original!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Performance,load,load,64,// fold (conv (load x)) -> (load (conv*)x); // If the resultant load doesn't need a higher alignment than the original!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,load,10,"// If the load is volatile, we only want to change the load type if the; // resulting load is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,Performance,load,load,55,"// If the load is volatile, we only want to change the load type if the; // resulting load is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Performance,load,load,86,"// If the load is volatile, we only want to change the load type if the; // resulting load is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:154,Security,access,accesses,154,"// If the load is volatile, we only want to change the load type if the; // resulting load is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:273,Security,access,accesses,273,"// If the load is volatile, we only want to change the load type if the; // resulting load is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:425,Energy Efficiency,reduce,reduces,425,"// fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit)); //; // For ppc_fp128:; // fold (bitcast (fneg x)) ->; // flipbit = signbit; // (xor (bitcast x) (build_pair flipbit, flipbit)); //; // fold (bitcast (fabs x)) ->; // flipbit = (and (extract_element (bitcast x), 0), signbit); // (xor (bitcast x) (build_pair flipbit, flipbit)); // This often reduces constant pool loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:447,Performance,load,loads,447,"// fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit)); //; // For ppc_fp128:; // fold (bitcast (fneg x)) ->; // flipbit = signbit; // (xor (bitcast x) (build_pair flipbit, flipbit)); //; // fold (bitcast (fabs x)) ->; // flipbit = (and (extract_element (bitcast x), 0), signbit); // (xor (bitcast x) (build_pair flipbit, flipbit)); // This often reduces constant pool loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,"// bitconvert(build_pair(ld, ld)) -> ld iff load locations are consecutive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Deployability,update,updated,18,"// But, that also updated the use in the freeze we just created, thus; // creating a cycle in a DAG. Let's undo that by mutating the freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,Usability,undo,undo,107,"// But, that also updated the use in the freeze we just created, thus; // creating a cycle in a DAG. Let's undo that by mutating the freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Deployability,update,updated,32,"// The whole node may have been updated, so the value we were holding; // may no longer be valid. Re-fetch the operand we're `freeze`ing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Deployability,update,updated,50,"// Finally, recreate the node, it's operands were updated to use; // frozen operands, so we just need to use it's ""original"" operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Safety,avoid,avoid,58,"// Otherwise, we're growing or shrinking the elements. To avoid having to; // handle annoying details of growing/shrinking FP values, we convert them to; // int first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,Integrability,contract,contraction,34,// Returns true if floating point contraction is allowed on the FMUL-SDValue; // `N`,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Performance,perform,perform,11,/// Try to perform FMA combining on a given FADD node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Integrability,contract,contractable,26,"// If the addition is not contractable, do not combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Energy Efficiency,reduce,reduce,103,"// Folding fadd (fmul x, y), (fmul x, y) -> fma x, y, (fmul x, y) is never; // beneficial. It does not reduce latency. It increases register pressure. It; // replaces an fadd with an fma which is a more complex instruction, so is; // likely to have a larger encoding, use more functional units, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:110,Performance,latency,latency,110,"// Folding fadd (fmul x, y), (fmul x, y) -> fma x, y, (fmul x, y) is never; // beneficial. It does not reduce latency. It increases register pressure. It; // replaces an fadd with an fma which is a more complex instruction, so is; // likely to have a larger encoding, use more functional units, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Integrability,contract,contractable,27,// Is the node an FMUL and contractable either due to global flags or; // SDNodeFlags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Usability,simpl,simplified,60,// Replacing the inner FMul could cause the outer FMA to be simplified; // away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Performance,perform,perform,11,/// Try to perform FMA combining on a given FSUB node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Integrability,contract,contractable,29,"// If the subtraction is not contractable, do not combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Integrability,contract,contractable,27,// Is the node an FMUL and contractable either due to global flags or; // SDNodeFlags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:265,Integrability,contract,contract,265,"// fold (fsub (fpext (fneg (fmul, x, y))), z); // -> (fneg (fma (fpext x), (fpext y), z)); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:291,Safety,unsafe,unsafe-fp-math,291,"// fold (fsub (fpext (fneg (fmul, x, y))), z); // -> (fneg (fma (fpext x), (fpext y), z)); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:265,Integrability,contract,contract,265,"// fold (fsub (fneg (fpext (fmul, x, y))), z); // -> (fneg (fma (fpext x)), (fpext y), z); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:291,Safety,unsafe,unsafe-fp-math,291,"// fold (fsub (fneg (fpext (fmul, x, y))), z); // -> (fneg (fma (fpext x)), (fpext y), z); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Performance,perform,perform,11,"/// Try to perform FMA combining on a given FMUL node based on the distributive; /// law x * (y + 1) = x * y + x and variants thereof (commuted versions,; /// subtraction instead of addition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Safety,unsafe,unsafe,7,"// If 'unsafe math' or reassoc and nsz, fold lots of things.; // TODO: break out portions of the transformations below for which Unsafe is; // considered and which do not require both nsz and reassoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:129,Safety,Unsafe,Unsafe,129,"// If 'unsafe math' or reassoc and nsz, fold lots of things.; // TODO: break out portions of the transformations below for which Unsafe is; // considered and which do not require both nsz and reassoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:98,Safety,safe,safe,98,// We can fold chains of FADD's of the same value into multiplications.; // This transform is not safe in general because we are reducing the number; // of rounding steps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Safety,unsafe,unsafe-fp-math,10,// enable-unsafe-fp-math; // FADD -> FMA combines:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:266,Energy Efficiency,power,power,266,"// Transform IEEE Floats:; // (fmul C, (uitofp Pow2)); // -> (bitcast_to_FP (add (bitcast_to_INT C), Log2(Pow2) << mantissa)); // (fdiv C, (uitofp Pow2)); // -> (bitcast_to_FP (sub (bitcast_to_INT C), Log2(Pow2) << mantissa)); //; // The rationale is fmul/fdiv by a power of 2 is just change the exponent, so; // there is no need for more than an add/sub.; //; // This is valid under the following circumstances:; // 1) We are dealing with IEEE floats; // 2) C is normal; // 3) The fmul/fdiv add/sub will not go outside of min/max exponent bounds.; // TODO: Much of this could also be used for generating `ldexp` on targets the; // prefer it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Perform,Perform,3,// Perform actual transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,// Avoid an infinite loop by making sure that N00 is not a constant; // (the inner multiply has not been constant folded yet).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Safety,Unsafe,UnsafeFPMath,49,// FIXME: use fast math flags instead of Options.UnsafeFPMath,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Usability,simpl,simplified,36,// Skip X/sqrt(X) that has not been simplified to sqrt(X) yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,optimiz,optimization,33,// This division is eligible for optimization only if global unsafe math; // is enabled or if this division allows reciprocal formation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,Safety,unsafe,unsafe,61,// This division is eligible for optimization only if global unsafe math; // is enabled or if this division allows reciprocal formation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Deployability,configurat,configuration,91,"// Do not optimize out type conversion of f128 type yet.; // For some targets like x86_64, configuration is changed to keep one f128; // value in one SSE register, but instruction selection cannot handle; // FCOPYSIGN on SSE registers yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Modifiability,config,configuration,91,"// Do not optimize out type conversion of f128 type yet.; // For some targets like x86_64, configuration is changed to keep one f128; // value in one SSE register, but instruction selection cannot handle; // FCOPYSIGN on SSE registers yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,optimiz,optimize,10,"// Do not optimize out type conversion of f128 type yet.; // For some targets like x86_64, configuration is changed to keep one f128; // value in one SSE register, but instruction selection cannot handle; // FCOPYSIGN on SSE registers yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:217,Energy Efficiency,power,power-of-,217,"// Try to convert x ** (1/4) and x ** (3/4) into square roots.; // x ** (1/2) is canonicalized to sqrt, so we do not bother with that case.; // TODO: This could be extended (using a target hook) to handle smaller; // power-of-2 fractional exponents.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:164,Modifiability,extend,extended,164,"// Try to convert x ** (1/4) and x ** (3/4) into square roots.; // x ** (1/2) is canonicalized to sqrt, so we do not bother with that case.; // TODO: This could be extended (using a target hook) to handle smaller; // power-of-2 fractional exponents.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Performance,optimiz,optimizations,12,"// The next optimizations are desirable only if SELECT_CC can be lowered.; // fold (sint_to_fp (setcc x, y, cc)) -> (select (setcc x, y, cc), -1.0, 0.0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:263,Integrability,depend,depend,263,"// We can safely assume the conversion won't overflow the output range,; // because (for example) (uint8_t)18293.f is undefined behavior.; // Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Safety,safe,safely,10,"// We can safely assume the conversion won't overflow the output range,; // because (for example) (uint8_t)18293.f is undefined behavior.; // Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:354,Safety,safe,safe,354,"// We can safely assume the conversion won't overflow the output range,; // because (for example) (uint8_t)18293.f is undefined behavior.; // Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Avoid,Avoid,3,// Avoid folding legal fp_rounds into non-legal ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,load,16,// fold (fpext (load x)) -> (fpext (fptrunc (extload x))),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Safety,unsafe,unsafe,22,"// -(X-Y) -> (Y-X) is unsafe because when X==Y, -0.0 != +0.0; // FIXME: This is duplicated in getNegatibleCost, but getNegatibleCost doesn't; // know it was called from a context with a nsz flag if the input fsub does; // not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:204,Availability,avail,available,204,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // fold a brcond with a setcc condition into a BR_CC node if BR_CC is legal; // on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:287,Deployability,update,update,287,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // fold a brcond with a setcc condition into a BR_CC node if BR_CC is legal; // on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:168,Usability,Simpl,SimplifyCFG,168,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // fold a brcond with a setcc condition into a BR_CC node if BR_CC is legal; // on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:439,Testability,TEST,TEST,439,"// Match this pattern so that we can generate simpler code:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and i32 %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // This applies only when the AND constant value has one bit set and the; // SRL constant is equal to the log2 of the AND constant. The back-end is; // smart enough to convert the result into a TEST/JMP sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,Usability,simpl,simpler,46,"// Match this pattern so that we can generate simpler code:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and i32 %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // This applies only when the AND constant value has one bit set and the; // SRL constant is equal to the log2 of the AND constant. The back-end is; // smart enough to convert the result into a TEST/JMP sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Usability,Simpl,SimplifiedSetCC,63,"// Because we may call this on a speculatively constructed; // SimplifiedSetCC Node, we need to simplify this node first.; // Ideally this should be folded into SimplifySetCC and not; // here. For now, grab a handle to N so we don't lose it from; // replacements interal to the visit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Usability,simpl,simplify,96,"// Because we may call this on a speculatively constructed; // SimplifiedSetCC Node, we need to simplify this node first.; // Ideally this should be folded into SimplifySetCC and not; // here. For now, grab a handle to N so we don't lose it from; // replacements interal to the visit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Usability,Simpl,SimplifySetCC,161,"// Because we may call this on a speculatively constructed; // SimplifiedSetCC Node, we need to simplify this node first.; // Ideally this should be folded into SimplifySetCC and not; // here. For now, grab a handle to N so we don't lose it from; // replacements interal to the visit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,Usability,simpl,simplification,6,// No simplification done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:8,Usability,simpl,simplified,8,// Node simplified. Try simplifying again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,Usability,simpl,simplifying,24,// Node simplified. Try simplifying again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:204,Availability,avail,available,204,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // Use SimplifySetCC to simplify SETCC's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:287,Deployability,update,update,287,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // Use SimplifySetCC to simplify SETCC's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:168,Usability,Simpl,SimplifyCFG,168,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // Use SimplifySetCC to simplify SETCC's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:351,Usability,Simpl,SimplifySetCC,351,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // Use SimplifySetCC to simplify SETCC's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:368,Usability,simpl,simplify,368,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // Use SimplifySetCC to simplify SETCC's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Usability,simpl,simpler,13,// fold to a simpler setcc,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Performance,load,load,18,"/// Try turning a load/store into a pre-indexed load/store when the base; /// pointer is an add or subtract and it has other uses besides the load/store.; /// After the transformation, the new indexed load/store has effectively folded; /// the add/subtract in and all of its other uses are redirected to the; /// new load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Performance,load,load,48,"/// Try turning a load/store into a pre-indexed load/store when the base; /// pointer is an add or subtract and it has other uses besides the load/store.; /// After the transformation, the new indexed load/store has effectively folded; /// the add/subtract in and all of its other uses are redirected to the; /// new load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,Performance,load,load,142,"/// Try turning a load/store into a pre-indexed load/store when the base; /// pointer is an add or subtract and it has other uses besides the load/store.; /// After the transformation, the new indexed load/store has effectively folded; /// the add/subtract in and all of its other uses are redirected to the; /// new load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:201,Performance,load,load,201,"/// Try turning a load/store into a pre-indexed load/store when the base; /// pointer is an add or subtract and it has other uses besides the load/store.; /// After the transformation, the new indexed load/store has effectively folded; /// the add/subtract in and all of its other uses are redirected to the; /// new load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:317,Performance,load,load,317,"/// Try turning a load/store into a pre-indexed load/store when the base; /// pointer is an add or subtract and it has other uses besides the load/store.; /// After the transformation, the new indexed load/store has effectively folded; /// the add/subtract in and all of its other uses are redirected to the; /// new load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Modifiability,variab,variable,91,// Backends without true r+i pre-indexed forms may need to pass a; // constant base with a variable offset so that constant coercion; // will work with the patterns in canonical form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,load,load,26,// Don't create a indexed load / store with zero offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Performance,load,load,37,// Try turning it into a pre-indexed load / store except when:; // 1) The new base ptr is a frame index.; // 2) If N is a store and the new base ptr is either the same as or is a; // predecessor of the value being stored.; // 3) Another use of old base ptr is a predecessor of N. If ptr is folded; // that would create a cycle.; // 4) All uses are load / store ops that use it as old base ptr.; // Check #1. Preinc'ing a frame index would require copying the stack pointer; // (plus the implicit offset) to a register to preinc anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:348,Performance,load,load,348,// Try turning it into a pre-indexed load / store except when:; // 1) The new base ptr is a frame index.; // 2) If N is a store and the new base ptr is either the same as or is a; // predecessor of the value being stored.; // 3) Another use of old base ptr is a predecessor of N. If ptr is folded; // that would create a cycle.; // 4) All uses are load / store ops that use it as old base ptr.; // Check #1. Preinc'ing a frame index would require copying the stack pointer; // (plus the implicit offset) to a register to preinc anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Cache,Caches,3,// Caches for hasPredecessorHelper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:128,Safety,avoid,avoid,128,"// If the offset is a constant, there may be other adds of constants that; // can be folded with this one. We should do this to avoid having to keep; // a copy of the original base pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Deployability,update,updated,45,// Replace other uses of BasePtr that can be updated to use Ptr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:154,Performance,load,load,154,"// We need to replace ptr0 in the following expression:; // x0 * offset0 + y0 * ptr0 = t0; // knowing that; // x1 * offset1 + y1 * ptr0 = t1 (the indexed load/store); //; // where x0, x1, y0 and y1 in {-1, 1} are given by the types of the; // indexed load/store and the expression that needs to be re-written.; //; // Therefore, we have:; // t0 = (x0 * offset0 - x1 * y0 * y1 *offset1) + (y0 * y1) * t1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:251,Performance,load,load,251,"// We need to replace ptr0 in the following expression:; // x0 * offset0 + y0 * ptr0 = t0; // knowing that; // x1 * offset1 + y1 * ptr0 = t1 (the indexed load/store); //; // where x0, x1, y0 and y1 in {-1, 1} are given by the types of the; // indexed load/store and the expression that needs to be re-written.; //; // Therefore, we have:; // t0 = (x0 * offset0 - x1 * y0 * y1 *offset1) + (y0 * y1) * t1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Deployability,update,updated,44,// Replace the uses of Ptr with uses of the updated base value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,load,load,26,// Don't create a indexed load / store with zero offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Performance,perform,perform,42,// No if there's a later user which could perform the index instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Performance,load,load,23,"// If all the uses are load / store addresses, then don't do the; // transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Performance,load,load,38,"// Try turning it into a post-indexed load / store except when; // 1) All uses are load / store ops that use it as base ptr (and; // it may be folded as addressing mmode).; // 2) Op must be independent of N, i.e. Op is neither a predecessor; // nor a successor of N. Otherwise, if Op is folded that would; // create a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Performance,load,load,83,"// Try turning it into a post-indexed load / store except when; // 1) All uses are load / store ops that use it as base ptr (and; // it may be folded as addressing mmode).; // 2) Op must be independent of N, i.e. Op is neither a predecessor; // nor a successor of N. Otherwise, if Op is folded that would; // create a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,/// Try to combine a load/store with a add/sub of the base pointer node into a; /// post-indexed load/store. The transformation folded the add/subtract into the; /// new indexed load/store effectively and all of its uses are redirected to the; /// new load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,Performance,load,load,97,/// Try to combine a load/store with a add/sub of the base pointer node into a; /// post-indexed load/store. The transformation folded the add/subtract into the; /// new indexed load/store effectively and all of its uses are redirected to the; /// new load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,Performance,load,load,178,/// Try to combine a load/store with a add/sub of the base pointer node into a; /// post-indexed load/store. The transformation folded the add/subtract into the; /// new indexed load/store effectively and all of its uses are redirected to the; /// new load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:252,Performance,load,load,252,/// Try to combine a load/store with a add/sub of the base pointer node into a; /// post-indexed load/store. The transformation folded the add/subtract into the; /// new indexed load/store effectively and all of its uses are redirected to the; /// new load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Deployability,update,updated,44,// Replace the uses of Use with uses of the updated base value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Performance,load,load,41,"// Some backends use TargetConstants for load offsets, but don't expect; // TargetConstants in general ADD nodes. We can convert these constants into; // regular Constants (if the constant is not opaque).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Performance,load,load,81,"// There are two cases to consider here:; // 1. The store is fixed width and the load is scalable. In this case we; // don't know at compile time if the store completely envelops the load; // so we abandon the optimisation.; // 2. The store is scalable and the load is fixed width. We could; // potentially support a limited number of cases here, but there has been; // no cost-benefit analysis to prove it's worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:89,Performance,scalab,scalable,89,"// There are two cases to consider here:; // 1. The store is fixed width and the load is scalable. In this case we; // don't know at compile time if the store completely envelops the load; // so we abandon the optimisation.; // 2. The store is scalable and the load is fixed width. We could; // potentially support a limited number of cases here, but there has been; // no cost-benefit analysis to prove it's worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:183,Performance,load,load,183,"// There are two cases to consider here:; // 1. The store is fixed width and the load is scalable. In this case we; // don't know at compile time if the store completely envelops the load; // so we abandon the optimisation.; // 2. The store is scalable and the load is fixed width. We could; // potentially support a limited number of cases here, but there has been; // no cost-benefit analysis to prove it's worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:244,Performance,scalab,scalable,244,"// There are two cases to consider here:; // 1. The store is fixed width and the load is scalable. In this case we; // don't know at compile time if the store completely envelops the load; // so we abandon the optimisation.; // 2. The store is scalable and the load is fixed width. We could; // potentially support a limited number of cases here, but there has been; // no cost-benefit analysis to prove it's worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:261,Performance,load,load,261,"// There are two cases to consider here:; // 1. The store is fixed width and the load is scalable. In this case we; // don't know at compile time if the store completely envelops the load; // so we abandon the optimisation.; // 2. The store is scalable and the load is fixed width. We could; // potentially support a limited number of cases here, but there has been; // no cost-benefit analysis to prove it's worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,scalab,scalable,26,"// If we are dealing with scalable vectors on a big endian platform the; // calculation of offsets below becomes trickier, since we do not know at; // compile time the absolute size of the vector. Until we've done more; // analysis on big-endian platforms it seems better to bail out for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Performance,load,loaded,103,// Normalize for Endianness. After this Offset=0 will denote that the least; // significant bit in the loaded value maps to the least significant bit in; // the stored value). With Offset=n (for n > 0) the loaded value starts at the; // n:th least significant byte of the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:206,Performance,load,loaded,206,// Normalize for Endianness. After this Offset=0 will denote that the least; // significant bit in the loaded value maps to the least significant bit in; // the stored value). With Offset=n (for n > 0) the loaded value starts at the; // n:th least significant byte of the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,Performance,load,loaded,55,// Check that the stored value cover all bits that are loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:110,Performance,load,loads,110,// Cannot handle opaque target constants and we must respect the user's; // request not to split indexes from loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Availability,mask,masked,37,// Memory as copy space (potentially masked).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simple,3,// Simple case: Direct non-truncating forwarding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,Availability,mask,mask,55,// Can we model the truncate and extension with an and mask?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Availability,Mask,Mask,3,// Mask to size of LDMemType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,Availability,failure,failure,6,"// On failure, cleanup dead nodes we may have created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Deployability,update,updated,82,"// If load is not volatile and there are no uses of the loaded value (and; // the updated indexed value in case of indexed loads), change uses of the; // chain value into uses of the chain input (i.e. delete the dead load).; // TODO: Allow this for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,Performance,load,load,6,"// If load is not volatile and there are no uses of the loaded value (and; // the updated indexed value in case of indexed loads), change uses of the; // chain value into uses of the chain input (i.e. delete the dead load).; // TODO: Allow this for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Performance,load,loaded,56,"// If load is not volatile and there are no uses of the loaded value (and; // the updated indexed value in case of indexed loads), change uses of the; // chain value into uses of the chain input (i.e. delete the dead load).; // TODO: Allow this for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,Performance,load,loads,123,"// If load is not volatile and there are no uses of the loaded value (and; // the updated indexed value in case of indexed loads), change uses of the; // chain value into uses of the chain input (i.e. delete the dead load).; // TODO: Allow this for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:217,Performance,load,load,217,"// If load is not volatile and there are no uses of the loaded value (and; // the updated indexed value in case of indexed loads), change uses of the; // chain value into uses of the chain input (i.e. delete the dead load).; // TODO: Allow this for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,Performance,load,loads,13,// Unindexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:84,Performance,load,load,84,"// It's not safe to use the two value CombineTo variant here. e.g.; // v1, chain2 = load chain1, loc; // v2, chain3 = load chain2, loc; // v3 = add v2, c; // Now we replace use of chain2 with chain1. This makes the second load; // isomorphic to the one we are deleting, and thus makes this load live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:118,Performance,load,load,118,"// It's not safe to use the two value CombineTo variant here. e.g.; // v1, chain2 = load chain1, loc; // v2, chain3 = load chain2, loc; // v3 = add v2, c; // Now we replace use of chain2 with chain1. This makes the second load; // isomorphic to the one we are deleting, and thus makes this load live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:222,Performance,load,load,222,"// It's not safe to use the two value CombineTo variant here. e.g.; // v1, chain2 = load chain1, loc; // v2, chain3 = load chain2, loc; // v3 = add v2, c; // Now we replace use of chain2 with chain1. This makes the second load; // isomorphic to the one we are deleting, and thus makes this load live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:290,Performance,load,load,290,"// It's not safe to use the two value CombineTo variant here. e.g.; // v1, chain2 = load chain1, loc; // v2, chain3 = load chain2, loc; // v3 = add v2, c; // Now we replace use of chain2 with chain1. This makes the second load; // isomorphic to the one we are deleting, and thus makes this load live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Safety,safe,safe,12,"// It's not safe to use the two value CombineTo variant here. e.g.; // v1, chain2 = load chain1, loc; // v2, chain3 = load chain2, loc; // v3 = add v2, c; // Now we replace use of chain2 with chain1. This makes the second load; // isomorphic to the one we are deleting, and thus makes this load live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Performance,load,loads,11,// Indexed loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Performance,load,load,11,"// If this load has an opaque TargetConstant offset, then we cannot split; // the indexing into an add/sub directly (that TargetConstant may not be; // valid for a different type of node, and we cannot convert an opaque; // target constant into a regular constant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Performance,load,loads,59,// Try to fold the base pointer arithmetic into subsequent loads and; // stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Performance,load,load,11,"// If this load is directly stored, replace the load value with the stored; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Performance,load,load,48,"// If this load is directly stored, replace the load value with the stored; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Performance,load,load,54,// Try to infer better alignment information than the load already has.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Integrability,depend,dependency,29,// Replace the chain to void dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,// Replace uses with load result and token factor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,load,36,// Try transforming N to an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,loads,36,// Try to slice up N to more direct loads if the slices are mapped to; // different register banks or pairing can take place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Performance,load,load,37,"/// Helper structure used to slice a load in smaller loads.; /// Basically a slice is obtained from the following sequence:; /// Origin = load Ty1, Base; /// Shift = srl Ty1 Origin, CstTy Amount; /// Inst = trunc Shift to Ty2; ///; /// Then, it will be rewritten into:; /// Slice = load SliceTy, Base + SliceOffset; /// [Inst = zext Slice to Ty2], only if SliceTy <> Ty2; ///; /// SliceTy is deduced from the number of bits that are actually used to; /// build Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,loads,53,"/// Helper structure used to slice a load in smaller loads.; /// Basically a slice is obtained from the following sequence:; /// Origin = load Ty1, Base; /// Shift = srl Ty1 Origin, CstTy Amount; /// Inst = trunc Shift to Ty2; ///; /// Then, it will be rewritten into:; /// Slice = load SliceTy, Base + SliceOffset; /// [Inst = zext Slice to Ty2], only if SliceTy <> Ty2; ///; /// SliceTy is deduced from the number of bits that are actually used to; /// build Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Performance,load,load,138,"/// Helper structure used to slice a load in smaller loads.; /// Basically a slice is obtained from the following sequence:; /// Origin = load Ty1, Base; /// Shift = srl Ty1 Origin, CstTy Amount; /// Inst = trunc Shift to Ty2; ///; /// Then, it will be rewritten into:; /// Slice = load SliceTy, Base + SliceOffset; /// [Inst = zext Slice to Ty2], only if SliceTy <> Ty2; ///; /// SliceTy is deduced from the number of bits that are actually used to; /// build Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:282,Performance,load,load,282,"/// Helper structure used to slice a load in smaller loads.; /// Basically a slice is obtained from the following sequence:; /// Origin = load Ty1, Base; /// Shift = srl Ty1 Origin, CstTy Amount; /// Inst = trunc Shift to Ty2; ///; /// Then, it will be rewritten into:; /// Slice = load SliceTy, Base + SliceOffset; /// [Inst = zext Slice to Ty2], only if SliceTy <> Ty2; ///; /// SliceTy is deduced from the number of bits that are actually used to; /// build Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Performance,optimiz,optimizing,11,/// Are we optimizing for code size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Performance,load,load,182,/// Account for slicing gain in the current cost.; /// Slicing provide a few gains like removing a shift or a; /// truncate. This method allows to grow the cost of the original; /// load with the gain from this slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,load,loads,58,// Assume cross register banks copies are as expensive as loads.; // FIXME: Do we want some more target hooks?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Performance,optimiz,optimizing,17,"// Unless we are optimizing for code size, consider the; // expensive operation first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,load,16,// The original load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Performance,load,load,52,// The right shift amount in bits from the original load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:88,Modifiability,extend,extend,88,// Reproduce the trunc(lshr) sequence:; // - Start from the truncated value.; // - Zero extend to the desired bit width.; // - Shift left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,loaded,36,/// Get the size of the slice to be loaded in bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,load,loaded,30,/// Get the type that will be loaded for this slice.; /// Note: This may not be the final type for the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Performance,load,load,29,/// Get the alignment of the load used for this slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Performance,load,load,27,"// Offsets are for indexed load only, we do not handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Performance,load,load,18,// Check that the load is legal for this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Performance,load,loading,59,"// If Offset is bigger than TySizeInBytes, it means we are loading all; // zeros. This should have been optimized before in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:104,Performance,optimiz,optimized,104,"// If Offset is bigger than TySizeInBytes, it means we are loading all; // zeros. This should have been optimized before in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Performance,load,load,45,/// Generate the sequence of instructions to load the slice; /// represented by this object and redirect the uses of this slice to; /// this new sequence of instructions.; /// \pre this->Inst && this->Origin are valid Instructions and this; /// object passed the legal check: LoadedSlice::isLegal returned true.; /// \return The last instruction of the sequence used to load the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:276,Performance,Load,LoadedSlice,276,/// Generate the sequence of instructions to load the slice; /// represented by this object and redirect the uses of this slice to; /// this new sequence of instructions.; /// \pre this->Inst && this->Origin are valid Instructions and this; /// object passed the legal check: LoadedSlice::isLegal returned true.; /// \return The last instruction of the sequence used to load the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:370,Performance,load,load,370,/// Generate the sequence of instructions to load the slice; /// represented by this object and redirect the uses of this slice to; /// this new sequence of instructions.; /// \pre this->Inst && this->Origin are valid Instructions and this; /// object passed the legal check: LoadedSlice::isLegal returned true.; /// \return The last instruction of the sequence used to load the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,load,loaded,26,// Create the type of the loaded slice according to its size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,load,14,// Create the load for the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,Modifiability,extend,extend,117,"// If the final type is not the same as the loaded type, this means that; // we have to pad with zero. Create a zero extend for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,loaded,44,"// If the final type is not the same as the loaded type, this means that; // we have to pad with zero. Create a zero extend for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,Performance,load,load,102,"/// Check if this slice can be merged with an expensive cross register; /// bank copy. E.g.,; /// i = load i32; /// f = bitcast i32 i to float",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,Performance,perform,perform,34,"// At this point, we know that we perform a cross-register-bank copy.; // Check if it is expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Performance,load,load,39,// Check if it will be merged with the load.; // 1. Check the alignment / fast memory access constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Security,access,access,86,// Check if it will be merged with the load.; // 1. Check the alignment / fast memory access constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,// 2. Check that the load is a legal operation for that type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,Performance,load,loaded,137,/// Check whether or not \p First and \p Second are next to each other; /// in memory. This means that there is no hole between the bits loaded; /// by \p First and the bits loaded by \p Second.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:174,Performance,load,loaded,174,/// Check whether or not \p First and \p Second are next to each other; /// in memory. This means that there is no hole between the bits loaded; /// by \p First and the bits loaded by \p Second.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:172,Performance,load,loads,172,/// Adjust the \p GlobalLSCost according to the target; /// paring capabilities and the layout of the slices.; /// \pre \p GlobalLSCost should account for at least as many loads as; /// there is in the slices in \p LoadedSlices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:215,Performance,Load,LoadedSlices,215,/// Adjust the \p GlobalLSCost according to the target; /// paring capabilities and the layout of the slices.; /// \pre \p GlobalLSCost should account for at least as many loads as; /// there is in the slices in \p LoadedSlices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Performance,load,load,103,// First (resp. Second) is the first (resp. Second) potentially candidate; // to be placed in a paired load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Performance,load,loads,39,// Check if the target supplies paired loads for this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,loads,19,// Check that both loads are next to each other in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,Load,LoadedSlice,44,"/// Check the profitability of all involved LoadedSlice.; /// Currently, it is considered profitable if there is exactly two; /// involved slices (1) which are (2) next to each other in memory, and; /// whose cost (\see LoadedSlice::Cost) is smaller than the original load (3).; ///; /// Note: The order of the elements in \p LoadedSlices may be modified, but not; /// the elements themselves.; ///; /// FIXME: When the cost model will be mature enough, we can relax; /// constraints (1) and (2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:220,Performance,Load,LoadedSlice,220,"/// Check the profitability of all involved LoadedSlice.; /// Currently, it is considered profitable if there is exactly two; /// involved slices (1) which are (2) next to each other in memory, and; /// whose cost (\see LoadedSlice::Cost) is smaller than the original load (3).; ///; /// Note: The order of the elements in \p LoadedSlices may be modified, but not; /// the elements themselves.; ///; /// FIXME: When the cost model will be mature enough, we can relax; /// constraints (1) and (2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:268,Performance,load,load,268,"/// Check the profitability of all involved LoadedSlice.; /// Currently, it is considered profitable if there is exactly two; /// involved slices (1) which are (2) next to each other in memory, and; /// whose cost (\see LoadedSlice::Cost) is smaller than the original load (3).; ///; /// Note: The order of the elements in \p LoadedSlices may be modified, but not; /// the elements themselves.; ///; /// FIXME: When the cost model will be mature enough, we can relax; /// constraints (1) and (2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:326,Performance,Load,LoadedSlices,326,"/// Check the profitability of all involved LoadedSlice.; /// Currently, it is considered profitable if there is exactly two; /// involved slices (1) which are (2) next to each other in memory, and; /// whose cost (\see LoadedSlice::Cost) is smaller than the original load (3).; ///; /// Note: The order of the elements in \p LoadedSlices may be modified, but not; /// the elements themselves.; ///; /// FIXME: When the cost model will be mature enough, we can relax; /// constraints (1) and (2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,load,33,// The original code has one big load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Deployability,configurat,configuration,35,// Account as cost in the original configuration the gain obtained; // with the current slices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Modifiability,config,configuration,35,// Account as cost in the original configuration the gain obtained; // with the current slices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,load,33,"// If the target supports paired load, adjust the cost accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Performance,load,load,17,"/// If the given load, \p LI, is used only by trunc or trunc(lshr); /// operations, split it in the various pieces being extracted.; ///; /// This sort of thing is introduced by SROA.; /// This slicing takes care not to insert overlapping loads.; /// \pre LI is a simple load (i.e., not an atomic or volatile load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:239,Performance,load,loads,239,"/// If the given load, \p LI, is used only by trunc or trunc(lshr); /// operations, split it in the various pieces being extracted.; ///; /// This sort of thing is introduced by SROA.; /// This slicing takes care not to insert overlapping loads.; /// \pre LI is a simple load (i.e., not an atomic or volatile load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:271,Performance,load,load,271,"/// If the given load, \p LI, is used only by trunc or trunc(lshr); /// operations, split it in the various pieces being extracted.; ///; /// This sort of thing is introduced by SROA.; /// This slicing takes care not to insert overlapping loads.; /// \pre LI is a simple load (i.e., not an atomic or volatile load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:309,Performance,load,load,309,"/// If the given load, \p LI, is used only by trunc or trunc(lshr); /// operations, split it in the various pieces being extracted.; ///; /// This sort of thing is introduced by SROA.; /// This slicing takes care not to insert overlapping loads.; /// \pre LI is a simple load (i.e., not an atomic or volatile load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:264,Usability,simpl,simple,264,"/// If the given load, \p LI, is used only by trunc or trunc(lshr); /// operations, split it in the various pieces being extracted.; ///; /// This sort of thing is introduced by SROA.; /// This slicing takes care not to insert overlapping loads.; /// \pre LI is a simple load (i.e., not an atomic or volatile load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Performance,load,load,31,"// The algorithm to split up a load of a scalable vector into individual; // elements currently requires knowing the length of the loaded type,; // so will need adjusting to work on scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Performance,scalab,scalable,41,"// The algorithm to split up a load of a scalable vector into individual; // elements currently requires knowing the length of the loaded type,; // so will need adjusting to work on scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Performance,load,loaded,131,"// The algorithm to split up a load of a scalable vector into individual; // elements currently requires knowing the length of the loaded type,; // so will need adjusting to work on scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,Performance,scalab,scalable,182,"// The algorithm to split up a load of a scalable vector into individual; // elements currently requires knowing the length of the loaded type,; // so will need adjusting to work on scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Safety,detect,detect,38,"// Keep track of already used bits to detect overlapping values.; // In that case, we will just abort the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Safety,abort,abort,96,"// Keep track of already used bits to detect overlapping values.; // In that case, we will just abort the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Performance,load,load,17,"// Check if this load is used as several smaller chunks of bits.; // Basically, look for uses in trunc or trunc(lshr) and record a new chain; // of computation for each trunc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,Energy Efficiency,power,power,35,"// The width of the type must be a power of 2 and greater than 8-bits.; // Otherwise the load cannot be represented in LLVM IR.; // Moreover, if we shifted with a non-8-bits multiple, the slice; // will be across several bytes. We do not support that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:89,Performance,load,load,89,"// The width of the type must be a power of 2 and greater than 8-bits.; // Otherwise the load cannot be represented in LLVM IR.; // Moreover, if we shifted with a non-8-bits multiple, the slice; // will be across several bytes. We do not support that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Deployability,Update,Update,3,// Update the bits used globally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Abort,Abort,3,// Abort slicing if it does not seem to be profitable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite each chain to use an independent load.; // By construction, each chain can be represented by a unique load.; // Prepare the argument for the new token factor for all the slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,"// Rewrite each chain to use an independent load.; // By construction, each chain can be represented by a unique load.; // Prepare the argument for the new token factor for all the slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:113,Performance,load,load,113,"// Rewrite each chain to use an independent load.; // By construction, each chain can be represented by a unique load.; // Prepare the argument for the new token factor for all the slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:140,Availability,mask,masked,140,"/// Check to see if V is (and load (ptr), imm), where the load is having; /// specific bytes cleared out. If so, return the byte size being masked out; /// and the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,load,load,30,"/// Check to see if V is (and load (ptr), imm), where the load is having; /// specific bytes cleared out. If so, return the byte size being masked out; /// and the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,load,load,58,"/// Check to see if V is (and load (ptr), imm), where the load is having; /// specific bytes cleared out. If so, return the byte size being masked out; /// and the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Usability,clear,cleared,93,"/// Check to see if V is (and load (ptr), imm), where the load is having; /// specific bytes cleared out. If so, return the byte size being masked out; /// and the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Usability,simpl,simple,48,// Not from same pointer.; // This only handles simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Availability,mask,mask,22,// Check the constant mask. Invert it so that the bits being masked out are; // 0 and the bits being kept are 1. Use getSExtValue so that leading bits; // follow the sign bit for uniformity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,Availability,mask,masked,61,// Check the constant mask. Invert it so that the bits being masked out are; // 0 and the bits being kept are 1. Use getSExtValue so that leading bits; // follow the sign bit for uniformity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Availability,mask,mask,12,"// All zero mask.; // See if we have a continuous run of bits. If so, we have 0*1+0*",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Deployability,continuous,continuous,39,"// All zero mask.; // See if we have a continuous run of bits. If so, we have 0*1+0*",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Availability,down,down,20,// Adjust NotMaskLZ down to be from the actual size of the int instead of i64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Availability,mask,mask,11,"// All one mask, or 5-byte mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,Availability,mask,mask,27,"// All one mask, or 5-byte mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Availability,mask,mask,53,// Verify that the first bit starts at a multiple of mask so that the access; // is aligned the same as the access width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:70,Security,access,access,70,// Verify that the first bit starts at a multiple of mask so that the access; // is aligned the same as the access width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Security,access,access,108,// Verify that the first bit starts at a multiple of mask so that the access; // is aligned the same as the access width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Performance,load,load,59,"// For narrowing to be valid, it must be the case that the load the; // immediately preceding memory operation before the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Integrability,depend,dependencies,51,// LD has only 1 chain use so they are no indirect dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Availability,Mask,MaskInfo,81,"/// Check to see if IVal is something that provides a value as specified by; /// MaskInfo. If so, replace the specified store with a narrower store of; /// truncated IVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,Availability,mask,masked,55,"// Check to see if IVal is all zeros in the part being masked in by the 'or'; // that uses this. If not, this is not a replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Availability,down,down,116,"// Okay, we can do this! Replace the 'St' store with a store of IVal that is; // shifted by ByteShift and truncated down to NumBytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Security,access,access,64,// Figure out the offset for the store and the alignment of the access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Availability,down,down,12,// Truncate down to the new size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,Performance,load,load,25,"/// Look for sequence of load / op / store where op is one of 'or', 'xor', and; /// 'and' of immediates. If 'op' is only touching some of the loaded bits, try; /// narrowing the load and store if it would end up being a win for performance; /// or code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,Performance,load,loaded,142,"/// Look for sequence of load / op / store where op is one of 'or', 'xor', and; /// 'and' of immediates. If 'op' is only touching some of the loaded bits, try; /// narrowing the load and store if it would end up being a win for performance; /// or code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,Performance,load,load,178,"/// Look for sequence of load / op / store where op is one of 'or', 'xor', and; /// 'and' of immediates. If 'op' is only touching some of the loaded bits, try; /// narrowing the load and store if it would end up being a win for performance; /// or code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:228,Performance,perform,performance,228,"/// Look for sequence of load / op / store where op is one of 'or', 'xor', and; /// 'and' of immediates. If 'op' is only touching some of the loaded bits, try; /// narrowing the load and store if it would end up being a win for performance; /// or code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Availability,mask,mask,91,"// If this is ""store (or X, Y), P"" and X is ""(and (load P), cst)"", where cst; // is a byte mask indicating a consecutive number of bytes, check to see if; // Y is known to provide just those bytes. If so, we try to replace the; // load + replace + store sequence with a single (narrower) store, which makes; // the load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Performance,load,load,51,"// If this is ""store (or X, Y), P"" and X is ""(and (load P), cst)"", where cst; // is a byte mask indicating a consecutive number of bytes, check to see if; // Y is known to provide just those bytes. If so, we try to replace the; // load + replace + store sequence with a single (narrower) store, which makes; // the load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:231,Performance,load,load,231,"// If this is ""store (or X, Y), P"" and X is ""(and (load P), cst)"", where cst; // is a byte mask indicating a consecutive number of bytes, check to see if; // Y is known to provide just those bytes. If so, we try to replace the; // load + replace + store sequence with a single (narrower) store, which makes; // the load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:315,Performance,load,load,315,"// If this is ""store (or X, Y), P"" and X is ""(and (load P), cst)"", where cst; // is a byte mask indicating a consecutive number of bytes, check to see if; // Y is known to provide just those bytes. If so, we try to replace the; // load + replace + store sequence with a single (narrower) store, which makes; // the load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,Performance,load,load,34,// Find the type to narrow it the load / op / store to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Performance,load,load,43,"// The narrowing should be profitable, the load/store operation should be; // legal (or custom) and the store size should be equal to the NewVT width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Performance,load,load,78,"// For big endian targets, we need to adjust the offset to the pointer to; // load the correct bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Performance,load,load,31,"/// For a given floating point load / store pair, if the load value isn't used; /// by any other operations, then consider transforming the pair to integer; /// load / store operations if the target deems the transformation profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,Performance,load,load,57,"/// For a given floating point load / store pair, if the load value isn't used; /// by any other operations, then consider transforming the pair to integer; /// load / store operations if the target deems the transformation profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,Performance,load,load,161,"/// For a given floating point load / store pair, if the load value isn't used; /// by any other operations, then consider transforming the pair to integer; /// load / store operations if the target deems the transformation profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Performance,scalab,scalable,29,// We don't know the size of scalable types at compile time so we cannot; // create an integer of the equivalent size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Usability,clear,clear,7,// Not clear how to truncate FP values.; // TODO: Handle truncation of build_vector constants,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Performance,Load,Load,18,// Create the new Load and Store operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Performance,load,loadbaseptr,12,// Match on loadbaseptr if relevant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Load,Load,3,// Load and store should be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Load,Loads,3,// Loads must only have one use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Performance,Load,Load,7,// The Load's Base Ptr must also match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Load,Loads,3,// Loads must only have one use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Performance,load,loads,22,// Don't mix temporal loads with non-temporal loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,Performance,load,loads,46,// Don't mix temporal loads with non-temporal loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:110,Integrability,depend,dependence,110,// Check if the pair of StoreNode and the RootNode already bail out many; // times which is over the limit in dependence check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:129,Availability,down,down,129,"// We looking for a root node which is an ancestor to all mergable; // stores. We search up through a load, to our root and then down; // through all children. For instance we will find Store{1,2,3} if; // St is Store1, Store2. or Store3 where the root is not a load; // which always true for nonvolatile ops. TODO: Expand; // the search to find all valid candidates through multiple layers of loads.; //; // Root; // |-------|-------|; // Load Load Store3; // | |; // Store1 Store2; //; // FIXME: We should be able to climb and; // descend TokenFactors to find candidates as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:384,Modifiability,layers,layers,384,"// We looking for a root node which is an ancestor to all mergable; // stores. We search up through a load, to our root and then down; // through all children. For instance we will find Store{1,2,3} if; // St is Store1, Store2. or Store3 where the root is not a load; // which always true for nonvolatile ops. TODO: Expand; // the search to find all valid candidates through multiple layers of loads.; //; // Root; // |-------|-------|; // Load Load Store3; // | |; // Store1 Store2; //; // FIXME: We should be able to climb and; // descend TokenFactors to find candidates as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,Performance,load,load,102,"// We looking for a root node which is an ancestor to all mergable; // stores. We search up through a load, to our root and then down; // through all children. For instance we will find Store{1,2,3} if; // St is Store1, Store2. or Store3 where the root is not a load; // which always true for nonvolatile ops. TODO: Expand; // the search to find all valid candidates through multiple layers of loads.; //; // Root; // |-------|-------|; // Load Load Store3; // | |; // Store1 Store2; //; // FIXME: We should be able to climb and; // descend TokenFactors to find candidates as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:262,Performance,load,load,262,"// We looking for a root node which is an ancestor to all mergable; // stores. We search up through a load, to our root and then down; // through all children. For instance we will find Store{1,2,3} if; // St is Store1, Store2. or Store3 where the root is not a load; // which always true for nonvolatile ops. TODO: Expand; // the search to find all valid candidates through multiple layers of loads.; //; // Root; // |-------|-------|; // Load Load Store3; // | |; // Store1 Store2; //; // FIXME: We should be able to climb and; // descend TokenFactors to find candidates as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:394,Performance,load,loads,394,"// We looking for a root node which is an ancestor to all mergable; // stores. We search up through a load, to our root and then down; // through all children. For instance we will find Store{1,2,3} if; // St is Store1, Store2. or Store3 where the root is not a load; // which always true for nonvolatile ops. TODO: Expand; // the search to find all valid candidates through multiple layers of loads.; //; // Root; // |-------|-------|; // Load Load Store3; // | |; // Store1 Store2; //; // FIXME: We should be able to climb and; // descend TokenFactors to find candidates as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:440,Performance,Load,Load,440,"// We looking for a root node which is an ancestor to all mergable; // stores. We search up through a load, to our root and then down; // through all children. For instance we will find Store{1,2,3} if; // St is Store1, Store2. or Store3 where the root is not a load; // which always true for nonvolatile ops. TODO: Expand; // the search to find all valid candidates through multiple layers of loads.; //; // Root; // |-------|-------|; // Load Load Store3; // | |; // Store1 Store2; //; // FIXME: We should be able to climb and; // descend TokenFactors to find candidates as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:445,Performance,Load,Load,445,"// We looking for a root node which is an ancestor to all mergable; // stores. We search up through a load, to our root and then down; // through all children. For instance we will find Store{1,2,3} if; // St is Store1, Store2. or Store3 where the root is not a load; // which always true for nonvolatile ops. TODO: Expand; // the search to find all valid candidates through multiple layers of loads.; //; // Root; // |-------|-------|; // Load Load Store3; // | |; // Store1 Store2; //; // FIXME: We should be able to climb and; // descend TokenFactors to find candidates as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:8,Availability,down,down,8,// walk down chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Integrability,depend,depend,21,// Check stores that depend on the root (e.g. Store 3 in the chart above).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108,Integrability,depend,depend,108,// We need to check that merging these stores does not cause a loop in the; // DAG. Any store candidate may depend on another candidate indirectly through; // its operands. Check in parallel by searching up from operands of candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:205,Usability,simpl,simplfication,205,// FIXME: We should be able to truncate a full search of; // predecessors by doing a BFS and keeping tabs the originating; // stores from which worklist nodes come from in a similar way to; // TokenFactor simplfication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Integrability,depend,dependencies,147,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:193,Integrability,depend,dependency,193,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:266,Integrability,depend,depends,266,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:321,Integrability,depend,dependencies,321,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:209,Performance,load,load,209,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:255,Performance,load,load,255,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:508,Performance,load,load,508,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Performance,load,load,12,// Look for load nodes which are used by the stored values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,loads,19,"// Find acceptable loads. Loads need to have the same chain (token factor),; // must not be zext, volatile, indexed, and they must be consecutive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,Load,Loads,26,"// Find acceptable loads. Loads need to have the same chain (token factor),; // must not be zext, volatile, indexed, and they must be consecutive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,load,14,"// If we have load/store pair instructions and we only have two values,; // don't bother merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,load,loads,10,"// If the loads are reversed, see if we can rotate the halves into place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Modifiability,variab,variables,109,// Scan the memory operations on the chain and find the first; // non-consecutive load memory address. These variables hold the index in; // the store node array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,Performance,load,load,82,// Scan the memory operations on the chain and find the first; // non-consecutive load memory address. These variables hold the index in; // the store node array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:8,Modifiability,variab,variable,8,// This variable refers to the size and not index in the array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,Performance,load,loads,7,// All loads must share the same chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Modifiability,variab,variables,38,// We add +1 here because the LastXXX variables refer to location while; // the NumElem refers to array/index size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:313,Performance,load,load,313,// We know that candidate stores are in order and of correct; // shape. While there is no mergeable sequence from the; // beginning one may start later in the sequence. The only; // reason a merge of size N could have failed where another of; // the same size would not have is if the alignment or either; // the load or store has improved. Drop as many candidates as we; // can here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Performance,load,load,54,// Find if it is better to use vectors or integers to load and store; // to memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,loads,14,"// The merged loads are required to have the same incoming chain, so; // using the first's chain is acceptable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loads,33,// Transfer chain users from old loads to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Performance,load,load,50,// Transfer chain users from old loads to the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Modifiability,Extend,Extend,9,"// TODO: Extend this function to merge stores of scalable vectors.; // (i.e. two <vscale x 8 x i8> stores can be merged to one <vscale x 16 x i8>; // store since we know <vscale x 16 x i8> is exactly twice as large as; // <vscale x 8 x i8>). Until then, bail out for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Performance,scalab,scalable,49,"// TODO: Extend this function to merge stores of scalable vectors.; // (i.e. two <vscale x 8 x i8> stores can be merged to one <vscale x 16 x i8>; // store since we know <vscale x 16 x i8> is exactly twice as large as; // <vscale x 8 x i8>). Until then, bail out for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:267,Performance,scalab,scalable,267,"// TODO: Extend this function to merge stores of scalable vectors.; // (i.e. two <vscale x 8 x i8> stores can be merged to one <vscale x 16 x i8>; // store since we know <vscale x 16 x i8> is exactly twice as large as; // <vscale x 8 x i8>). Until then, bail out for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,Performance,load,loads,66,"// Do not bother looking at stored values that are not constants, loads, or; // extracted vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Integrability,depend,dependency,30,// Replace the chain to avoid dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,Safety,avoid,avoid,24,// Replace the chain to avoid dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,load,load,30,"// (store (insert_vector_elt (load p), x, i), p) -> (store x, p+offset); //; // If a store of a load with an element inserted into it has no other; // uses in between the chain, then we can consider the vector store; // dead and replace it with just the single scalar element store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Performance,load,load,96,"// (store (insert_vector_elt (load p), x, i), p) -> (store x, p+offset); //; // If a store of a load with an element inserted into it has no other; // uses in between the chain, then we can consider the vector store; // dead and replace it with just the single scalar element store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Availability,recover,recover,49,// If the offset is a known constant then try to recover the pointer; // info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Safety,recover,recover,49,// If the offset is a known constant then try to recover the pointer; // info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,Security,access,accesses,157,"// If the store is volatile, we only want to change the store type if the; // resulting store is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.; // TODO: May be able to relax for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:276,Security,access,accesses,276,"// If the store is volatile, we only want to change the store type if the; // resulting store is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.; // TODO: May be able to relax for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Performance,load,load,42,// Try transforming a pair floating point load / store ops to integer; // load / store ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:74,Performance,load,load,74,// Try transforming a pair floating point load / store ops to integer; // load / store ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,Usability,simpl,simplify,17,"// See if we can simplify the operation with SimplifyDemandedBits, which; // only works if the value has a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Usability,Simpl,SimplifyDemandedBits,45,"// See if we can simplify the operation with SimplifyDemandedBits, which; // only works if the value has a single use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:112,Usability,Simpl,SimplifyDemandedBits,112,"// Re-visit the store if anything changed and the store hasn't been merged; // with another node (N is deleted) SimplifyDemandedBits will add Value's; // node back to the worklist if necessary, but we also need to re-visit; // the Store node itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Usability,simpl,simplify,28,"// Otherwise, see if we can simplify the input to this truncstore with; // knowledge that only the low bits are being used. For example:; // ""truncstore (or (shl x, 8), y), i8"" -> ""truncstore y, i8""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Usability,simpl,simplify,56,"// If we're storing a truncated constant, see if we can simplify it.; // TODO: Move this to targetShrinkDemandedConstant?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,load,load,16,"// If this is a load followed by a store to the same location, then the store; // is dead/noop. Peek through any truncates if canCombineTruncStore failed.; // TODO: Add big-endian truncate support with test coverage.; // TODO: Can relax for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:202,Testability,test,test,202,"// If this is a load followed by a store to the same location, then the store; // is dead/noop. Peek through any truncates if canCombineTruncStore failed.; // TODO: Add big-endian truncate support with test coverage.; // TODO: Can relax for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Performance,load,load,47,"// There can't be any side effects between the load and store, such as; // a call or store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Performance,load,loads,36,// Try scalarizing vector stores of loads where we only change one element,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,scalab,scalable,58,"// If we consider two stores and one smaller in size is a scalable; // vector type and another one a bigger size store with a fixed type,; // then we could not allow the scalable store removal because we don't; // know its final size in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:170,Performance,scalab,scalable,170,"// If we consider two stores and one smaller in size is a scalable; // vector type and another one a bigger size store with a fixed type,; // then we could not allow the scalable store removal because we don't; // know its final size in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Performance,perform,perform,10,"// Always perform this optimization before types are legal. If the target; // prefers, also try this after legalization to catch stores that were created; // by intrinsics or other nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Performance,optimiz,optimization,23,"// Always perform this optimization before types are legal. If the target; // prefers, also try this after legalization to catch stores that were created; // by intrinsics or other nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:145,Safety,avoid,avoid,145,"// Turn 'store float 1.0, Ptr' -> 'store int 0x12345678, Ptr'; //; // Make sure to do this only after attempting to merge stores in order to; // avoid changing the types of some subset of stores due to visit order,; // preventing their merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,scalab,scalable,19,"// The bounds of a scalable store are not known until runtime, so this; // store cannot be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:965,Usability,simpl,simple,965,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficent to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Security,access,accesses,37,// Can't change the number of memory accesses for a volatile store or break; // atomicity for an atomic one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Modifiability,extend,extended,22,// Lo and Hi are zero-extended from int with size less equal than 32; // to i64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Availability,Mask,Mask,93,"// Merge an insertion into an existing shuffle:; // (insert_vector_elt (vector_shuffle X, Y, Mask),; // .(extract_vector_elt X, N), InsIndex); // --> (vector_shuffle X, Y, NewMask); // and variations where shuffle operands may be CONCAT_VECTORS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:168,Performance,perform,perform,168,"// We explore the inputs of the shuffle in order to see if we find the; // source of the extract_vector_elt. If so, we can use it to modify the; // shuffle rather than perform an insert_vector_elt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:170,Availability,Mask,Mask,170,"// Convert a disguised subvector insertion into a shuffle:; // insert_vector_elt V, (bitcast X from vector type), IdxC -->; // bitcast(shuffle (bitcast V), (extended X), Mask); // Note: We do not use an insert_subvector node because that requires a; // legal subvector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,Modifiability,extend,extended,157,"// Convert a disguised subvector insertion into a shuffle:; // insert_vector_elt V, (bitcast X from vector type), IdxC -->; // bitcast(shuffle (bitcast V), (extended X), Mask); // Note: We do not use an insert_subvector node because that requires a; // legal subvector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Availability,mask,mask,28,"// Step 1: Create a shuffle mask that implements this insert operation. The; // vector that we are inserting into will be operand 0 of the shuffle, so; // those elements are just 'i'. The inserted subvector is in the first; // positions of operand 1 of the shuffle. Example:; // insert v4i32 V, (v2i16 X), 2 --> shuffle v8i16 V', X', {0,1,2,3,8,9,6,7}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Performance,load,load,26,"// Combine insert(shuffle(load, <u,0,1,2>), load, 0) into a single load if; // possible and the new load will be quick. We use more loads but less shuffles; // and inserts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,"// Combine insert(shuffle(load, <u,0,1,2>), load, 0) into a single load if; // possible and the new load will be quick. We use more loads but less shuffles; // and inserts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:67,Performance,load,load,67,"// Combine insert(shuffle(load, <u,0,1,2>), load, 0) into a single load if; // possible and the new load will be quick. We use more loads but less shuffles; // and inserts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,Performance,load,load,100,"// Combine insert(shuffle(load, <u,0,1,2>), load, 0) into a single load if; // possible and the new load will be quick. We use more loads but less shuffles; // and inserts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:132,Performance,load,loads,132,"// Combine insert(shuffle(load, <u,0,1,2>), load, 0) into a single load if; // possible and the new load will be quick. We use more loads but less shuffles; // and inserts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Availability,mask,mask,31,"// Look for a shuffle with the mask u,0,1,2,3,4,5,6 or 1,2,3,4,5,6,7,u; // depending on the InsIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,Integrability,depend,depending,75,"// Look for a shuffle with the mask u,0,1,2,3,4,5,6 or 1,2,3,4,5,6,7,u; // depending on the InsIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Modifiability,extend,extend,30,// We optionally skip over an extend so long as both loads are extended in the; // same way from the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,Modifiability,extend,extended,63,// We optionally skip over an extend so long as both loads are extended in the; // same way from the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Performance,load,loads,53,// We optionally skip over an extend so long as both loads are extended in the; // same way from the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,Deployability,continuous,continuous,66,// Check that the offset between the pointers to produce a single continuous; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Performance,load,load,81,// Check that the offset between the pointers to produce a single continuous; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,load,load,30,// And that the new unaligned load will be fast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,// Calculate the new Ptr and create the new load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Availability,redundant,redundant,10,// Remove redundant insertions:; // (insert_vector_elt x (extract_vector_elt x idx) idx) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Safety,redund,redundant,10,// Remove redundant insertions:; // (insert_vector_elt x (extract_vector_elt x idx) idx) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Modifiability,variab,variable,14,"// If this is variable insert to undef vector, it might be better to splat:; // inselt undef, InVal, EltNo --> build_vector < InVal, InVal, ... >",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:92,Availability,mask,mask,92,"// VECTOR_SHUFFLE - if all the operands match the shuffle's sources,; // update the shuffle mask (and second operand if we started with unary; // shuffle) and create a new legal shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,Deployability,update,update,73,"// VECTOR_SHUFFLE - if all the operands match the shuffle's sources,; // update the shuffle mask (and second operand if we started with unary; // shuffle) and create a new legal shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Availability,mask,mask,59,"// If all insertions are zero value, try to convert to AND mask.; // TODO: Do this for -1 with OR mask?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:98,Availability,mask,mask,98,"// If all insertions are zero value, try to convert to AND mask.; // TODO: Do this for -1 with OR mask?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Performance,load,load,116,// If the vector element type is not a multiple of a byte then we are unable; // to correctly compute an address to load only the extracted element as a; // scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:136,Modifiability,variab,variable,136,// Discard the pointer info except the address space because the memory; // operand can't represent this new access since the offset is variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,Security,access,access,109,// Discard the pointer info except the address space because the memory; // operand can't represent this new access since the offset is variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,Performance,load,load,29,// We are replacing a vector load with a scalar load. The new load must have; // identical memory op ordering to the original.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Performance,load,load,48,// We are replacing a vector load with a scalar load. The new load must have; // identical memory op ordering to the original.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,Performance,load,load,62,// We are replacing a vector load with a scalar load. The new load must have; // identical memory op ordering to the original.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,Modifiability,extend,extending,76,"// If the result type of vextract is wider than the load, then issue an; // extending load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,Performance,load,load,52,"// If the result type of vextract is wider than the load, then issue an; // extending load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Performance,load,load,86,"// If the result type of vextract is wider than the load, then issue an; // extending load instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:95,Testability,log,logic,95,/// Transform a vector binary operation into a scalar binary operation by moving; /// the math/logic after an extract element of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Safety,avoid,avoid,23,// Targets may want to avoid this to prevent an expensive register transfer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:374,Availability,recover,recover,374,"// Given a ISD::EXTRACT_VECTOR_ELT, which is a glorified bit sequence extract,; // recursively analyse all of it's users. and try to model themselves as; // bit sequence extractions. If all of them agree on the new, narrower element; // type, and all of them can be modelled as ISD::EXTRACT_VECTOR_ELT's of that; // new element type, do so now.; // This is mainly useful to recover from legalization that scalarized; // the vector as wide elements, but tries to rebuild it with narrower elements.; //; // Some more nodes could be modelled if that helps cover interesting patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:374,Safety,recover,recover,374,"// Given a ISD::EXTRACT_VECTOR_ELT, which is a glorified bit sequence extract,; // recursively analyse all of it's users. and try to model themselves as; // bit sequence extractions. If all of them agree on the new, narrower element; // type, and all of them can be modelled as ISD::EXTRACT_VECTOR_ELT's of that; // new element type, do so now.; // This is mainly useful to recover from legalization that scalarized; // the vector as wide elements, but tries to rebuild it with narrower elements.; //; // Some more nodes could be modelled if that helps cover interesting patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,Performance,perform,perform,6,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may cause legalizaton cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,optimiz,optimization,19,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may cause legalizaton cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:133,Performance,Perform,Performing,133,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may cause legalizaton cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:149,Performance,optimiz,optimization,149,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may cause legalizaton cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Usability,simpl,simply,14,"// Truncation simply means we keep position, but extract less bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Testability,Log,Logical,3,"// Logical right-shift means that we start extraction later,; // but stop it at the same position we did previously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:186,Modifiability,extend,extend,186,"// Check if the result type doesn't match the inserted element type.; // The inserted element and extracted element may have mismatched bitwidth.; // As a result, EXTRACT_VECTOR_ELT may extend or truncate the extracted vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Performance,scalab,scalable,147,"// All the code from this point onwards assumes fixed width vectors, but it's; // possible that some of the combinations could be made to work for scalable; // vectors too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:198,Energy Efficiency,reduce,reduce,198,"// TODO: These transforms should not require the 'hasOneUse' restriction, but; // there are regressions on multiple targets without it. We can end up with a; // mess of scalar and vector code if we reduce only part of the DAG to scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,Integrability,depend,depend,46,// The vector index of the LSBs of the source depend on the endian-ness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:179,Modifiability,extend,extend,179,"// An extract element return value type can be wider than its vector; // operand element type. In that case, the high bits are undefined, so; // it's possible that we may need to extend rather than truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:88,Performance,perform,perform,88,"// Transform: (EXTRACT_VECTOR_ELT( VECTOR_SHUFFLE )) -> EXTRACT_VECTOR_ELT.; // We only perform this optimization before the op legalization phase because; // we may introduce new vector instructions which are not backed by TD; // patterns. For example on AVX, extracting elements from a wide vector; // without using extract_subvector. However, if we can find an underlying; // scalar value, then we can always use that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:101,Performance,optimiz,optimization,101,"// Transform: (EXTRACT_VECTOR_ELT( VECTOR_SHUFFLE )) -> EXTRACT_VECTOR_ELT.; // We only perform this optimization before the op legalization phase because; // we may introduce new vector instructions which are not backed by TD; // patterns. For example on AVX, extracting elements from a wide vector; // without using extract_subvector. However, if we can find an underlying; // scalar value, then we can always use that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:69,Usability,simpl,simplify,69,// If only EXTRACT_VECTOR_ELT nodes use the source vector we can; // simplify it based on the (valid) extraction indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,Usability,simpl,simplified,6,"// We simplified the vector operand of this extract element. If this; // extract is not dead, visit it again so it is folded properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,Usability,simpl,simplified,6,"// We simplified the vector operand of this extract element. If this; // extract is not dead, visit it again so it is folded properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Performance,load,loaded,60,"// Everything under here is trying to match an extract of a loaded value.; // If the result of load has to be truncated, then it's not necessarily; // profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:95,Performance,load,load,95,"// Everything under here is trying to match an extract of a loaded value.; // If the result of load has to be truncated, then it's not necessarily; // profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,// Don't duplicate a load with other uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,load,load,19,"// extract (vector load $addr), i --> load $addr + i * size",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Performance,load,load,38,"// extract (vector load $addr), i --> load $addr + i * size",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Perform,Perform,3,// Perform only after legalization to ensure build_vector / vector_shuffle; // optimizations have already been done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:79,Performance,optimiz,optimizations,79,// Perform only after legalization to ensure build_vector / vector_shuffle; // optimizations have already been done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Performance,load,load,20,"// (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size); // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size); // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Performance,load,load,44,"// (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size); // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size); // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Performance,load,load,93,"// (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size); // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size); // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:118,Performance,load,load,118,"// (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size); // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size); // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:167,Performance,load,load,167,"// (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size); // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size); // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:203,Performance,load,load,203,"// (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size); // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size); // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,// Don't duplicate a load with other uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,Performance,load,load,30,"// (vextract (vector_shuffle (load $addr), v2, <1, u, u, u>), 1); // =>; // (load $addr+1*size); // Don't duplicate a load with other uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Performance,load,load,77,"// (vextract (vector_shuffle (load $addr), v2, <1, u, u, u>), 1); // =>; // (load $addr+1*size); // Don't duplicate a load with other uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:118,Performance,load,load,118,"// (vextract (vector_shuffle (load $addr), v2, <1, u, u, u>), 1); // =>; // (load $addr+1*size); // Don't duplicate a load with other uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Availability,mask,mask,86,"// If the bit convert changed the number of elements, it is unsafe; // to examine the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Safety,unsafe,unsafe,60,"// If the bit convert changed the number of elements, it is unsafe; // to examine the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Performance,load,load,21,// Don't duplicate a load with other uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,Performance,load,load,37,// Make sure we found a non-volatile load and the extractelement is; // the only use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify (build_vec (ext )) to (bitcast (build_vec )),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,Performance,perform,perform,6,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may create bit-casts which; // will be type-legalized to complex code sequences.; // We perform this optimization only before the operation legalizer because we; // may introduce illegal operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Performance,optimiz,optimization,19,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may create bit-casts which; // will be type-legalized to complex code sequences.; // We perform this optimization only before the operation legalizer because we; // may introduce illegal operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:133,Performance,Perform,Performing,133,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may create bit-casts which; // will be type-legalized to complex code sequences.; // We perform this optimization only before the operation legalizer because we; // may introduce illegal operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:149,Performance,optimiz,optimization,149,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may create bit-casts which; // will be type-legalized to complex code sequences.; // We perform this optimization only before the operation legalizer because we; // may introduce illegal operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:257,Performance,perform,perform,257,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may create bit-casts which; // will be type-legalized to complex code sequences.; // We perform this optimization only before the operation legalizer because we; // may introduce illegal operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:270,Performance,optimiz,optimization,270,// We perform this optimization post type-legalization because; // the type-legalizer often scalarizes integer-promoted vectors.; // Performing this optimization before may create bit-casts which; // will be type-legalized to complex code sequences.; // We perform this optimization only before the operation legalizer because we; // may introduce illegal operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:253,Modifiability,extend,extend,253,"// Check to see if this is a BUILD_VECTOR of a bunch of values; // which come from any_extend or zero_extend nodes. If so, we can create; // a new BUILD_VECTOR using bit-casts which may enable other BUILD_VECTOR; // optimizations. We do not handle sign-extend because we can't fill the sign; // using shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:216,Performance,optimiz,optimizations,216,"// Check to see if this is a BUILD_VECTOR of a bunch of values; // which come from any_extend or zero_extend nodes. If so, we can create; // a new BUILD_VECTOR using bit-casts which may enable other BUILD_VECTOR; // optimizations. We do not handle sign-extend because we can't fill the sign; // using shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Abort,Abort,3,// Abort if the element is not an extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Safety,Abort,Abort,26,// Multiple income types. Abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Modifiability,extend,extends,23,// Check if all of the extends are ANY_EXTENDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:175,Energy Efficiency,power,power,175,"// In order to have valid types, all of the inputs must be extended from the; // same source type and all of the inputs must be any or zero extend.; // Scalar sizes must be a power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Modifiability,extend,extended,59,"// In order to have valid types, all of the inputs must be extended from the; // same source type and all of the inputs must be any or zero extend.; // Scalar sizes must be a power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:140,Modifiability,extend,extend,140,"// In order to have valid types, all of the inputs must be extended from the; // same source type and all of the inputs must be any or zero extend.; // Scalar sizes must be a power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Performance,optimiz,optimizations,58,// Create a new simpler BUILD_VECTOR sequence which other optimizations can; // turn into a single shuffle instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Usability,simpl,simpler,16,// Create a new simpler BUILD_VECTOR sequence which other optimizations can; // turn into a single shuffle instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,Performance,optimiz,optimized,61,// The new BUILD_VECTOR node has the potential to be further optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify (build_vec (trunc $1); // (trunc (srl $1 half-width)); // (trunc (srl $1 (2 * half-width)))); // to (bitcast $1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Energy Efficiency,power,power,12,// Only for power of two types to be sure that bitcast works well,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,Modifiability,variab,variable,42,// Vector parts do not stem from the same variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Availability,mask,mask,14,// Initialize mask to undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,Modifiability,extend,extend,76,"// First, determine where the build vector is not undef.; // TODO: We could extend this to handle zero elements as well as undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:128,Modifiability,extend,extended,128,"// The build vector contains some number of undef elements and exactly; // one other element. That other element must be a zero-extended scalar; // extracted from a vector at a constant index to turn this into a shuffle.; // Also, require that the build vector does not implicitly truncate/extend; // its elements.; // TODO: This could be enhanced to allow ANY_EXTEND as well as ZERO_EXTEND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:290,Modifiability,extend,extend,290,"// The build vector contains some number of undef elements and exactly; // one other element. That other element must be a zero-extended scalar; // extracted from a vector at a constant index to turn this into a shuffle.; // Also, require that the build vector does not implicitly truncate/extend; // its elements.; // TODO: This could be enhanced to allow ANY_EXTEND as well as ZERO_EXTEND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:339,Modifiability,enhance,enhanced,339,"// The build vector contains some number of undef elements and exactly; // one other element. That other element must be a zero-extended scalar; // extracted from a vector at a constant index to turn this into a shuffle.; // Also, require that the build vector does not implicitly truncate/extend; // its elements.; // TODO: This could be enhanced to allow ANY_EXTEND as well as ZERO_EXTEND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Modifiability,extend,extend,12,"// The zero-extend must be a multiple of the source size, and we must be; // building a vector of the same size as the source of the extract element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Availability,mask,mask,20,// Create a shuffle mask that will combine the extracted element with zeros; // and undefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:238,Availability,mask,mask,238,"// The low bits of the (potentially translated) extracted element map to; // the source vector. The high bits map to zero. We will use a zero vector; // as the 2nd source operand of the shuffle, so use the 1st element of; // that vector (mask value is number-of-elements) for the high bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:89,Availability,mask,mask,89,// Undef elements of the build vector remain undef because we initialize; // the shuffle mask with -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Energy Efficiency,efficient,efficiently,91,"// If all the Operands of BUILD_VECTOR extract from same; // vector, then split the vector efficiently based on the maximum; // vector access index and adjust the VectorMask and; // VecIn accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:135,Security,access,access,135,"// If all the Operands of BUILD_VECTOR extract from same; // vector, then split the vector efficiently based on the maximum; // vector access index and adjust the VectorMask and; // VecIn accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Availability,mask,mask,21,// Update the vector mask to point to the post-shuffle vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Deployability,Update,Update,3,// Update the vector mask to point to the post-shuffle vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,Modifiability,extend,extends,38,// Try to turn a build vector of zero extends of extract vector elts into a; // a vector zero extend and possibly an extract subvector.; // TODO: Support sign extend?; // TODO: Allow undef elements?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,Modifiability,extend,extend,94,// Try to turn a build vector of zero extends of extract vector elts into a; // a vector zero extend and possibly an extract subvector.; // TODO: Support sign extend?; // TODO: Allow undef elements?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:159,Modifiability,extend,extend,159,// Try to turn a build vector of zero extends of extract vector elts into a; // a vector zero extend and possibly an extract subvector.; // TODO: Support sign extend?; // TODO: Allow undef elements?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Usability,simpl,simple,21,"// If this is a very simple BUILD_VECTOR with first element being a ZERO_EXTEND,; // and all other elements being constant zero's, granularize the BUILD_VECTOR's; // element width, absorbing the ZERO_EXTEND, turning it into a constant zero op.; // This patten can appear during legalization.; //; // NOTE: This can be generalized to allow more than a single; // non-constant-zero op, UNDEF's, and to be KnownBits-based,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Performance,scalab,scalable,60,// We currently can't generate an appropriate shuffle for a scalable vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Availability,mask,mask,40,// UNDEF nodes convert to UNDEF shuffle mask values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:40,Availability,mask,mask,40,// UNDEF nodes convert to UNDEF shuffle mask values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Integrability,depend,depends,116,"// The wider cast must be supported by the target. This is unusual because; // the operation support type parameter depends on the opcode. In addition,; // check the other type in the cast to make sure this is really legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Usability,simpl,simple,20,"// See if this is a simple CONCAT_VECTORS with no UNDEF operands, and if one of; // the operands is a SHUFFLE_VECTOR, and all other operands are also operands; // to that SHUFFLE_VECTOR, create wider SHUFFLE_VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Usability,simpl,simple,23,"// For now, only allow simple 2-operand concatenations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Availability,mask,masks,12,// Identity masks for the operands of the (padded) shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,Availability,mask,mask,24,// New combined shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,Availability,mask,masks,32,// Don't create illegal shuffle masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Performance,Optimiz,Optimize,3,// Optimize concat_vectors where all but the first of the vectors are undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:334,Performance,scalab,scalable,334,"// If the input is a concat_vectors, just make a larger concat by padding; // with smaller undefs.; //; // Legalizing in AArch64TargetLowering::LowerCONCAT_VECTORS() and combining; // here could cause an infinite loop. That legalizing happens when LegalDAG; // is true and input of AArch64TargetLowering::LowerCONCAT_VECTORS() is; // scalable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:98,Testability,test,tested,98,"// Fold any combination of BUILD_VECTOR or UNDEF nodes into one BUILD_VECTOR.; // We have already tested above for an UNDEF only concatenation.; // fold (concat_vectors (BUILD_VECTOR A, B, ...), (BUILD_VECTOR C, D, ...)); // -> (BUILD_VECTOR A, B, ..., C, D, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:270,Performance,scalab,scalable,270,"// Type legalization of vectors and DAG canonicalization of SHUFFLE_VECTOR; // nodes often generate nop CONCAT_VECTOR nodes. Scan the CONCAT_VECTOR; // operands and look for a CONCAT operations that place the incoming vectors; // at the exact same location.; //; // For scalable vectors, EXTRACT_SUBVECTOR indexes are implicitly scaled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:92,Modifiability,extend,extend,92,"// Check the source type is the same as the type of the result.; // If not, this concat may extend the vector, so we can not; // optimize it away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:129,Performance,optimiz,optimize,129,"// Check the source type is the same as the type of the result.; // If not, this concat may extend the vector, so we can not; // optimize it away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:120,Safety,avoid,avoid,120,/// If we are extracting a subvector produced by a wide binary operator try; /// to use a narrow binary operator and/or avoid concatenation and extraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Modifiability,Refactor,Refactor,9,"// TODO: Refactor with the caller (visitEXTRACT_SUBVECTOR), so we can share; // some of these bailouts with other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,Energy Efficiency,reduce,reduced,81,"// Exclude the fake form of fneg (fsub -0.0, x) because that is likely to be; // reduced to the unary fneg when it is visited, and we probably want to deal; // with fneg in a target-specific way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:124,Performance,scalab,scalable,124,"// The optimisations below currently assume we are dealing with fixed length; // vectors. It is possible to add support for scalable vectors, but at the; // moment we've done no analysis to prove whether they are profitable or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:221,Modifiability,extend,extended,221,"// TODO: The motivating case for this transform is an x86 AVX1 target. That; // target has temptingly almost legal versions of bitwise logic ops in 256-bit; // flavors, but no other 256-bit integer support. This could be extended to; // handle any binop, but that may require fixing/adding other folds to avoid; // codegen regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:305,Safety,avoid,avoid,305,"// TODO: The motivating case for this transform is an x86 AVX1 target. That; // target has temptingly almost legal versions of bitwise logic ops in 256-bit; // flavors, but no other 256-bit integer support. This could be extended to; // handle any binop, but that may require fixing/adding other folds to avoid; // codegen regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:135,Testability,log,logic,135,"// TODO: The motivating case for this transform is an x86 AVX1 target. That; // target has temptingly almost legal versions of bitwise logic ops in 256-bit; // flavors, but no other 256-bit integer support. This could be extended to; // handle any binop, but that may require fixing/adding other folds to avoid; // codegen regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Performance,load,load,56,"/// If we are extracting a subvector from a wide vector load, convert to a; /// narrow load to eliminate the extraction:; /// (extract_subvector (load wide vector)) --> (load narrow vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:87,Performance,load,load,87,"/// If we are extracting a subvector from a wide vector load, convert to a; /// narrow load to eliminate the extraction:; /// (extract_subvector (load wide vector)) --> (load narrow vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,Performance,load,load,146,"/// If we are extracting a subvector from a wide vector load, convert to a; /// narrow load to eliminate the extraction:; /// (extract_subvector (load wide vector)) --> (load narrow vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:170,Performance,load,load,170,"/// If we are extracting a subvector from a wide vector load, convert to a; /// narrow load to eliminate the extraction:; /// (extract_subvector (load wide vector)) --> (load narrow vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,Performance,load,loads,33,// We can only create byte sized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Performance,scalab,scalable,48,// A fixed length vector being extracted from a scalable vector; // may not be any *smaller* than the scalable one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,Performance,scalab,scalable,102,// A fixed length vector being extracted from a scalable vector; // may not be any *smaller* than the scalable one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,Performance,load,load,14,// The narrow load will be offset from the base address of the old load if; // we are extracting from something besides index 0 (little-endian).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:67,Performance,load,load,67,// The narrow load will be offset from the base address of the old load if; // we are extracting from something besides index 0 (little-endian).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Availability,Mask,Mask,53,"/// Given EXTRACT_SUBVECTOR(VECTOR_SHUFFLE(Op0, Op1, Mask)),; /// try to produce VECTOR_SHUFFLE(EXTRACT_SUBVECTOR(Op?, ?),; /// EXTRACT_SUBVECTOR(Op?, ?),; /// Mask')); /// iff it is legal and profitable to do so. Notably, the trimmed mask; /// (containing only the elements that are extracted); /// must reference at most two subvectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:160,Availability,Mask,Mask,160,"/// Given EXTRACT_SUBVECTOR(VECTOR_SHUFFLE(Op0, Op1, Mask)),; /// try to produce VECTOR_SHUFFLE(EXTRACT_SUBVECTOR(Op?, ?),; /// EXTRACT_SUBVECTOR(Op?, ?),; /// Mask')); /// iff it is legal and profitable to do so. Notably, the trimmed mask; /// (containing only the elements that are extracted); /// must reference at most two subvectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:235,Availability,mask,mask,235,"/// Given EXTRACT_SUBVECTOR(VECTOR_SHUFFLE(Op0, Op1, Mask)),; /// try to produce VECTOR_SHUFFLE(EXTRACT_SUBVECTOR(Op?, ?),; /// EXTRACT_SUBVECTOR(Op?, ?),; /// Mask')); /// iff it is legal and profitable to do so. Notably, the trimmed mask; /// (containing only the elements that are extracted); /// must reference at most two subvectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Performance,scalab,scalable,22,// Only deal with non-scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Availability,mask,mask,26,// Try to decode the wide mask into narrow mask from at most two subvectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,Availability,mask,mask,43,// Try to decode the wide mask into narrow mask from at most two subvectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Integrability,depend,depend,12,"// Does not depend on operands, does not require adjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,Availability,mask,mask,55,// From which operand of the shuffle does this shuffle mask element pick?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,Availability,mask,mask,47,// Picking from an undef operand. Let's adjust mask instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Integrability,depend,depend,54,// Did we discover that the shuffle does not actually depend on operands?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,Availability,mask,mask,91,// Profitability check: only deal with extractions from the first subvector; // unless the mask becomes an identity mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,Availability,mask,mask,116,// Profitability check: only deal with extractions from the first subvector; // unless the mask becomes an identity mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Performance,perform,perform,12,"// We still perform the exact same EXTRACT_SUBVECTOR, just on different; // operand[s]/index[es], so there is no point in checking for it's legality.; // Do not turn a legal shuffle into an illegal one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:74,Usability,simpl,simplification,74,"// If the concatenated source types match this extract, it's a direct; // simplification:; // extract_subvec (concat V1, V2, ...), i --> Vi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,Usability,simpl,simple,15,// Handle only simple case where vector being inserted and vector; // being extracted are of same size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Performance,perform,performance,147,"/// Try to convert a wide shuffle of concatenated vectors into 2 narrow shuffles; /// followed by concatenation. Narrow vector ops may have better performance; /// than wide ops, and this can unlock further narrowing of other vector ops.; /// Targets can invert this transform later if it is not profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Availability,mask,mask,26,// Split the wide shuffle mask into halves. Any mask element that is accessing; // operand 1 is offset down to account for narrowing of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Availability,mask,mask,48,// Split the wide shuffle mask into halves. Any mask element that is accessing; // operand 1 is offset down to account for narrowing of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,Availability,down,down,103,// Split the wide shuffle mask into halves. Any mask element that is accessing; // operand 1 is offset down to account for narrowing of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:69,Security,access,accessing,69,// Split the wide shuffle mask into halves. Any mask element that is accessing; // operand 1 is offset down to account for narrowing of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Availability,Mask,Mask,49,"// shuffle (concat X, undef), (concat Y, undef), Mask -->; // concat (shuffle X, Y, Mask0), (shuffle X, Y, Mask1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,Usability,simpl,simpler,117,"// Tries to turn a shuffle of two CONCAT_VECTORS into a single concat,; // or turn a shuffle of a single concat into simpler shuffle then concat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Energy Efficiency,efficient,efficiently,50,"// Special case: shuffle(concat(A,B)) can be more efficiently represented; // as concat(shuffle(A,B),UNDEF) if the shuffle doesn't set any of the high; // half vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:481,Modifiability,variab,variable,481,"// Attempt to combine a shuffle of 2 inputs of 'scalar sources' -; // BUILD_VECTOR or SCALAR_TO_VECTOR into a single BUILD_VECTOR.; //; // SHUFFLE(BUILD_VECTOR(), BUILD_VECTOR()) -> BUILD_VECTOR() is always; // a simplification in some sense, but it isn't appropriate in general: some; // BUILD_VECTORs are substantially cheaper than others. The general case; // of a BUILD_VECTOR requires inserting each element individually (or; // performing the equivalent in a temporary stack variable). A BUILD_VECTOR of; // all constants is a single constant pool load. A BUILD_VECTOR where each; // element is identical is a splat. A BUILD_VECTOR where most of the operands; // are undef lowers to a small number of element insertions.; //; // To deal with this, we currently use a bunch of mostly arbitrary heuristics.; // We don't fold shuffles where one side is a non-zero constant, and we don't; // fold shuffles if the resulting (non-splat) BUILD_VECTOR would have duplicate; // non-constant operands. This seems to work out reasonably well in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:434,Performance,perform,performing,434,"// Attempt to combine a shuffle of 2 inputs of 'scalar sources' -; // BUILD_VECTOR or SCALAR_TO_VECTOR into a single BUILD_VECTOR.; //; // SHUFFLE(BUILD_VECTOR(), BUILD_VECTOR()) -> BUILD_VECTOR() is always; // a simplification in some sense, but it isn't appropriate in general: some; // BUILD_VECTORs are substantially cheaper than others. The general case; // of a BUILD_VECTOR requires inserting each element individually (or; // performing the equivalent in a temporary stack variable). A BUILD_VECTOR of; // all constants is a single constant pool load. A BUILD_VECTOR where each; // element is identical is a splat. A BUILD_VECTOR where most of the operands; // are undef lowers to a small number of element insertions.; //; // To deal with this, we currently use a bunch of mostly arbitrary heuristics.; // We don't fold shuffles where one side is a non-zero constant, and we don't; // fold shuffles if the resulting (non-splat) BUILD_VECTOR would have duplicate; // non-constant operands. This seems to work out reasonably well in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:554,Performance,load,load,554,"// Attempt to combine a shuffle of 2 inputs of 'scalar sources' -; // BUILD_VECTOR or SCALAR_TO_VECTOR into a single BUILD_VECTOR.; //; // SHUFFLE(BUILD_VECTOR(), BUILD_VECTOR()) -> BUILD_VECTOR() is always; // a simplification in some sense, but it isn't appropriate in general: some; // BUILD_VECTORs are substantially cheaper than others. The general case; // of a BUILD_VECTOR requires inserting each element individually (or; // performing the equivalent in a temporary stack variable). A BUILD_VECTOR of; // all constants is a single constant pool load. A BUILD_VECTOR where each; // element is identical is a splat. A BUILD_VECTOR where most of the operands; // are undef lowers to a small number of element insertions.; //; // To deal with this, we currently use a bunch of mostly arbitrary heuristics.; // We don't fold shuffles where one side is a non-zero constant, and we don't; // fold shuffles if the resulting (non-splat) BUILD_VECTOR would have duplicate; // non-constant operands. This seems to work out reasonably well in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:213,Usability,simpl,simplification,213,"// Attempt to combine a shuffle of 2 inputs of 'scalar sources' -; // BUILD_VECTOR or SCALAR_TO_VECTOR into a single BUILD_VECTOR.; //; // SHUFFLE(BUILD_VECTOR(), BUILD_VECTOR()) -> BUILD_VECTOR() is always; // a simplification in some sense, but it isn't appropriate in general: some; // BUILD_VECTORs are substantially cheaper than others. The general case; // of a BUILD_VECTOR requires inserting each element individually (or; // performing the equivalent in a temporary stack variable). A BUILD_VECTOR of; // all constants is a single constant pool load. A BUILD_VECTOR where each; // element is identical is a splat. A BUILD_VECTOR where most of the operands; // are undef lowers to a small number of element insertions.; //; // To deal with this, we currently use a bunch of mostly arbitrary heuristics.; // We don't fold shuffles where one side is a non-zero constant, and we don't; // fold shuffles if the resulting (non-splat) BUILD_VECTOR would have duplicate; // non-constant operands. This seems to work out reasonably well in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,Availability,mask,mask,147,// If both inputs are splats of the same value then we can safely merge this; // to a single BUILD_VECTOR with undef elements based on the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Safety,safe,safely,59,// If both inputs are splats of the same value then we can safely merge this; // to a single BUILD_VECTOR with undef elements based on the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:90,Modifiability,extend,extend,90,"// BUILD_VECTOR requires all inputs to be of the same type, find the; // maximum type and extend them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:246,Performance,perform,performed,246,"// Match shuffles that can be converted to *_vector_extend_in_reg.; // This is often generated during legalization.; // e.g. v4i32 <0,u,1,u> -> (v2i64 any_vector_extend_in_reg(v4i32 src)),; // and returns the EVT to which the extension should be performed.; // NOTE: this assumes that the src is the first operand of the shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Testability,test,test,50,// TODO Add support for big-endian when we have a test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Energy Efficiency,power,power-of-,78,"// Attempt to match a '*_extend_vector_inreg' shuffle, we just search for; // power-of-2 extensions as they are the most likely.; // FIXME: should try Scale == NumElts case too,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Testability,test,test,50,// TODO Add support for big-endian when we have a test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Testability,test,test,51,// TODO: add support for big-endian when we have a test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,Availability,mask,mask,54,"// Manifest zeroable element knowledge in the shuffle mask.; // NOTE: we don't have 'zeroable' sentinel value in generic DAG,; // this is a local invention, but it won't leak into DAG.; // FIXME: should we not manifest them, but just check when matching?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,Availability,mask,mask,60,"// Don't proceed unless we've refined at least one zeroable mask indice.; // If we didn't, then we are still trying to match the same shuffle mask; // we previously tried to match as ISD::ANY_EXTEND_VECTOR_INREG,; // and evidently failed. Proceeding will lead to endless combine loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,Availability,mask,mask,142,"// Don't proceed unless we've refined at least one zeroable mask indice.; // If we didn't, then we are still trying to match the same shuffle mask; // we previously tried to match as ISD::ANY_EXTEND_VECTOR_INREG,; // and evidently failed. Proceeding will lead to endless combine loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:141,Availability,mask,mask,141,// The shuffle may be more fine-grained than we want. Widen elements first.; // FIXME: should we do this before manifesting zeroable shuffle mask indices?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,Availability,mask,mask,23,// Analyze the shuffle mask in Scale-sized chunks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Safety,Detect,Detect,3,// Detect 'truncate_vector_inreg' style shuffles that pack the lower parts of; // each source element of a large type into the lowest elements of a smaller; // destination type. This is often generated during legalization.; // If the source node itself was a '*_extend_vector_inreg' node then we should; // then be able to remove it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Testability,test,test,50,// TODO Add support for big-endian when we have a test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:88,Availability,mask,mask,88,"// Combine shuffles of splat-shuffles of the form:; // shuffle (shuffle V, undef, splat-mask), undef, M; // If splat-mask contains undef elements, we need to be careful about; // introducing undef's in the folded mask which are not the result of composing; // the masks of the shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,Availability,mask,mask,117,"// Combine shuffles of splat-shuffles of the form:; // shuffle (shuffle V, undef, splat-mask), undef, M; // If splat-mask contains undef elements, we need to be careful about; // introducing undef's in the folded mask which are not the result of composing; // the masks of the shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:213,Availability,mask,mask,213,"// Combine shuffles of splat-shuffles of the form:; // shuffle (shuffle V, undef, splat-mask), undef, M; // If splat-mask contains undef elements, we need to be careful about; // introducing undef's in the folded mask which are not the result of composing; // the masks of the shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:264,Availability,mask,masks,264,"// Combine shuffles of splat-shuffles of the form:; // shuffle (shuffle V, undef, splat-mask), undef, M; // If splat-mask contains undef elements, we need to be careful about; // introducing undef's in the folded mask which are not the result of composing; // the masks of the shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:114,Availability,mask,mask,114,"// If the inner operand is a known splat with no undefs, just return that directly.; // TODO: Create DemandedElts mask from Shuf's mask.; // TODO: Allow undef elements and merge with the shuffle code below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:131,Availability,mask,mask,131,"// If the inner operand is a known splat with no undefs, just return that directly.; // TODO: Create DemandedElts mask from Shuf's mask.; // TODO: Allow undef elements and merge with the shuffle code below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:90,Availability,mask,mask,90,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:184,Availability,mask,mask,184,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:214,Availability,mask,mask,214,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:678,Availability,mask,masks,678,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:840,Availability,mask,mask,840,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:940,Safety,safe,safe,940,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,Usability,simpl,simplifying,10,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:425,Usability,simpl,simplify,425,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:720,Usability,simpl,simplify,720,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:948,Usability,simpl,simplify,948,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,Availability,mask,mask,31,// Create a new shuffle with a mask that is composed of the two shuffles'; // masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,Availability,mask,masks,78,// Create a new shuffle with a mask that is composed of the two shuffles'; // masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Availability,mask,mask,86,"// Combine shuffles of bitcasts into a shuffle of the bitcast type, providing; // the mask can be treated as a larger type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,Availability,mask,mask,41,// Check that each group of lanes in the mask are either undef or make a valid; // mask for the wider lane type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Availability,mask,mask,83,// Check that each group of lanes in the mask are either undef or make a valid; // mask for the wider lane type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,Availability,mask,mask,39,// Create the new shuffle with the new mask and bitcast it back to the; // original type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,Availability,mask,masks,28,// Peek through the shuffle masks to get the underlying source element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,Availability,mask,mask,48,// TODO: The transform may be a win even if the mask is not legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,Availability,mask,mask,19,"/// If the shuffle mask is taking exactly one element from the first vector; /// operand and passing through all other elements from the second vector; /// operand, return the index of the mask element that is choosing an element; /// from the first operand. Otherwise, return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:189,Availability,mask,mask,189,"/// If the shuffle mask is taking exactly one element from the first vector; /// operand and passing through all other elements from the second vector; /// operand, return the index of the mask element that is choosing an element; /// from the first operand. Otherwise, return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:72,Availability,mask,mask,72,"// TODO: This does not match if there are undef elements in the shuffle mask.; // Should we ignore undefs in the shuffle mask instead? The trade-off is; // removing an instruction (a shuffle), but losing the knowledge that some; // vector lanes are not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:121,Availability,mask,mask,121,"// TODO: This does not match if there are undef elements in the shuffle mask.; // Should we ignore undefs in the shuffle mask instead? The trade-off is; // removing an instruction (a shuffle), but losing the knowledge that some; // vector lanes are not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:118,Security,access,access,118,"/// If a shuffle inserts exactly one element from a source vector operand into; /// another vector operand and we can access the specified element as a scalar,; /// then we can eliminate the shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,Availability,mask,mask,11,// Commute mask and check again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,Availability,mask,mask,50,// Commute operands to match the commuted shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,Security,access,access,96,"// The shuffle inserts exactly one element from operand 0 into operand 1.; // Now see if we can access that element as a scalar via a real insert element; // instruction.; // TODO: We can try harder to locate the element as a scalar. Examples: it; // could be an operand of SCALAR_TO_VECTOR, BUILD_VECTOR, or a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:512,Availability,mask,mask,512,"// There's an existing insertelement with constant insertion index, so we; // don't need to check the legality/profitability of a replacement operation; // that differs at most in the constant value. The target should be able to; // lower any of those in a similar way. If not, legalization will expand this; // to a scalar-to-vector plus shuffle.; //; // Note that the shuffle may move the scalar from the position that the insert; // element used. Therefore, our new insert element occurs at the shuffle's; // mask index value, not the insert's index value.; // shuffle (insertelt v1, x, C), v2, mask --> insertelt v2, x, C'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:598,Availability,mask,mask,598,"// There's an existing insertelement with constant insertion index, so we; // don't need to check the legality/profitability of a replacement operation; // that differs at most in the constant value. The target should be able to; // lower any of those in a similar way. If not, legalization will expand this; // to a scalar-to-vector plus shuffle.; //; // Note that the shuffle may move the scalar from the position that the insert; // element used. Therefore, our new insert element occurs at the shuffle's; // mask index value, not the insert's index value.; // shuffle (insertelt v1, x, C), v2, mask --> insertelt v2, x, C'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:191,Availability,mask,mask,191,"/// If we have a unary shuffle of a shuffle, see if it can be folded away; /// completely. This has the potential to lose undef knowledge because the first; /// shuffle may not have an undef mask element where the second one does. So; /// only call this after doing simplifications based on demanded elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:266,Usability,simpl,simplifications,266,"/// If we have a unary shuffle of a shuffle, see if it can be folded away; /// completely. This has the potential to lose undef knowledge because the first; /// shuffle may not have an undef mask element where the second one does. So; /// only call this after doing simplifications based on demanded elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,Availability,Mask,Mask,36,"// shuf (shuf0 X, Y, Mask0), undef, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:66,Availability,mask,mask,66,"// Canonicalize shuffle undef, v -> v, undef. Commute the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,Availability,mask,mask,45,// Simplify source operands based on shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Usability,Simpl,Simplify,3,// Simplify source operands based on shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,Usability,simpl,simplification,56,// This is intentionally placed after demanded elements simplification because; // it could eliminate knowledge of undef elements created by this shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:155,Availability,Mask,Mask,155,"// A shuffle of a concat of the same narrow vector can be reduced to use; // only low-half elements of a concat with undef:; // shuf (concat X, X), undef, Mask --> shuf (concat X, undef), undef, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:195,Availability,Mask,Mask,195,"// A shuffle of a concat of the same narrow vector can be reduced to use; // only low-half elements of a concat with undef:; // shuf (concat X, X), undef, Mask --> shuf (concat X, undef), undef, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,Energy Efficiency,reduce,reduced,58,"// A shuffle of a concat of the same narrow vector can be reduced to use; // only low-half elements of a concat with undef:; // shuf (concat X, X), undef, Mask --> shuf (concat X, undef), undef, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:95,Performance,perform,performance,95,// Search [NumSubElts] spans for RHS sequence.; // TODO: Can we avoid nested loops to increase performance?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,Safety,avoid,avoid,64,// Search [NumSubElts] spans for RHS sequence.; // TODO: Can we avoid nested loops to increase performance?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,Availability,mask,mask,9,// Reset mask to identity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,Availability,mask,mask,22,// See if the shuffle mask matches the reference insertion mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Availability,mask,mask,59,// See if the shuffle mask matches the reference insertion mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,Performance,perform,performing,16,"// If we're not performing a select/blend shuffle, see if we can convert the; // shuffle into a AND node, with all the out-of-lane elements are known zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Availability,mask,mask,26,// TODO: Should we try to mask with N1 as well?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,Availability,mask,mask,18,// See if a clear mask is legal instead of going via; // XformToShuffleWithZero which loses UNDEF mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:98,Availability,mask,mask,98,// See if a clear mask is legal instead of going via; // XformToShuffleWithZero which loses UNDEF mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,Usability,clear,clear,12,// See if a clear mask is legal instead of going via; // XformToShuffleWithZero which loses UNDEF mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Availability,mask,masks,21,// Scale the shuffle masks to the smaller scalar type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,Availability,mask,masks,21,// Merge the shuffle masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,Availability,mask,mask,20,// Test for shuffle mask legality over both commutations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
