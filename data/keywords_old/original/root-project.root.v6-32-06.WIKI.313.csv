id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html604/TImagePalette.html:507,Integrability,depend,depends,507,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html604/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TImagePalette.html
https://root.cern/root/html604/TImagePalette.html:751,Integrability,depend,depends,751,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html604/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TImagePalette.html
https://root.cern/root/html604/TImagePalette.html:901,Modifiability,inherit,inheritance,901,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html604/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TImagePalette.html
https://root.cern/root/html604/TImagePalette.html:1241,Modifiability,variab,variables,1241,"te. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::C",MatchSource.WIKI,root/html604/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TImagePalette.html
https://root.cern/root/html604/TImagePlugin.html:423,Availability,avail,available,423,". TImagePlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePlugin. class TImagePlugin: public TObject. TImagePlugin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html604/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TImagePlugin.html
https://root.cern/root/html604/TImagePlugin.html:1393,Availability,error,error,1393," virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html604/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TImagePlugin.html
https://root.cern/root/html604/TImagePlugin.html:1477,Availability,error,error,1477," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html604/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TImagePlugin.html
https://root.cern/root/html604/TIndexTable.html:3489,Availability,error,error,3489," named) const; Int_tTTable::CopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TIndexTable::iteratorend(); TIndexTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html604/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIndexTable.html
https://root.cern/root/html604/TIndexTable.html:3573,Availability,error,error,3573,"_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TIndexTable::iteratorend(); TIndexTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html604/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIndexTable.html
https://root.cern/root/html604/TIndexTable.html:17917,Testability,assert,assert,17917," (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. iterator & operator=(const TIndexTable& ); {fTable = iter.fTable; fCurrentRow = iter.fCurrentRow; return *this;}. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }. » Author: Valery Fine(fine@bnl.gov) 01/03/2001 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIndexTable.html
https://root.cern/root/html604/TIndexTable.html:18014,Testability,assert,assert,18014," (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. iterator & operator=(const TIndexTable& ); {fTable = iter.fTable; fCurrentRow = iter.fCurrentRow; return *this;}. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }. » Author: Valery Fine(fine@bnl.gov) 01/03/2001 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIndexTable.html
https://root.cern/root/html604/TInetAddress.html:1341,Availability,error,error,1341," virtual~TInetAddress(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAddress() const; UChar_t*GetAddressBytes() const; const TInetAddress::AddressList_t&GetAddresses() const; const TInetAddress::AliasList_t&GetAliases() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFamily() const; const char*GetHostAdd",MatchSource.WIKI,root/html604/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInetAddress.html
https://root.cern/root/html604/TInetAddress.html:1425,Availability,error,error,1425," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAddress() const; UChar_t*GetAddressBytes() const; const TInetAddress::AddressList_t&GetAddresses() const; const TInetAddress::AliasList_t&GetAliases() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFamily() const; const char*GetHostAddress() const; static const char*GetHostAddress(UInt_t addr); const char*GetHostName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html604/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInetAddress.html
https://root.cern/root/html604/TInetAddress.html:7195,Energy Efficiency,allocate,allocated,7195,"host byte order; TInetAddress::AliasList_tfAliaseslist of aliases; Int_tfFamilyaddress family; TStringfHostnamefully qualified hostname; Int_tfPortport through which we are connected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInetAddress(); Default ctor. Used in case of unknown host. Not a valid address. TInetAddress(const char* host, UInt_t addr, Int_t family, Int_t port = -1); Create TInetAddress. Private ctor. TInetAddress objects can only; be created via the friend classes TSystem, TServerSocket and TSocket.; Use the IsValid() method to check the validity of a TInetAddress. TInetAddress(const TInetAddress& adr); TInetAddress copy ctor. TInetAddress& operator=(const TInetAddress& rhs); TInetAddress assignment operator. UChar_t * GetAddressBytes() const; Returns the raw IP address in host byte order. The highest; order byte position is in addr[0]. To be prepared for 64-bit; IP addresses an array of bytes is returned.; User must delete allocated memory. const char * GetHostAddress(UInt_t addr); Returns the IP address string ""%d.%d.%d.%d"", use it to convert; alternative addresses obtained via GetAddresses().; Copy string immediately, it will be reused. Static function. const char * GetHostAddress() const; Returns the IP address string ""%d.%d.%d.%d"".; Copy string immediately, it will be reused. void Print(Option_t* option = """") const; Print internet address as string. void AddAddress(UInt_t addr); Add alternative address to list of addresses. void AddAlias(const char* alias); Add alias to list of aliases. void Streamer(TBuffer& ); Stream an object of class TInetAddress. virtual ~TInetAddress(); { }. UInt_t GetAddress() const; { return fAddresses[0]; }. const char * GetHostName() const; { return (const char *) fHostname; }. Int_t GetFamily() const; { return fFamily; }. Int_t GetPort() const; { return fPort; }. const AddressList_t & GetAddresses() const; { return fAddresses; }. const AliasList_t & GetAliases() const; { ",MatchSource.WIKI,root/html604/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInetAddress.html
https://root.cern/root/html604/TInspectCanvas.html:6135,Availability,error,error,6135,"l, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargi",MatchSource.WIKI,root/html604/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInspectCanvas.html
https://root.cern/root/html604/TInspectCanvas.html:6219,Availability,error,error,6219,"ct::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas::GetCanvasI",MatchSource.WIKI,root/html604/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInspectCanvas.html
https://root.cern/root/html604/TInspectCanvas.html:30099,Availability,down,down,30099,,MatchSource.WIKI,root/html604/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInspectCanvas.html
https://root.cern/root/html604/TInspectCanvas.html:37904,Integrability,interface,interface,37904," fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tTCanvas::fgIsFolderIndicates if canvas can be browsed as a folder; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInspectCanvas(); InspectCanvas default constructor. TInspectCanvas(UInt_t ww, UInt_t wh); InspectCanvas constructor. ~TInspectCanvas(); InspectCanvas default destructor. void InspectObject(TObject* obj); Dump contents of obj in a graphics canvas.; Same action as TObject::Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. void GoBackward(); static function , inspect previous object. void GoForward(); static function , inspect next object. void Inspector(TObject* obj); static function , interface to InspectObject.; Create the InspectCanvas if it does not exist yet. void RecursiveRemove(TObject* obj); Recursively remove object from the list of objects. void Divide(Int_t nx = 1, Int_t ny = 1, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); { }. void SetGrid(Int_t valuex = 1, Int_t valuey = 1); { }. void SetGridx(Int_t value = 1); { }. void SetGridy(Int_t value = 1); { }. void SetLogx(Int_t value = 1); { }. void SetLogy(Int_t value = 1); { }. void SetLogz(Int_t value = 1); { }. void SetTickx(Int_t value = 1); { }. void SetTicky(Int_t value = 1); { }. void x3d(Option_t* option = """"); { }. TInspectCanvas(). TButton * GetBackward() const; {return fBackward;}. TButton * GetForward() const; {return fForward;}. TObject * GetCurObject() const; {return fCurObject;}. TList * GetObjects() const; {return fObjects;}. » Author: Rene Brun 08/01/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated",MatchSource.WIKI,root/html604/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInspectCanvas.html
https://root.cern/root/html604/TInspectCanvas.html:32602,Testability,log,log,32602,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html604/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInspectCanvas.html
https://root.cern/root/html604/TInspectCanvas.html:32659,Testability,log,log,32659,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html604/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInspectCanvas.html
https://root.cern/root/html604/TInspectCanvas.html:32716,Testability,log,log,32716,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html604/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInspectCanvas.html
https://root.cern/root/html604/TInterpreter.html:525,Availability,avail,available,525,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname, Bool_t knowDictNotLoaded = kFALSE); virtual Int_tAutoLoad(const type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE); virtual Int_tAutoParse(const char* cls); virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t*) const; virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*, ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*, void* = 0, bool = true) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(CallFunc_t*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:1845,Availability,error,error,1845,"type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE); virtual Int_tAutoParse(const char* cls); virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t*) const; virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*, ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*, void* = 0, bool = true) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(CallFunc_t*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*, TInterpreterValue&) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long64_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual voidCallFunc_ExecWithArgsAndReturn(CallFunc_t*, void*, const void*[] = 0, int = 0, void* = 0) const; virtual voidCallFunc_ExecWithReturn(CallFunc_t*, void*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual TInterpreter::CallFuncIFacePtr_tCallFunc_IFacePtr(CallFunc_t*) const; virtual voidCallFunc_IgnoreExtraArgs(CallFunc_t*, bool) const; virtual voidCallFunc_Init(CallFunc_t*) const; virtual Bool_tCallFunc_IsValid(CallFunc_t*) const; virtual voidCallFunc_ResetArg(CallFunc_t*) const",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:9853,Availability,error,error,9853,"DataMemberInfo_t*) const; virtual intDataMemberInfo_TypeSize(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual Bool_tDeclare(const char* code); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, const char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual voidFuncTempInfo_Delete(FuncTempInfo_t*) const; virtual FuncTempInfo_t*FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const; virtual FuncTempInfo_t*FuncTempInfo_FactoryCopy(FuncTempInfo_t*) const; virtual Bool_t",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:9956,Availability,error,error,9956,"ar*DataMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual Bool_tDeclare(const char* code); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, const char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual voidFuncTempInfo_Delete(FuncTempInfo_t*) const; virtual FuncTempInfo_t*FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const; virtual FuncTempInfo_t*FuncTempInfo_FactoryCopy(FuncTempInfo_t*) const; virtual Bool_tFuncTempInfo_IsValid(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Name(FuncTempInfo_t*, TString& na",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:10055,Availability,error,error,10055,"ayIndex(DataMemberInfo_t*) const; virtual Bool_tDeclare(const char* code); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, const char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual voidFuncTempInfo_Delete(FuncTempInfo_t*) const; virtual FuncTempInfo_t*FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const; virtual FuncTempInfo_t*FuncTempInfo_FactoryCopy(FuncTempInfo_t*) const; virtual Bool_tFuncTempInfo_IsValid(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Name(FuncTempInfo_t*, TString& name) const; virtual Long_tFuncTempInfo_Property(FuncTempInfo_t*) const; virtual UInt_tFuncTempInfo_T",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:10210,Availability,error,error,10210,"al(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, const char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual voidFuncTempInfo_Delete(FuncTempInfo_t*) const; virtual FuncTempInfo_t*FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const; virtual FuncTempInfo_t*FuncTempInfo_FactoryCopy(FuncTempInfo_t*) const; virtual Bool_tFuncTempInfo_IsValid(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Name(FuncTempInfo_t*, TString& name) const; virtual Long_tFuncTempInfo_Property(FuncTempInfo_t*) const; virtual UInt_tFuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t*) const; virtual UInt_tFuncTempInfo_TemplateNargs(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Title(FuncTempInfo_t*, ",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:16097,Availability,error,error,16097,"onst; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual voidInspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient); static TInterpreter*Instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsAutoParsingSuspended() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsErrorMessagesEnabled() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsLoaded(const char* filename) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsProcessLineLocked() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Int_tLoad(const char* filenam, Bool_t system = kFALSE); virtual voidLoadEnums(TListOfEnums& cl) const; virtual intLoadFile(const char*) const; virtual voidLoadFunctionTemplates(TClass* cl) const; virtual Int_tLoadLibraryMap(const char* rootmapfile = 0); virtual voidLoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual Bool_tLoadText(const char*) const; virtual voidTNamed::ls(Option_t* option = """") const; virtual const char*MapCppName(const char*) const; voidTObject::MayNotUse(const char* method) const; virtual const char*MethodArgInfo_DefaultValue(MethodArgInfo_t*) const; virtual voidMethodArgInfo_Delete(MethodArgInfo_t*) const; virtual MethodArgInfo_t*MethodArgInfo_Factory() const; virtual MethodArgInfo_t*MethodArgInfo_Factory(MethodInfo_t*) const; virtual MethodArgInfo_t*MethodArgInfo_FactoryCopy(MethodArgInfo_t*) const; virtual Bool_tMethodArgInfo_IsValid(MethodArgInfo_t*) const; virtual const char*MethodArgInfo_Name(MethodArgInfo_t*) const; virtual intMethodArgInfo_Next(MethodArgInfo_t*) const; virtual Long_tMethodArgInfo_Property(MethodArgInfo_t*) const; virtual const char*MethodArgInfo_TypeName(MethodArgInfo_t*) const; virtual stringMethodArgInfo_TypeNormalizedName(MethodArgInfo_t*) const; virtual TInterpreter::EReturnTypeMethodCallReturnType(TFunction* func) const; virtual vo",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:19156,Availability,error,error,19156,"hodInfo_Title(MethodInfo_t*) const; virtual TypeInfo_t*MethodInfo_Type(MethodInfo_t*) const; virtual const char*MethodInfo_TypeName(MethodInfo_t*) const; virtual stringMethodInfo_TypeNormalizedName(MethodInfo_t*) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TInterpreter&operator=(const TInterpreter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRegisterModule(const char*, const char**, const char**, const char*, const char*, void(*)(), const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclArgsToKeep, const char** classesHeaders); virtual voidRegisterTClassUpdate(TClass* oldcl, DictFuncPtr_t dict); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void(*)()) const; virtual ",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:19243,Availability,error,error,19243,"onst; virtual const char*MethodInfo_TypeName(MethodInfo_t*) const; virtual stringMethodInfo_TypeNormalizedName(MethodInfo_t*) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TInterpreter&operator=(const TInterpreter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRegisterModule(const char*, const char**, const char**, const char*, const char*, void(*)(), const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclArgsToKeep, const char** classesHeaders); virtual voidRegisterTClassUpdate(TClass* oldcl, DictFuncPtr_t dict); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void(*)()) const; virtual voidSetAllocunlockfunc(void(*)()) const; virtual void*SetAutoLoadCallBack(void*); voidT",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:24037,Availability,error,error,24037,"rtual intTypeInfo_Size(TypeInfo_t*) const; virtual const char*TypeInfo_TrueName(TypeInfo_t*) const; virtual const char*TypeName(const char* s); virtual Int_tUnloadAllSharedLibraryMaps(); virtual intUnloadFile(const char*) const; virtual Int_tUnloadLibraryMap(const char* library); virtual voidUnRegisterTClassUpdate(const TClass* oldcl); virtual voidUpdateEnumConstants(TEnum* enumObj, TClass* cl) const; virtual voidUpdateListOfGlobalFunctions(); virtual voidUpdateListOfGlobals(); virtual voidUpdateListOfMethods(TClass* cl) const; virtual voidUpdateListOfTypes(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidExecute(TMethod* method, TObjArray* params, int* error = 0); voidTObject::MakeZombie(); virtual Bool_tSetSuspendAutoParsing(Bool_t value). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TInterpreter::EErrorCodekDangerous; static TInterpreter::EErrorCodekFatal; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TInterpreter::EErrorCodekNoError; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TInterpreter::EErrorCodekProcessing; static TInterpreter::EErrorCodekRecoverable; static TObject::(anonymous)TObject::kSingleKey; stat",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:25505,Availability,error,error,25505,"ject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TInterpreter::EErrorCodekNoError; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TInterpreter::EErrorCodekProcessing; static TInterpreter::EErrorCodekRecoverable; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter(const char* name, const char* title = ""Generic Interpreter""); TInterpreter ctor only called by derived classes. TInterpreter * Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). Bool_t SetSuspendAutoParsing(Bool_t value). Bool_t IsAutoParsingSuspended() const. TInterpreter(); { }. TInterpreter(const char* name, const char* title = ""Generic Interpreter""). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). void * SetAutoLoadCallBack(void* ); { return 0; }. void * GetAutoLoadCallBack() const; { return 0; }. Int_t AutoLoad(const char* classname, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoLoad(const type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoParse(const char* cls). void ClearFileBusy(). void ClearStack(). Bool_t Declare(const char* code). void EnableAutoLoading(). void EndOfLineAction(). TClass * GetClass(const type_info& typeinfo, Bool_t load) const. Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. TClass * GenerateTClass(const char* classname, Bool_t emulation, Bool_t silent = kFALSE). TClass * GenerateTClass(ClassInfo_t* classinfo, Bool_t sil",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:27148,Availability,error,error,27148,"code). void EnableAutoLoading(). void EndOfLineAction(). TClass * GetClass(const type_info& typeinfo, Bool_t load) const. Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. TClass * GenerateTClass(const char* classname, Bool_t emulation, Bool_t silent = kFALSE). TClass * GenerateTClass(ClassInfo_t* classinfo, Bool_t silent = kFALSE). Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. void Initialize(). void InspectMembers(TMemberInspector& , const void* obj, const TClass* cl, Bool_t isTransient). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void RegisterModule(const char* , const char** , const char** , const char* , const char* , void(*)() , const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclArgsToKeep, const char** classesHeaders). void UnRegisterTClassUpdate(const TClass* oldcl). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char*(*)(const char*) getlineFunc, void(*)(const char*) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). v",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:27417,Availability,error,error,27417,"mulation, Bool_t silent = kFALSE). TClass * GenerateTClass(ClassInfo_t* classinfo, Bool_t silent = kFALSE). Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. void Initialize(). void InspectMembers(TMemberInspector& , const void* obj, const TClass* cl, Bool_t isTransient). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void RegisterModule(const char* , const char** , const char** , const char* , const char* , void(*)() , const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclArgsToKeep, const char** classesHeaders). void UnRegisterTClassUpdate(const TClass* oldcl). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char*(*)(const char*) getlineFunc, void(*)(const char*) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload, Bool_t isClassOrNamespaceOnly = kFALSE). ",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:27497,Availability,error,error,27497,"nfo, Bool_t silent = kFALSE). Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. void Initialize(). void InspectMembers(TMemberInspector& , const void* obj, const TClass* cl, Bool_t isTransient). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void RegisterModule(const char* , const char** , const char** , const char* , const char* , void(*)() , const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclArgsToKeep, const char** classesHeaders). void UnRegisterTClassUpdate(const TClass* oldcl). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char*(*)(const char*) getlineFunc, void(*)(const char*) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload, Bool_t isClassOrNamespaceOnly = kFALSE). Bool_t CheckClassTemplate(const char* name). Long_t Calc(const char* line, TI",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:28492,Availability,error,error,28492,", TInterpreter::EErrorCode* error = 0). void PrintIntro(). void RegisterModule(const char* , const char** , const char** , const char* , const char* , void(*)() , const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclArgsToKeep, const char** classesHeaders). void UnRegisterTClassUpdate(const TClass* oldcl). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char*(*)(const char*) getlineFunc, void(*)(const char*) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload, Bool_t isClassOrNamespaceOnly = kFALSE). Bool_t CheckClassTemplate(const char* name). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl) const. void CreateListOfDataMembers(TClass* cl) const. void CreateListOfMethods(TClass* cl) const. void CreateListOfMethodArgs(TFunction* m) const. void UpdateListOfMethods(TClass* cl) const. TString GetMangledName(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void GetInterpreterTypeName(const char* name, string& output, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TO",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:29442,Availability,error,error,29442,"const char* name). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl) const. void CreateListOfDataMembers(TClass* cl) const. void CreateListOfMethods(TClass* cl) const. void CreateListOfMethodArgs(TFunction* m) const. void UpdateListOfMethods(TClass* cl) const. TString GetMangledName(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void GetInterpreterTypeName(const char* name, string& output, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const. Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void ",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:29538,Availability,error,error,29538,"). void CreateListOfBaseClasses(TClass* cl) const. void CreateListOfDataMembers(TClass* cl) const. void CreateListOfMethods(TClass* cl) const. void CreateListOfMethodArgs(TFunction* m) const. void UpdateListOfMethods(TClass* cl) const. TString GetMangledName(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void GetInterpreterTypeName(const char* name, string& output, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const. Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. ",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:29630,Availability,error,error,29630,"nst. void CreateListOfMethods(TClass* cl) const. void CreateListOfMethodArgs(TFunction* m) const. void UpdateListOfMethods(TClass* cl) const. TString GetMangledName(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void GetInterpreterTypeName(const char* name, string& output, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const. Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. c",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:29827,Availability,error,error,29827,"char* params, Bool_t objectIsConst = kFALSE). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void GetInterpreterTypeName(const char* name, string& output, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const. Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. Boo",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:341,Integrability,interface,interface,341,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname, Bool_t knowDictNotLoaded = kFALSE); virtual Int_tAutoLoad(const type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE); virtual Int_tAutoParse(const char* cls); virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t*) const; virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*, ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*, void* = 0, bool = true) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(CallFunc_t*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:32856,Integrability,interface,interface,32856,"r* ). DeclId_t GetDataMember(ClassInfo_t* cl, const char* name) const. DeclId_t GetDataMemberAtAddr(const void* addr) const. DeclId_t GetDataMemberWithValue(const void* ptrvalue) const. DeclId_t GetEnum(TClass* cl, const char* name) const. TEnum* CreateEnum(void* VD, TClass* cl) const. void UpdateEnumConstants(TEnum* enumObj, TClass* cl) const. void LoadEnums(TListOfEnums& cl) const. DeclId_t GetFunction(ClassInfo_t* cl, const char* funcname). DeclId_t GetFunctionWithPrototype(ClassInfo_t* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch). DeclId_t GetFunctionWithValues(ClassInfo_t* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). DeclId_t GetFunctionTemplate(ClassInfo_t* cl, const char* funcname). void GetFunctionOverloads(ClassInfo_t* cl, const char* funcname, vector<TInterpreter::DeclId_t>& res) const. void LoadFunctionTemplates(TClass* cl) const. void CallFunc_Delete(CallFunc_t* ) const; CallFunc interface. {;}. void CallFunc_Exec(CallFunc_t* , void* ) const; {;}. void CallFunc_Exec(CallFunc_t* , void* , TInterpreterValue& ) const; {;}. void CallFunc_ExecWithReturn(CallFunc_t* , void* , void* ) const; {;}. void CallFunc_ExecWithArgsAndReturn(CallFunc_t* , void* , const void*[] = 0, int = 0, void* = 0) const; {}. Long_t CallFunc_ExecInt(CallFunc_t* , void* ) const; {return 0;}. Long64_t CallFunc_ExecInt64(CallFunc_t* , void* ) const; {return 0;}. Double_t CallFunc_ExecDouble(CallFunc_t* , void* ) const; {return 0;}. CallFunc_t * CallFunc_Factory() const; {return 0;}. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* ) const; {return 0;}. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* ) const; {return 0;}. void CallFunc_IgnoreExtraArgs(CallFunc_t* , bool ) const; {;}. void CallFunc_Init(CallFunc_t* ) const; {;}. Bool_t CallFunc_IsValid(CallFunc_t* ) const; {return 0;}. CallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t* ) const; {return CallFuncIFacePtr_t();}. vo",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:36137,Integrability,interface,interface,36137,"har* , const char* , bool , Long_t* ) const; {;}. void CallFunc_SetFunc(CallFunc_t* , ClassInfo_t* , const char* , const char* , Long_t* ) const; {;}. void CallFunc_SetFunc(CallFunc_t* , MethodInfo_t* ) const; {;}. void CallFunc_SetFuncProto(CallFunc_t* , ClassInfo_t* , const char* , const char* , Long_t* , ROOT::EFunctionMatchMode = ROOT::kConversionMatch) const; {;}. void CallFunc_SetFuncProto(CallFunc_t* , ClassInfo_t* , const char* , const char* , bool , Long_t* , ROOT::EFunctionMatchMode = ROOT::kConversionMatch) const; {;}. void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const vector<TypeInfo_t*>& proto, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const. void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const vector<TypeInfo_t*>& proto, bool objectIsConst, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const. Bool_t ClassInfo_Contains(ClassInfo_t* info, TInterpreter::DeclId_t decl) const; ClassInfo interface. Long_t ClassInfo_ClassProperty(ClassInfo_t* ) const; {return 0;}. void ClassInfo_Delete(ClassInfo_t* ) const; {;}. void ClassInfo_Delete(ClassInfo_t* , void* ) const; {;}. void ClassInfo_DeleteArray(ClassInfo_t* , void* , bool ) const; {;}. void ClassInfo_Destruct(ClassInfo_t* , void* ) const; {;}. ClassInfo_t * ClassInfo_Factory(Bool_t = kTRUE) const. ClassInfo_t * ClassInfo_Factory(ClassInfo_t* ) const. ClassInfo_t * ClassInfo_Factory(const char* ) const. Long_t ClassInfo_GetBaseOffset(ClassInfo_t* , ClassInfo_t* , void* = 0, bool = true) const; {return 0;}. Bool_t ClassInfo_HasDefaultConstructor(ClassInfo_t* ) const; {return 0;}. Bool_t ClassInfo_HasMethod(ClassInfo_t* , const char* ) const; {return 0;}. void ClassInfo_Init(ClassInfo_t* , const char* ) const; {;}. void ClassInfo_Init(ClassInfo_t* , int ) const; {;}. Bool_t ClassInfo_IsBase(ClassInfo_t* , const char* ) const; {return 0;}. Bool_t ClassInfo_IsEnum(const char* ) const;",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:38425,Integrability,interface,interface,38425,"ssInfo_IsValidMethod(ClassInfo_t* , const char* , const char* , Bool_t , Long_t* , ROOT::EFunctionMatchMode = ROOT::kConversionMatch) const; {return 0;}. int ClassInfo_Next(ClassInfo_t* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , int ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , int , void* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , void* ) const; {return 0;}. Long_t ClassInfo_Property(ClassInfo_t* ) const; {return 0;}. int ClassInfo_Size(ClassInfo_t* ) const; {return 0;}. Long_t ClassInfo_Tagnum(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_FileName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_FullName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Name(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Title(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_TmpltName(ClassInfo_t* ) const; {return 0;}. void BaseClassInfo_Delete(BaseClassInfo_t* ) const; BaseClassInfo interface. {;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* , ClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* , int ) const; {return 0;}. Long_t BaseClassInfo_Offset(BaseClassInfo_t* , void* = 0, bool = true) const; {return 0;}. Long_t BaseClassInfo_Property(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Tagnum(BaseClassInfo_t* ) const; {return 0;}. ClassInfo_t* BaseClassInfo_ClassInfo(BaseClassInfo_t* ) const. const char * BaseClassInfo_FullName(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_Name(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_TmpltName(BaseClassInfo_t* ) const; {return 0;}. int DataMemberInfo_ArrayDim(DataMemberInfo_t* ) const; DataMemberInfo interface. {return 0;}. void DataMemberInfo_Delete(DataMemberInfo_t* ) const; {;}. DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t* = 0",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:39256,Integrability,interface,interface,39256,". const char * ClassInfo_Title(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_TmpltName(ClassInfo_t* ) const; {return 0;}. void BaseClassInfo_Delete(BaseClassInfo_t* ) const; BaseClassInfo interface. {;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* , ClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* , int ) const; {return 0;}. Long_t BaseClassInfo_Offset(BaseClassInfo_t* , void* = 0, bool = true) const; {return 0;}. Long_t BaseClassInfo_Property(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Tagnum(BaseClassInfo_t* ) const; {return 0;}. ClassInfo_t* BaseClassInfo_ClassInfo(BaseClassInfo_t* ) const. const char * BaseClassInfo_FullName(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_Name(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_TmpltName(BaseClassInfo_t* ) const; {return 0;}. int DataMemberInfo_ArrayDim(DataMemberInfo_t* ) const; DataMemberInfo interface. {return 0;}. void DataMemberInfo_Delete(DataMemberInfo_t* ) const; {;}. DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t* = 0) const; {return 0;}. DataMemberInfo_t * DataMemberInfo_Factory(TInterpreter::DeclId_t declid, ClassInfo_t* clinfo) const. DataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. Bool_t DataMemberInfo_IsValid(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_MaxIndex(DataMemberInfo_t* , Int_t ) const; {return 0;}. int DataMemberInfo_Next(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Offset(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Property(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_TypeSize(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMembe",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:40556,Integrability,interface,interface,40556,"mberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. Bool_t DataMemberInfo_IsValid(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_MaxIndex(DataMemberInfo_t* , Int_t ) const; {return 0;}. int DataMemberInfo_Next(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Offset(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Property(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_TypeSize(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Name(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Title(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* ) const; {return 0;}. void FuncTempInfo_Delete(FuncTempInfo_t* ) const; Function Template interface. FuncTempInfo_t * FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const. FuncTempInfo_t * FuncTempInfo_FactoryCopy(FuncTempInfo_t* ) const. Bool_t FuncTempInfo_IsValid(FuncTempInfo_t* ) const. UInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t* ) const. UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t* ) const. Long_t FuncTempInfo_Property(FuncTempInfo_t* ) const. void FuncTempInfo_Name(FuncTempInfo_t* , TString& name) const. void FuncTempInfo_Title(FuncTempInfo_t* , TString& title) const. void MethodInfo_CreateSignature(MethodInfo_t* , TString& ) const; MethodInfo interface. {;}. void MethodInfo_Delete(MethodInfo_t* ) const; {;}. MethodInfo_t * MethodInfo_Factory() const; {return 0;}. MethodInfo_t * MethodInfo_Factory(ClassInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_Factory(TInterpreter::DeclId_t declid) const. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* ) const; {return 0;}. void * MethodInfo_InterfaceMethod(MethodInfo",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:41145,Integrability,interface,interface,41145," DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Name(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Title(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* ) const; {return 0;}. void FuncTempInfo_Delete(FuncTempInfo_t* ) const; Function Template interface. FuncTempInfo_t * FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const. FuncTempInfo_t * FuncTempInfo_FactoryCopy(FuncTempInfo_t* ) const. Bool_t FuncTempInfo_IsValid(FuncTempInfo_t* ) const. UInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t* ) const. UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t* ) const. Long_t FuncTempInfo_Property(FuncTempInfo_t* ) const. void FuncTempInfo_Name(FuncTempInfo_t* , TString& name) const. void FuncTempInfo_Title(FuncTempInfo_t* , TString& title) const. void MethodInfo_CreateSignature(MethodInfo_t* , TString& ) const; MethodInfo interface. {;}. void MethodInfo_Delete(MethodInfo_t* ) const; {;}. MethodInfo_t * MethodInfo_Factory() const; {return 0;}. MethodInfo_t * MethodInfo_Factory(ClassInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_Factory(TInterpreter::DeclId_t declid) const. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* ) const; {return 0;}. void * MethodInfo_InterfaceMethod(MethodInfo_t* ) const; {return 0;}. Bool_t MethodInfo_IsValid(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NDefaultArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_Next(MethodInfo_t* ) const; {return 0;}. Long_t MethodInfo_Property(MethodInfo_t* ) const. Long_t MethodInfo_ExtraProperty(MethodInfo_t* ) const. TypeInfo_t * MethodInfo_Type(MethodInfo_t* ) const; {return 0;}. EReturnType MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const. const char * MethodInfo_GetMangledName(MethodInfo_t* ) const; {return 0;}. cons",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:42525,Integrability,interface,interface,42525,"Info_InterfaceMethod(MethodInfo_t* ) const; {return 0;}. Bool_t MethodInfo_IsValid(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NDefaultArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_Next(MethodInfo_t* ) const; {return 0;}. Long_t MethodInfo_Property(MethodInfo_t* ) const. Long_t MethodInfo_ExtraProperty(MethodInfo_t* ) const. TypeInfo_t * MethodInfo_Type(MethodInfo_t* ) const; {return 0;}. EReturnType MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const. const char * MethodInfo_GetMangledName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetPrototype(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Name(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_TypeName(MethodInfo_t* ) const; {return 0;}. std::string MethodInfo_TypeNormalizedName(MethodInfo_t* ) const; {return """";}. const char * MethodInfo_Title(MethodInfo_t* ) const; {return 0;}. void MethodArgInfo_Delete(MethodArgInfo_t* ) const; MethodArgInfo interface. {;}. MethodArgInfo_t * MethodArgInfo_Factory() const; {return 0;}. MethodArgInfo_t * MethodArgInfo_Factory(MethodInfo_t* ) const; {return 0;}. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* ) const; {return 0;}. Bool_t MethodArgInfo_IsValid(MethodArgInfo_t* ) const; {return 0;}. int MethodArgInfo_Next(MethodArgInfo_t* ) const; {return 0;}. Long_t MethodArgInfo_Property(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* ) const. void TypeInfo_Delete(TypeInfo_t* ) const; TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(const char* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {r",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:43308,Integrability,interface,interface,43308,"o_t* ) const; {return 0;}. std::string MethodInfo_TypeNormalizedName(MethodInfo_t* ) const; {return """";}. const char * MethodInfo_Title(MethodInfo_t* ) const; {return 0;}. void MethodArgInfo_Delete(MethodArgInfo_t* ) const; MethodArgInfo interface. {;}. MethodArgInfo_t * MethodArgInfo_Factory() const; {return 0;}. MethodArgInfo_t * MethodArgInfo_Factory(MethodInfo_t* ) const; {return 0;}. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* ) const; {return 0;}. Bool_t MethodArgInfo_IsValid(MethodArgInfo_t* ) const; {return 0;}. int MethodArgInfo_Next(MethodArgInfo_t* ) const; {return 0;}. Long_t MethodArgInfo_Property(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* ) const. void TypeInfo_Delete(TypeInfo_t* ) const; TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(const char* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {return 0;}. void TypeInfo_Init(TypeInfo_t* , const char* ) const; {;}. Bool_t TypeInfo_IsValid(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_Name(TypeInfo_t* ) const; {return 0;}. Long_t TypeInfo_Property(TypeInfo_t* ) const; {return 0;}. int TypeInfo_RefType(TypeInfo_t* ) const; {return 0;}. int TypeInfo_Size(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_TrueName(TypeInfo_t* ) const; {return 0;}. void TypedefInfo_Delete(TypedefInfo_t* ) const; TypedefInfo interface. {;}. TypedefInfo_t * TypedefInfo_Factory() const; {return 0;}. TypedefInfo_t * TypedefInfo_Factory(const char* ) const; {return 0;}. TypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t* ) const; {return 0;}. void TypedefInfo_Init(TypedefInfo_t* , const char* ) const; {;}. Bool_t TypedefInfo_IsVal",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:43977,Integrability,interface,interface,43977,"turn 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* ) const. void TypeInfo_Delete(TypeInfo_t* ) const; TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(const char* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {return 0;}. void TypeInfo_Init(TypeInfo_t* , const char* ) const; {;}. Bool_t TypeInfo_IsValid(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_Name(TypeInfo_t* ) const; {return 0;}. Long_t TypeInfo_Property(TypeInfo_t* ) const; {return 0;}. int TypeInfo_RefType(TypeInfo_t* ) const; {return 0;}. int TypeInfo_Size(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_TrueName(TypeInfo_t* ) const; {return 0;}. void TypedefInfo_Delete(TypedefInfo_t* ) const; TypedefInfo interface. {;}. TypedefInfo_t * TypedefInfo_Factory() const; {return 0;}. TypedefInfo_t * TypedefInfo_Factory(const char* ) const; {return 0;}. TypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t* ) const; {return 0;}. void TypedefInfo_Init(TypedefInfo_t* , const char* ) const; {;}. Bool_t TypedefInfo_IsValid(TypedefInfo_t* ) const; {return 0;}. int TypedefInfo_Next(TypedefInfo_t* ) const; {return 0;}. Long_t TypedefInfo_Property(TypedefInfo_t* ) const; {return 0;}. int TypedefInfo_Size(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_TrueName(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_Name(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_Title(TypedefInfo_t* ) const; {return 0;}. » Author: Fons Rademakers 01/03/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:11661,Performance,load,load,11661,"(FuncTempInfo_t*) const; virtual FuncTempInfo_t*FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const; virtual FuncTempInfo_t*FuncTempInfo_FactoryCopy(FuncTempInfo_t*) const; virtual Bool_tFuncTempInfo_IsValid(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Name(FuncTempInfo_t*, TString& name) const; virtual Long_tFuncTempInfo_Property(FuncTempInfo_t*) const; virtual UInt_tFuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t*) const; virtual UInt_tFuncTempInfo_TemplateNargs(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Title(FuncTempInfo_t*, TString& title) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual TClass*GenerateTClass(ClassInfo_t* classinfo, Bool_t silent = kFALSE); virtual TClass*GenerateTClass(const char* classname, Bool_t emulation, Bool_t silent = kFALSE); virtual voidGenericError(const char*) const; virtual void*GetAutoLoadCallBack() const; virtual TClass*GetClass(const type_info& typeinfo, Bool_t load) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual TInterpreter::DeclId_tGetDataMember(ClassInfo_t* cl, const char* name) const; virtual TInterpreter::DeclId_tGetDataMemberAtAddr(const void* addr) const; virtual TInterpreter::DeclId_tGetDataMemberWithValue(const void* ptrvalue) const; virtual TInterpreter::DeclId_tGetDeclId(CallFunc_t* info) const; virtual TInterpreter::DeclId_tGetDeclId(ClassInfo_t* info) const; virtual TInterpreter::DeclId_tGetDeclId(DataMemberInfo_t* info) const; virtual TInterpreter::DeclId_tGetDeclId(FuncTempInfo_t* info) const; virtual TInterpreter::DeclId_tGetDeclId(MethodInfo_t* info) const; virtual TInterpreter::DeclId_tGetDeclId(TypedefInfo_t* info) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TInterpreter::DeclId_tGetEnum(TClass* cl, const char* name) const; virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; vir",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:26230,Performance,load,load,26230,"erited Members; Includes; Libraries. Function documentation; TInterpreter(const char* name, const char* title = ""Generic Interpreter""); TInterpreter ctor only called by derived classes. TInterpreter * Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). Bool_t SetSuspendAutoParsing(Bool_t value). Bool_t IsAutoParsingSuspended() const. TInterpreter(); { }. TInterpreter(const char* name, const char* title = ""Generic Interpreter""). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). void * SetAutoLoadCallBack(void* ); { return 0; }. void * GetAutoLoadCallBack() const; { return 0; }. Int_t AutoLoad(const char* classname, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoLoad(const type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE). Int_t AutoParse(const char* cls). void ClearFileBusy(). void ClearStack(). Bool_t Declare(const char* code). void EnableAutoLoading(). void EndOfLineAction(). TClass * GetClass(const type_info& typeinfo, Bool_t load) const. Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. TClass * GenerateTClass(const char* classname, Bool_t emulation, Bool_t silent = kFALSE). TClass * GenerateTClass(ClassInfo_t* classinfo, Bool_t silent = kFALSE). Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. void Initialize(). void InspectMembers(TMemberInspector& , const void* obj, const TClass* cl, Bool_t isTransient). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0).",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TInterpreter.html:30240,Safety,avoid,avoids,30240," cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode = ROOT::kConversionMatch). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const. Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. Bool_t LoadText(const char* ) const; {return kFALSE;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void(*)() ) const; {;}. void SetAllocunlockfunc(void(*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. int SetClassAutoparsing(int ); {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int",MatchSource.WIKI,root/html604/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TInterpreter.html
https://root.cern/root/html604/TIsAProxy.html:1513,Performance,cache,cached,1513,"Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TIsAProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIsAProxy.html
https://root.cern/root/html604/TIsAProxy.html:1389,Safety,safe,safe,1389,"Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TIsAProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIsAProxy.html
https://root.cern/root/html604/TIter.html:1120,Deployability,release,release,1120,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub class",MatchSource.WIKI,root/html604/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIter.html
https://root.cern/root/html604/TIter.html:323,Integrability,protocol,protocol,323,". TIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Li",MatchSource.WIKI,root/html604/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIter.html
https://root.cern/root/html604/TIter.html:441,Modifiability,inherit,inherit,441,". TIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Li",MatchSource.WIKI,root/html604/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIter.html
https://root.cern/root/html604/TIter.html:1025,Modifiability,inherit,inherits,1025,"rarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); ",MatchSource.WIKI,root/html604/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIter.html
https://root.cern/root/html604/TIterator.html:513,Availability,avail,available,513,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); Bool_toperator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIterator(); TIterator(const TIterator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator(); { }. TIterator(const TIterator& ); { }. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. Bool_t operator==(const TIterator& other) const; { return !(*this != other); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Ren",MatchSource.WIKI,root/html604/TIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIterator.html
https://root.cern/root/html604/TIterator.html:342,Integrability,interface,interface,342,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); Bool_toperator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIterator(); TIterator(const TIterator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator(); { }. TIterator(const TIterator& ); { }. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. Bool_t operator==(const TIterator& other) const; { return !(*this != other); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Ren",MatchSource.WIKI,root/html604/TIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TIterator.html
https://root.cern/root/html604/TKDE.html:1236,Availability,error,error,1236,"rchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TKDE. class TKDE: public TNamed. Function Members (Methods); public:. virtual~TKDE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t data); voidFill(Double_t data, Double_t weight); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetAdaptiveWeights() const; TF1*GetApproximateBias(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.); Double_tGetBias(Double_t x) const; TF1*GetDrawnFunction(); TGraphErrors*GetDrawnGraph(); TF1*GetDrawnLowerFunction(); TF1*GetDrawnUpperFunction(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:1320,Availability,error,error,1320,"rchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TKDE. class TKDE: public TNamed. Function Members (Methods); public:. virtual~TKDE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t data); voidFill(Double_t data, Double_t weight); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetAdaptiveWeights() const; TF1*GetApproximateBias(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.); Double_tGetBias(Double_t x) const; TF1*GetDrawnFunction(); TGraphErrors*GetDrawnGraph(); TF1*GetDrawnLowerFunction(); TF1*GetDrawnUpperFunction(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:10995,Availability,error,errors,10995,lete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<Double_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventWeightsOriginal data weights; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; TKDE::KernelFunction_PtrfKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); Double_tfSumOfCountsData sum of weights; TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TKDE(); Class destructor. void Instantiate(TKDE::Kern,MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:11693,Availability,robust,robust,11693,lete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<Double_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventWeightsOriginal data weights; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; TKDE::KernelFunction_PtrfKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); Double_tfSumOfCountsData sum of weights; TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TKDE(); Class destructor. void Instantiate(TKDE::Kern,MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:16656,Availability,error,errors,16656,"a event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option; or set the bin count to the weights in case of weighted data. void Draw(const Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:16801,Availability,error,errors,16801,"a event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option; or set the bin count to the weights in case of weighted data. void Draw(const Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:17326,Availability,error,errors,17326,"id SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option; or set the bin count to the weights in case of weighted data. void Draw(const Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integra",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:10567,Energy Efficiency,adapt,adaptive,10567,lete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<Double_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventWeightsOriginal data weights; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; TKDE::KernelFunction_PtrfKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); Double_tfSumOfCountsData sum of weights; TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TKDE(); Class destructor. void Instantiate(TKDE::Kern,MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:13141,Energy Efficiency,adapt,adaptive,13141,"ble_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, const Double_t* weight, Double_t xMin, Double_t xMax, const Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(const Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data, const Double_t* weights); Sets the data events input sample or bin centres for binned option and computes bas",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:13638,Energy Efficiency,adapt,adaptive,13638,"ptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data, const Double_t* weights); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0). void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKerne",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:17616,Energy Efficiency,adapt,adaptive,17616,"const Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:17706,Energy Efficiency,adapt,adaptive,17706,"ptions:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. void ComputeDataStats(); in cas",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:10567,Modifiability,adapt,adaptive,10567,lete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<Double_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventWeightsOriginal data weights; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; TKDE::KernelFunction_PtrfKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); Double_tfSumOfCountsData sum of weights; TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TKDE(); Class destructor. void Instantiate(TKDE::Kern,MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:13141,Modifiability,adapt,adaptive,13141,"ble_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, const Double_t* weight, Double_t xMin, Double_t xMax, const Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(const Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data, const Double_t* weights); Sets the data events input sample or bin centres for binned option and computes bas",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:13638,Modifiability,adapt,adaptive,13638,"ptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data, const Double_t* weights); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0). void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKerne",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:17616,Modifiability,adapt,adaptive,17616,"const Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:17706,Modifiability,adapt,adaptive,17706,"ptions:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. void ComputeDataStats(); in cas",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDE.html:13563,Performance,tune,tune,13563,"* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data, const Double_t* weights); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0). void SetCanonicalBandwidt",MatchSource.WIKI,root/html604/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDE.html
https://root.cern/root/html604/TKDTreeBinning.html:2278,Availability,error,error,2278," virtual~TKDTreeBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawCla",MatchSource.WIKI,root/html604/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTreeBinning.html
https://root.cern/root/html604/TKDTreeBinning.html:2362,Availability,error,error,2362," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinData(ROOT::Fit::BinData& data) const; UInt_tFindBin(const Double_t* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetBinCenter(UInt_t bin) const; UInt_tGetBinContent(UInt_t bin) const; Double_tGetBinDensity(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinEdges(UInt_t bin) const; UInt_tGetBinMaxDensity() const; const Double_t*GetBinMaxEdges(UInt_t bin) const; UInt_tGetBinMinDensity() const; const Double_t*GetBinMinEdges(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinsEdges() const; const Double_t*GetBinsMaxEdges() const; const Double_t*GetBinsMinEdges() const; Double_tGetBinVolume(UInt_t bin) const; const Double_t*GetBinWidth(UInt_t bin) const; Double_tGetDataMax(UInt_t dim) const; Double_tGetD",MatchSource.WIKI,root/html604/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTreeBinning.html
https://root.cern/root/html604/TKDTreeBinning.html:10717,Safety,avoid,avoid,10717,"ion. Thus data[] = x1,x2,x3,......xN, y1,y2,y3......yN, z1,z2,...........zN,.... Note that the passed dataSize is not the size of the array but is the number of points (N); The size of the array must be at least dataDim*dataSize. ~TKDTreeBinning(); Class's destructor. void SetNBins(UInt_t bins); Sets binning inner structure. void SortBinsByDensity(Bool_t sortAsc = kTRUE); Sorts bins by their density. void SetData(Double_t* data); Sets the data and finds minimum and maximum by dimensional coordinate. void SetTreeData(); Sets the data for constructing the kD-tree. void SetBinsContent(); Sets the bins' content. void SetBinsEdges(); Sets the bins' edges; Double_t* rawBinEdges = fDataBins->GetBoundaryExact(fDataBins->GetNNodes());. void SetBinMinMaxEdges(Double_t* binEdges); Sets the bins' minimum and maximum edges. void SetCommonBinEdges(Double_t* binEdges); Sets indexing on the bin edges which have common boundaries. void ReadjustMinBinEdges(Double_t* binEdges); Readjusts the bins' minimum edge by shifting it slightly lower; to avoid overlapping with the data. void ReadjustMaxBinEdges(Double_t* binEdges); Readjusts the bins' maximum edge; and shift it sligtly higher. const Double_t* GetBinsMinEdges() const; Returns the bins' minimum edges. const Double_t* GetBinsMaxEdges() const; Returns the bins' maximum edges. std::pair<const Double_t*, const Double_t*> GetBinsEdges() const; Returns the bins' edges. const Double_t* GetBinMinEdges(UInt_t bin) const; Returns the bin's minimum edges. 'bin' is between 0 and fNBins - 1. const Double_t* GetBinMaxEdges(UInt_t bin) const; Returns the bin's maximum edges. 'bin' is between 0 and fNBins - 1. std::pair<const Double_t*, const Double_t*> GetBinEdges(UInt_t bin) const; Returns the bin's edges. 'bin' is between 0 and fNBins - 1. UInt_t GetNBins() const; Returns the number of bins. UInt_t GetDim() const; Returns the number of dimensions. UInt_t GetBinContent(UInt_t bin) const; Returns the number of points in bin. 'bin' is between 0 a",MatchSource.WIKI,root/html604/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTreeBinning.html
https://root.cern/root/html604/TKDTree_int_double_.html:1960,Availability,down,down,1960,"ng a multidimensional search key (e.g. range searches and; nearest neighbour searches). kd-trees are a special case of BSP trees. A kd-tree uses only splitting planes that are perpendicular to one of the coordinate system axes.; This differs from BSP trees, in which arbitrary splitting planes can be used.; In addition, in the typical definition every node of a kd-tree, from the root to the leaves, stores a point.; This differs from BSP trees, in which leaves are typically the only nodes that contain points; (or other geometric primitives). As a consequence, each splitting plane must go through one of; the points in the kd-tree. kd-trees are a variant that store data only in leaf nodes. 2. Constructing a classical kd-tree ( Pseudo code). Since there are many possible ways to choose axis-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return n",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:11221,Availability,error,error,11221,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const double* point, int ind, Int_t type = 2) const; voidDistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(double* point, double* delta, Int_t& inode); voidFindInRange(double* point, double range, vector<int>& res); voidFindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); intFindNode(const double* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(double* point, int& index, Int_t& iter); double*GetBoundaries(); double*GetBoundariesExact(); double*GetBoundary(const Int_t node); double*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:11305,Availability,error,error,11305,"ss*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const double* point, int ind, Int_t type = 2) const; voidDistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(double* point, double* delta, Int_t& inode); voidFindInRange(double* point, double range, vector<int>& res); voidFindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); intFindNode(const double* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(double* point, int& index, Int_t& iter); double*GetBoundaries(); double*GetBoundariesExact(); double*GetBoundary(const Int_t node); double*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode) const; virtual const char*TObject::GetName() const; intGetNDim(); Int_",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:18692,Availability,failure,failure,18692,"tfNDimnumber of dimensions; intfNDimmdummy 2*fNDim; Int_tfNNodessize of node array; intfNPointsnumber of multidimensional points; Int_tfOffset! offset in fIndPoints - if there are 2 rows, that contain terminal nodes; double*fRange[fNDimm] range of data for each dimension; Int_tfRowT0! smallest terminal row - first row that contains terminal nodes; Int_tfTotalNodestotal number of nodes (fNNodes + terminal nodes); double*fValue[fNNodes] nodes cutting value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TKDTree<Index, Value> Build(). Build the kd-tree. 1. calculate number of nodes; 2. calculate first terminal row; 3. initialize index array; 4. non recursive building of the binary tree. The tree is divided recursively. See class description, section 4b for the details; of the division alogrithm. void TKDTree<Index, Value> FindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); Find kNN nearest neighbors to the point in the first argument; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const double* point, Int_t kNN, int* ind, double* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const double* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const double* point) const; returns the in",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:19760,Availability,failure,failure,19760,"turns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const double* point, Int_t kNN, int* ind, double* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const double* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const double* point) const; returns the index of the terminal node to which point belongs; (index in the fAxis, fValue, etc arrays); returns -1 in case of failure. void TKDTree<Index, Value> FindPoint(double* point, int& index, Int_t& iter). find the index of point; works only if we keep fData pointers. void TKDTree<Index, Value> FindInRange(double* point, double range, vector<int>& res); Find all points in the sphere of a given radius ""range"" around the given point; 1st argument - the point; 2nd argument - radius of the shere; 3rd argument - a vector, in which the results will be returned. void TKDTree<Index, Value> UpdateRange(int inode, double* point, double range, vector<int>& res); Internal recursive function with the implementation of range searches. Index* TKDTree<Index, Value> GetPointsIndexes(Int_t node) const; return the indices of the points in that terminal node; for all the nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize. void TKDTree<Index, Value> GetNodePointsIndexes(Int_t node, Int_t& first1, ",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:6589,Energy Efficiency,consumption,consumption,6589," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:4038,Integrability,interface,interface,4038,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:4348,Modifiability,variab,variables,4348,"ave memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npoints; i++){; data0[i]=gRandom->Uniform(xmin, xmax);; data1[i]=gRandom->Uniform(xmin, xmax);; data2[i]=gRandom->Uniform(xmin, xmax);; }; TKDTreeID *kdtree = new TKDTreeID(npoints, ndim, bsize);; kdtree->SetData(0, data0);; kdtree->SetData(1, data1);; kdtree->SetData(2, data2);; kdtree->Build();; }. By default, the kd-tree doesn't own the data and doesn't delete it with itself. If you want the; data to ",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:24742,Modifiability,variab,variables,24742,"l node with just one point minimum and maximum for each; dimension are the same.; Boundaries can be retrieved by calling GetBoundaryExact(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> FindBNodeA(double* point, double* delta, Int_t& inode). find the smallest node covering the full range - start. Value* TKDTree<Index, Value> GetBoundaries(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundariesExact(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundary(const Int_t node); Get a boundary. Value* TKDTree<Index, Value> GetBoundaryExact(const Int_t node); Get a boundary. Int_t GetLeft(Int_t inode) const; Get indexes of left and right daughter nodes. {return inode*2+1;}. Int_t GetRight(Int_t inode) const; {return (inode+1)*2;}. Int_t GetParent(Int_t inode) const. Other getters. {return (inode-1)/2;}. UChar_t GetNodeAxis(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fAxis[id];}. Value GetNodeValue(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fValue[id];}. Int_t GetNNodes() const; {return fNNodes;}. Int_t GetTotalNodes() const; {return fTotalNodes;}. Index GetNPoints(); { return fNPoints; }. Index GetNDim(); { return fNDim; }. Int_t GetRowT0(); Getters for internal variables. {return fRowT0;}. Int_t GetCrossNode(); {return fCrossNode;}. Int_t GetOffset(); {return fOffset;}. Index* GetIndPoints(); {return fIndPoints;}. Index GetBucketSize(); {return fBucketSize;}. Bool_t IsTerminal(int inode) const; {return (inode>=fNNodes);}. Int_t IsOwner(); { return fDataOwner; }. void SetOwner(Int_t owner); { fDataOwner = owner; }. TKDTree<Index, Value>& operator=(const TKDTree<int,double>& ). » Last changed: Tue Jun 2 16:13:49 2015 » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:3473,Performance,optimiz,optimized,3473,"is method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtre",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:6560,Performance,optimiz,optimized,6560," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:8725,Performance,perform,performed,8725,"Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes. Non ideal case:; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes. 3b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0). For example, let n_nodes=67. Then, the closest 2^k=64, 2^k-1=32, 2^k-2=16.; Left node gets 32+3=35 sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. 3c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. fRange : array containing the boundaries of the domain:; | 1st dimension (min + max) | 2nd dimension (min + max) | ...; fBoundaries : nodes boundaries; | 1st node {1st dim * 2 elements | 2nd dim * 2 elements | ...} | 2nd n",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:22236,Performance,perform,performed,22236," the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, double** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, double* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, double* a, int* index, double& min, double& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, double* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(double* range = 0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Va",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:7100,Security,access,access,7100,"ing the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the indices, corresponding to; children nodes or the parent node:; Suppose, the parent node is stored under the index inode. Then:; Left child index = inode*2+1; Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the follo",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:2864,Usability,simpl,simple,2864,"-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tre",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_double_.html:4118,Usability,simpl,simplify,4118,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html604/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_double_.html
https://root.cern/root/html604/TKDTree_int_float_.html:1957,Availability,down,down,1957,"ng a multidimensional search key (e.g. range searches and; nearest neighbour searches). kd-trees are a special case of BSP trees. A kd-tree uses only splitting planes that are perpendicular to one of the coordinate system axes.; This differs from BSP trees, in which arbitrary splitting planes can be used.; In addition, in the typical definition every node of a kd-tree, from the root to the leaves, stores a point.; This differs from BSP trees, in which leaves are typically the only nodes that contain points; (or other geometric primitives). As a consequence, each splitting plane must go through one of; the points in the kd-tree. kd-trees are a variant that store data only in leaf nodes. 2. Constructing a classical kd-tree ( Pseudo code). Since there are many possible ways to choose axis-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return n",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:11213,Availability,error,error,11213,"tion_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const float* point, int ind, Int_t type = 2) const; voidDistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(float* point, float* delta, Int_t& inode); voidFindInRange(float* point, float range, vector<int>& res); voidFindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); intFindNode(const float* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(float* point, int& index, Int_t& iter); float*GetBoundaries(); float*GetBoundariesExact(); float*GetBoundary(const Int_t node); float*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:11297,Availability,error,error,11297,"TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const float* point, int ind, Int_t type = 2) const; voidDistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(float* point, float* delta, Int_t& inode); voidFindInRange(float* point, float range, vector<int>& res); voidFindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); intFindNode(const float* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(float* point, int& index, Int_t& iter); float*GetBoundaries(); float*GetBoundariesExact(); float*GetBoundary(const Int_t node); float*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode) const; virtual const char*TObject::GetName() const; intGetNDim(); Int_tGetNNodes()",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:18645,Availability,failure,failure,18645," intfNDimnumber of dimensions; intfNDimmdummy 2*fNDim; Int_tfNNodessize of node array; intfNPointsnumber of multidimensional points; Int_tfOffset! offset in fIndPoints - if there are 2 rows, that contain terminal nodes; float*fRange[fNDimm] range of data for each dimension; Int_tfRowT0! smallest terminal row - first row that contains terminal nodes; Int_tfTotalNodestotal number of nodes (fNNodes + terminal nodes); float*fValue[fNNodes] nodes cutting value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TKDTree<Index, Value> Build(). Build the kd-tree. 1. calculate number of nodes; 2. calculate first terminal row; 3. initialize index array; 4. non recursive building of the binary tree. The tree is divided recursively. See class description, section 4b for the details; of the division alogrithm. void TKDTree<Index, Value> FindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); Find kNN nearest neighbors to the point in the first argument; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const float* point, Int_t kNN, int* ind, float* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const float* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const float* point) const; returns the index of t",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:19706,Availability,failure,failure,19706,"nt; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const float* point, Int_t kNN, int* ind, float* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const float* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const float* point) const; returns the index of the terminal node to which point belongs; (index in the fAxis, fValue, etc arrays); returns -1 in case of failure. void TKDTree<Index, Value> FindPoint(float* point, int& index, Int_t& iter). find the index of point; works only if we keep fData pointers. void TKDTree<Index, Value> FindInRange(float* point, float range, vector<int>& res); Find all points in the sphere of a given radius ""range"" around the given point; 1st argument - the point; 2nd argument - radius of the shere; 3rd argument - a vector, in which the results will be returned. void TKDTree<Index, Value> UpdateRange(int inode, float* point, float range, vector<int>& res); Internal recursive function with the implementation of range searches. Index* TKDTree<Index, Value> GetPointsIndexes(Int_t node) const; return the indices of the points in that terminal node; for all the nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize. void TKDTree<Index, Value> GetNodePointsIndexes(Int_t node, Int_t& first1, Int_t",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:6586,Energy Efficiency,consumption,consumption,6586," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:4035,Integrability,interface,interface,4035,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:4345,Modifiability,variab,variables,4345,"ave memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npoints; i++){; data0[i]=gRandom->Uniform(xmin, xmax);; data1[i]=gRandom->Uniform(xmin, xmax);; data2[i]=gRandom->Uniform(xmin, xmax);; }; TKDTreeID *kdtree = new TKDTreeID(npoints, ndim, bsize);; kdtree->SetData(0, data0);; kdtree->SetData(1, data1);; kdtree->SetData(2, data2);; kdtree->Build();; }. By default, the kd-tree doesn't own the data and doesn't delete it with itself. If you want the; data to ",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:24674,Modifiability,variab,variables,24674,"inal node with just one point minimum and maximum for each; dimension are the same.; Boundaries can be retrieved by calling GetBoundaryExact(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> FindBNodeA(float* point, float* delta, Int_t& inode). find the smallest node covering the full range - start. Value* TKDTree<Index, Value> GetBoundaries(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundariesExact(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundary(const Int_t node); Get a boundary. Value* TKDTree<Index, Value> GetBoundaryExact(const Int_t node); Get a boundary. Int_t GetLeft(Int_t inode) const; Get indexes of left and right daughter nodes. {return inode*2+1;}. Int_t GetRight(Int_t inode) const; {return (inode+1)*2;}. Int_t GetParent(Int_t inode) const. Other getters. {return (inode-1)/2;}. UChar_t GetNodeAxis(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fAxis[id];}. Value GetNodeValue(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fValue[id];}. Int_t GetNNodes() const; {return fNNodes;}. Int_t GetTotalNodes() const; {return fTotalNodes;}. Index GetNPoints(); { return fNPoints; }. Index GetNDim(); { return fNDim; }. Int_t GetRowT0(); Getters for internal variables. {return fRowT0;}. Int_t GetCrossNode(); {return fCrossNode;}. Int_t GetOffset(); {return fOffset;}. Index* GetIndPoints(); {return fIndPoints;}. Index GetBucketSize(); {return fBucketSize;}. Bool_t IsTerminal(int inode) const; {return (inode>=fNNodes);}. Int_t IsOwner(); { return fDataOwner; }. void SetOwner(Int_t owner); { fDataOwner = owner; }. TKDTree<Index, Value>& operator=(const TKDTree<int,float>& ). » Last changed: Tue Jun 2 16:13:52 2015 » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:3470,Performance,optimiz,optimized,3470,"is method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtre",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:6557,Performance,optimiz,optimized,6557," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:8722,Performance,perform,performed,8722,"Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes. Non ideal case:; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes. 3b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0). For example, let n_nodes=67. Then, the closest 2^k=64, 2^k-1=32, 2^k-2=16.; Left node gets 32+3=35 sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. 3c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. fRange : array containing the boundaries of the domain:; | 1st dimension (min + max) | 2nd dimension (min + max) | ...; fBoundaries : nodes boundaries; | 1st node {1st dim * 2 elements | 2nd dim * 2 elements | ...} | 2nd n",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:22175,Performance,perform,performed,22175,"of the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, float** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, float* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, float* a, int* index, float& min, float& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, float* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(float* range = 0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> C",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:7097,Security,access,access,7097,"ing the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the indices, corresponding to; children nodes or the parent node:; Suppose, the parent node is stored under the index inode. Then:; Left child index = inode*2+1; Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the follo",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:2861,Usability,simpl,simple,2861,"-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tre",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKDTree_int_float_.html:4115,Usability,simpl,simplify,4115,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html604/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKDTree_int_float_.html
https://root.cern/root/html604/TKey.html:897,Availability,redundant,redundant,897,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) cons",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:2541,Availability,error,error,2541," virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) cons",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:2625,Availability,error,error,2625,"bject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*GetBufferRef() const; virtual const char*GetClassName() const; Short_tGetCycle() const; const TDatime&GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*GetIconName() const; Short_tGetKeep() const; Int_tGetKeylen() const; TDirectory*GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetObjlen() const; virtual Option_t*TObject::GetOption() const; virtual Long64_tGetSeekKey() const; virtual Long64_tGetS",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:17631,Availability,error,error,17631," The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situation will add key to gDirectory ???. void ReadKeyBuffer(char*& buffer); Decode input buffer. Bool_t ReadFile(); Read the key structure from the file. void SetParent(const TObject* parent); Set parent in key buffer. void Reset(); Reset the key as it had not been 'filled' yet. Int_t Sizeof() const; Return the size in bytes of the key header structure.; Int_t nbytes = sizeof fNbytes; 4; += sizeof(Version_t); 2; += sizeof fObjlen; 4; += sizeof fKeylen; 2; += sizeof fCycle; 2; += sizeof fSeekKey; 4 or 8; += sizeof fSeekPdir; 4 or 8; = 22. void Streamer(TBuffer& ); Stream a class object. Int_t WriteFile(Int_t cycle = 1, TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. Int_t WriteFileKeepBuffer(TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. const char * GetIconName() const; Title can keep 32x32 xpm thumbnail/icon of the parent object. const char * GetTitle() const; Returns title (title can contain 32x32 xpm thumbnail/icon). TKey(const TKey& ). TKey& operator=(const TKey& ). Int_t Read(const char* name); { return TObject::Read(name); }. const char * GetClassName() const; {return fClassName.Data();}. char * GetBuffer() const; {return fBuffer+fKeylen;}. TBuffer * GetBufferRef() const; {return fBufferRef;}. const TDatime & GetDatime() const; {return fDatime;}. Int_t GetKeylen() const; {return fKeylen;}. TDirectory* GetMotherDir() const; { return fMotherDir; }. Int_t GetNbytes() const; {return fNbytes;}. Int_t GetObjlen() const; {return fObjlen;}. Int_t GetVersion() const; {return fV",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:17847,Availability,error,error,17847,"ituation will add key to gDirectory ???. void ReadKeyBuffer(char*& buffer); Decode input buffer. Bool_t ReadFile(); Read the key structure from the file. void SetParent(const TObject* parent); Set parent in key buffer. void Reset(); Reset the key as it had not been 'filled' yet. Int_t Sizeof() const; Return the size in bytes of the key header structure.; Int_t nbytes = sizeof fNbytes; 4; += sizeof(Version_t); 2; += sizeof fObjlen; 4; += sizeof fKeylen; 2; += sizeof fCycle; 2; += sizeof fSeekKey; 4 or 8; += sizeof fSeekPdir; 4 or 8; = 22. void Streamer(TBuffer& ); Stream a class object. Int_t WriteFile(Int_t cycle = 1, TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. Int_t WriteFileKeepBuffer(TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. const char * GetIconName() const; Title can keep 32x32 xpm thumbnail/icon of the parent object. const char * GetTitle() const; Returns title (title can contain 32x32 xpm thumbnail/icon). TKey(const TKey& ). TKey& operator=(const TKey& ). Int_t Read(const char* name); { return TObject::Read(name); }. const char * GetClassName() const; {return fClassName.Data();}. char * GetBuffer() const; {return fBuffer+fKeylen;}. TBuffer * GetBufferRef() const; {return fBufferRef;}. const TDatime & GetDatime() const; {return fDatime;}. Int_t GetKeylen() const; {return fKeylen;}. TDirectory* GetMotherDir() const; { return fMotherDir; }. Int_t GetNbytes() const; {return fNbytes;}. Int_t GetObjlen() const; {return fObjlen;}. Int_t GetVersion() const; {return fVersion;}. Long64_t GetSeekKey() const; {return fSeekKey;}. Long64_t GetSeekPdir() const; {return fSeekPdir;}. void SetBuffer(); { fBuffer = new char[fNbytes];}. void SetMotherDir(TDirectory* dir); { fMotherDir = dir;",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:11851,Energy Efficiency,allocate,allocated,11851,"ression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You still have to call ""delete key"".; This is different from the behaviour of TObject::Delete()!. void DeleteBuffer(); Delete key buffer(s). Short_t GetCycle() const; Return cycle number associated to this key. TFile * GetFile() const; Returns file to which key belong. Short_t GetKeep() const; Returns the ""KEEP"" status. void FillBuffer(char*& buffer); Encode key header into output buffer. ULong_t Hash() const; This Hash function should redefine the default from TNamed. void IncrementPidOffset(UShort_t offset); Increment fPidOffset by 'offset'.; This offset is used when a key (or basket) is transfered from one file to; the other. In this case the TRef and TObject might have stored a pid; index (to retrieve TProcessIDs) which refered to their order on the; origin",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:14044,Modifiability,inherit,inheritance,14044,"o for new key/basket. Bool_t IsFolder() const; Check if object referenced by the key is a folder. void Keep(); Set the ""KEEP"" status.; When the KEEP flag is set to 1 the object cannot be purged. void ls(Option_t* option = """") const; List Key contents. void Print(Option_t* option = """") const; Print key contents. TObject * ReadObj(); To read a TObject* from the file. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass ",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:14421,Modifiability,inherit,inheritance,14421," The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. v",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:15851,Modifiability,inherit,inherits,15851,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:14303,Performance,perform,performance,14303," The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. v",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:897,Safety,redund,redundant,897,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) cons",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:10196,Safety,avoid,avoid,10196,"saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. private:. static TKey::EStatusBitskIsDirectoryFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char*",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:10495,Safety,avoid,avoid,10495,"mbers; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:10759,Safety,avoid,avoid,10759,"erDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFil",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:11057,Safety,avoid,avoid,11057,"Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You s",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:15918,Safety,safe,safely,15918,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:954,Security,integrity,integrity,954,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) cons",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKey.html:14107,Usability,simpl,simplified,14107," object cannot be purged. void ls(Option_t* option = """") const; List Key contents. void Print(Option_t* option = """") const; Print key contents. TObject * ReadObj(); To read a TObject* from the file. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only i",MatchSource.WIKI,root/html604/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKey.html
https://root.cern/root/html604/TKeyMapFile.html:1607,Availability,error,error,1607," virtual~TKeyMapFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html604/TKeyMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyMapFile.html
https://root.cern/root/html604/TKeyMapFile.html:1691,Availability,error,error,1691,"File(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html604/TKeyMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyMapFile.html
https://root.cern/root/html604/TKeySQL.html:1423,Availability,error,error,1423," virtual~TKeySQL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const;",MatchSource.WIKI,root/html604/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeySQL.html
https://root.cern/root/html604/TKeySQL.html:1507,Availability,error,error,1507,":AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Long64_tGetDBDirId() const; Long64_tGetDBKeyId() const; Long64_tGetDBObjId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetOb",MatchSource.WIKI,root/html604/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeySQL.html
https://root.cern/root/html604/TKeySQL.html:10389,Availability,error,error,10389,"st char* classname); Create TKeySQL object, which correponds to single entry in keys table. ~TKeySQL(); TKeySQL destructor. Bool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type from SQL database. void* ReadKeyObject(void* obj, const TClass* expectedClass); Read object, associated with key, from database. TKeySQL(const TKeySQL& ). TKeySQL& operator=(const TKeySQL& ). Int_t Read(const char* name); { return TKey::Read(name); }. Long64_t GetDBKeyId() const; { return fKeyId; }. Long64_t GetDBObjId() const; { return fObjId; }. void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return GetDBObjId() > 0 ? GetDBObjId() : 0; }. Long64_t GetSeekPdir() const; { return GetDBDirId() > 0 ? GetDBDirId() : 0; }. void Keep(); {}. void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t W",MatchSource.WIKI,root/html604/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeySQL.html
https://root.cern/root/html604/TKeySQL.html:10527,Availability,error,error,10527,"ool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type from SQL database. void* ReadKeyObject(void* obj, const TClass* expectedClass); Read object, associated with key, from database. TKeySQL(const TKeySQL& ). TKeySQL& operator=(const TKeySQL& ). Int_t Read(const char* name); { return TKey::Read(name); }. Long64_t GetDBKeyId() const; { return fKeyId; }. Long64_t GetDBObjId() const; { return fObjId; }. void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return GetDBObjId() > 0 ? GetDBObjId() : 0; }. Long64_t GetSeekPdir() const; { return GetDBDirId() > 0 ? GetDBDirId() : 0; }. void Keep(); {}. void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t WriteFile(Int_t = 1, TFile* = 0); { return 0; }. » Author: Sergey Linev 20/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fo",MatchSource.WIKI,root/html604/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeySQL.html
https://root.cern/root/html604/TKeySQL.html:9753,Deployability,update,updated,9753,"64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKeySQL(); default constructor. TKeySQL(TDirectory* mother, const TObject* obj, const char* name, const char* title = 0); Creates TKeySQL and convert obj data to TSQLStructure via TBufferSQL2. TKeySQL(TDirectory* mother, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeySQL and convert obj data to TSQLStructure via TBufferSQL2. TKeySQL(TDirectory* mother, Long64_t keyid, Long64_t objid, const char* name, const char* title, const char* keydatetime, Int_t cycle, const char* classname); Create TKeySQL object, which correponds to single entry in keys table. ~TKeySQL(); TKeySQL destructor. Bool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type",MatchSource.WIKI,root/html604/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeySQL.html
https://root.cern/root/html604/TKeyXML.html:1405,Availability,error,error,1405," virtual~TKeyXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; virtual Option_t*",MatchSource.WIKI,root/html604/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyXML.html
https://root.cern/root/html604/TKeyXML.html:1489,Availability,error,error,1489,":AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Long64_tGetKeyId() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t",MatchSource.WIKI,root/html604/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyXML.html
https://root.cern/root/html604/TKeyXML.html:10216,Availability,error,error,10216,"es TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return fKeyNode ? 1024 : 0;}. Long64_t GetSeekPdir() const; virtual ULong_t Hash() const { return 0; }. { return fKeyNode ? 1024 : 0;}. void Keep(); virtual void ls(Option_t* ="""") const;; virtual void Print(Option_t* ="""") const {}. {}. Int_t Read(TObject* tobj). void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. ",MatchSource.WIKI,root/html604/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyXML.html
https://root.cern/root/html604/TKeyXML.html:10364,Availability,error,error,10364,"ML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return fKeyNode ? 1024 : 0;}. Long64_t GetSeekPdir() const; virtual ULong_t Hash() const { return 0; }. { return fKeyNode ? 1024 : 0;}. void Keep(); virtual void ls(Option_t* ="""") const;; virtual void Print(Option_t* ="""") const {}. {}. Int_t Read(TObject* tobj). void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t WriteFile(Int_t = 1, TFile* = 0); { return 0; }. XMLNodePointer_t KeyNode() const; TKeyXML sp",MatchSource.WIKI,root/html604/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyXML.html
https://root.cern/root/html604/TKeyXML.html:9761,Deployability,update,update,9761,"rts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {",MatchSource.WIKI,root/html604/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyXML.html
https://root.cern/root/html604/TKeyXML.html:9829,Deployability,update,updates,9829," TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return",MatchSource.WIKI,root/html604/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyXML.html
https://root.cern/root/html604/TKeyXML.html:9890,Deployability,update,update,9890," TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return",MatchSource.WIKI,root/html604/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKeyXML.html
https://root.cern/root/html604/TKSocket.html:1440,Availability,error,error,1440,"tion = """"); Int_tBlockRead(char*& buf, TKSocket::EEncoding& type); Int_tBlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TKSocket*Connect(const char* server, Int_t port); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKSocket.html
https://root.cern/root/html604/TKSocket.html:1524,Availability,error,error,1524,"onst char* buf, Int_t len, TKSocket::EEncoding type); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TKSocket*Connect(const char* server, Int_t port); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKSocket.html
https://root.cern/root/html604/TKSocket.html:6569,Availability,error,error,6569,"ocket(TSocket* s = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TKSocket::EEncodingkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TKSocket::EEncodingkPriv; static TKSocket::EEncodingkSafe; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. krb5_auth_contextfAuthContextper connection kerberos authentication context; krb5_principalfServerserver principal; TSocket*fSocketunderlying socket; static krb5_ccachefgCCDefshared default credential cache; static krb5_principalfgClientclient principal; static krb5_contextfgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKSocket.html
https://root.cern/root/html604/TKSocket.html:6035,Performance,cache,cache,6035,"ocket(TSocket* s = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TKSocket::EEncodingkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TKSocket::EEncodingkPriv; static TKSocket::EEncodingkSafe; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. krb5_auth_contextfAuthContextper connection kerberos authentication context; krb5_principalfServerserver principal; TSocket*fSocketunderlying socket; static krb5_ccachefgCCDefshared default credential cache; static krb5_principalfgClientclient principal; static krb5_contextfgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKSocket.html
https://root.cern/root/html604/TKSocket.html:5887,Security,authenticat,authentication,5887,"ocket(TSocket* s = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TKSocket::EEncodingkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TKSocket::EEncodingkPriv; static TKSocket::EEncodingkSafe; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. krb5_auth_contextfAuthContextper connection kerberos authentication context; krb5_principalfServerserver principal; TSocket*fSocketunderlying socket; static krb5_ccachefgCCDefshared default credential cache; static krb5_principalfgClientclient principal; static krb5_contextfgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TKSocket.html
https://root.cern/root/html604/TLatex.html:4195,Availability,down,downarrow,4195,"q"") ; Tl.DrawText(x2, y, ""#leq"");; y -= step ; Tl.DrawLatex(x1, y, ""#approx"") ; Tl.DrawText(x2, y, ""#approx"");; y -= step ; Tl.DrawLatex(x1, y, ""#in"") ; Tl.DrawText(x2, y, ""#in"");; y -= step ; Tl.DrawLatex(x1, y, ""#supset"") ; Tl.DrawText(x2, y, ""#supset"");; y -= step ; Tl.DrawLatex(x1, y, ""#cap"") ; Tl.DrawText(x2, y, ""#cap"");; y -= step ; Tl.DrawLatex(x1, y, ""#ocopyright"") ; Tl.DrawText(x2, y, ""#ocopyright"");; y -= step ; Tl.DrawLatex(x1, y, ""#trademark"") ; Tl.DrawText(x2, y, ""#trademark"");; y -= step ; Tl.DrawLatex(x1, y, ""#times"") ; Tl.DrawText(x2, y, ""#times"");; y -= step ; Tl.DrawLatex(x1, y, ""#bullet"") ; Tl.DrawText(x2, y, ""#bullet"");; y -= step ; Tl.DrawLatex(x1, y, ""#voidb"") ; Tl.DrawText(x2, y, ""#voidb"");; y -= step ; Tl.DrawLatex(x1, y, ""#doublequote"") ; Tl.DrawText(x2, y, ""#doublequote"");; y -= step ; Tl.DrawLatex(x1, y, ""#lbar"") ; Tl.DrawText(x2, y, ""#lbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbottom"") ; Tl.DrawText(x2, y, ""#arcbottom"");; y -= step ; Tl.DrawLatex(x1, y, ""#downarrow"") ; Tl.DrawText(x2, y, ""#downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#leftrightarrow"") ; Tl.DrawText(x2, y, ""#leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Downarrow"") ; Tl.DrawText(x2, y, ""#Downarrow"");. // Draw Second Column; y = 0.96; x1 = 0.22; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#Leftrightarrow"") ; Tl.DrawText(x2, y, ""#Leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#void8"") ; Tl.DrawText(x2, y, ""#void8"");; y -= step ; Tl.DrawLatex(x1, y, ""#hbar"") ; Tl.DrawText(x2, y, ""#hbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#diamond"") ; Tl.DrawText(x2, y, ""#diamond"");; y -= step ; Tl.DrawLatex(x1, y, ""#aleph"") ; Tl.DrawText(x2, y, ""#aleph"");; y -= step ; Tl.DrawLatex(x1, y, ""#geq"") ; Tl.DrawText(x2, y, ""#geq"");; y -= step ; Tl.DrawLatex(x1, y, ""#neq"") ; Tl.DrawText(x2, y, ""#neq"");; y -= step ; Tl.DrawLatex(x1, y, ""#notin"") ; Tl.DrawText(x2, y, ""#notin"");; y -= step ; Tl.DrawLatex(x1, y, ""#subseteq"") ; Tl.DrawText(x2, y, ""#subseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:4230,Availability,down,downarrow,4230,"tep ; Tl.DrawLatex(x1, y, ""#approx"") ; Tl.DrawText(x2, y, ""#approx"");; y -= step ; Tl.DrawLatex(x1, y, ""#in"") ; Tl.DrawText(x2, y, ""#in"");; y -= step ; Tl.DrawLatex(x1, y, ""#supset"") ; Tl.DrawText(x2, y, ""#supset"");; y -= step ; Tl.DrawLatex(x1, y, ""#cap"") ; Tl.DrawText(x2, y, ""#cap"");; y -= step ; Tl.DrawLatex(x1, y, ""#ocopyright"") ; Tl.DrawText(x2, y, ""#ocopyright"");; y -= step ; Tl.DrawLatex(x1, y, ""#trademark"") ; Tl.DrawText(x2, y, ""#trademark"");; y -= step ; Tl.DrawLatex(x1, y, ""#times"") ; Tl.DrawText(x2, y, ""#times"");; y -= step ; Tl.DrawLatex(x1, y, ""#bullet"") ; Tl.DrawText(x2, y, ""#bullet"");; y -= step ; Tl.DrawLatex(x1, y, ""#voidb"") ; Tl.DrawText(x2, y, ""#voidb"");; y -= step ; Tl.DrawLatex(x1, y, ""#doublequote"") ; Tl.DrawText(x2, y, ""#doublequote"");; y -= step ; Tl.DrawLatex(x1, y, ""#lbar"") ; Tl.DrawText(x2, y, ""#lbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbottom"") ; Tl.DrawText(x2, y, ""#arcbottom"");; y -= step ; Tl.DrawLatex(x1, y, ""#downarrow"") ; Tl.DrawText(x2, y, ""#downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#leftrightarrow"") ; Tl.DrawText(x2, y, ""#leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Downarrow"") ; Tl.DrawText(x2, y, ""#Downarrow"");. // Draw Second Column; y = 0.96; x1 = 0.22; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#Leftrightarrow"") ; Tl.DrawText(x2, y, ""#Leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#void8"") ; Tl.DrawText(x2, y, ""#void8"");; y -= step ; Tl.DrawLatex(x1, y, ""#hbar"") ; Tl.DrawText(x2, y, ""#hbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#diamond"") ; Tl.DrawText(x2, y, ""#diamond"");; y -= step ; Tl.DrawLatex(x1, y, ""#aleph"") ; Tl.DrawText(x2, y, ""#aleph"");; y -= step ; Tl.DrawLatex(x1, y, ""#geq"") ; Tl.DrawText(x2, y, ""#geq"");; y -= step ; Tl.DrawLatex(x1, y, ""#neq"") ; Tl.DrawText(x2, y, ""#neq"");; y -= step ; Tl.DrawLatex(x1, y, ""#notin"") ; Tl.DrawText(x2, y, ""#notin"");; y -= step ; Tl.DrawLatex(x1, y, ""#subseteq"") ; Tl.DrawText(x2, y, ""#subseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#cup"") ; Tl.DrawText(x2, y, ""#cup"");; y -= ",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:7399,Availability,down,downleftarrow,7399,"DrawText(x2, y, ""#heart"");; y -= step ; Tl.DrawLatex(x1, y, ""#Jgothic"") ; Tl.DrawText(x2, y, ""#Jgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#LT"") ; Tl.DrawText(x2, y, ""#LT"");; y -= step ; Tl.DrawLatex(x1, y, ""#equiv"") ; Tl.DrawText(x2, y, ""#equiv"");; y -= step ; Tl.DrawLatex(x1, y, ""#subset"") ; Tl.DrawText(x2, y, ""#subset"");; y -= step ; Tl.DrawLatex(x1, y, ""#supseteq"") ; Tl.DrawText(x2, y, ""#supseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#wedge"") ; Tl.DrawText(x2, y, ""#wedge"");; y -= step ; Tl.DrawLatex(x1, y, ""#oright"") ; Tl.DrawText(x2, y, ""#oright"");; y -= step ; Tl.DrawLatex(x1, y, ""#AA"") ; Tl.DrawText(x2, y, ""#AA"");; y -= step ; Tl.DrawLatex(x1, y, ""#pm"") ; Tl.DrawText(x2, y, ""#pm"");; y -= step ; Tl.DrawLatex(x1, y, ""#mp"") ; Tl.DrawText(x2, y, ""#mp"");; y -= step ; Tl.DrawLatex(x1, y, ""#3dots"") ; Tl.DrawText(x2, y, ""#3dots"");. // Draw Fourth Column; y = 0.96; x1 = 0.62; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#nabla"") ; Tl.DrawText(x2, y, ""#nabla"");; y -= step ; Tl.DrawLatex(x1, y, ""#downleftarrow"") ; Tl.DrawText(x2, y, ""#downleftarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#topbar"") ; Tl.DrawText(x2, y, ""#topbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbar"") ; Tl.DrawText(x2, y, ""#arcbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#uparrow"") ; Tl.DrawText(x2, y, ""#uparrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#oplus"") ; Tl.DrawText(x2, y, ""#oplus"");; y -= step ; Tl.DrawLatex(x1, y, ""#Uparrow"") ; Tl.DrawText(x2, y, ""#Uparrow"");; y -= step ; Tl.DrawLatex(x1, y-0.01, ""#sum"") ; Tl.DrawText(x2, y, ""#sum"");; y -= step ; Tl.DrawLatex(x1, y, ""#perp"") ; Tl.DrawText(x2, y, ""#perp"");; y -= step ; Tl.DrawLatex(x1, y, ""#forall"") ; Tl.DrawText(x2, y, ""#forall"");; y -= step ; Tl.DrawLatex(x1, y, ""#spade"") ; Tl.DrawText(x2, y, ""#spade"");; y -= step ; Tl.DrawLatex(x1, y, ""#Rgothic"") ; Tl.DrawText(x2, y, ""#Rgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#GT"") ; Tl.DrawText(x2, y, ""#GT"");; y -= step ; Tl.DrawLatex(x1, y, ""#propto"") ; Tl.DrawText(x2, y, ""#propto"");; y -= step ; Tl.DrawLatex(x1, y,",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:7438,Availability,down,downleftarrow,7438,"awLatex(x1, y, ""#Jgothic"") ; Tl.DrawText(x2, y, ""#Jgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#LT"") ; Tl.DrawText(x2, y, ""#LT"");; y -= step ; Tl.DrawLatex(x1, y, ""#equiv"") ; Tl.DrawText(x2, y, ""#equiv"");; y -= step ; Tl.DrawLatex(x1, y, ""#subset"") ; Tl.DrawText(x2, y, ""#subset"");; y -= step ; Tl.DrawLatex(x1, y, ""#supseteq"") ; Tl.DrawText(x2, y, ""#supseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#wedge"") ; Tl.DrawText(x2, y, ""#wedge"");; y -= step ; Tl.DrawLatex(x1, y, ""#oright"") ; Tl.DrawText(x2, y, ""#oright"");; y -= step ; Tl.DrawLatex(x1, y, ""#AA"") ; Tl.DrawText(x2, y, ""#AA"");; y -= step ; Tl.DrawLatex(x1, y, ""#pm"") ; Tl.DrawText(x2, y, ""#pm"");; y -= step ; Tl.DrawLatex(x1, y, ""#mp"") ; Tl.DrawText(x2, y, ""#mp"");; y -= step ; Tl.DrawLatex(x1, y, ""#3dots"") ; Tl.DrawText(x2, y, ""#3dots"");. // Draw Fourth Column; y = 0.96; x1 = 0.62; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#nabla"") ; Tl.DrawText(x2, y, ""#nabla"");; y -= step ; Tl.DrawLatex(x1, y, ""#downleftarrow"") ; Tl.DrawText(x2, y, ""#downleftarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#topbar"") ; Tl.DrawText(x2, y, ""#topbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbar"") ; Tl.DrawText(x2, y, ""#arcbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#uparrow"") ; Tl.DrawText(x2, y, ""#uparrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#oplus"") ; Tl.DrawText(x2, y, ""#oplus"");; y -= step ; Tl.DrawLatex(x1, y, ""#Uparrow"") ; Tl.DrawText(x2, y, ""#Uparrow"");; y -= step ; Tl.DrawLatex(x1, y-0.01, ""#sum"") ; Tl.DrawText(x2, y, ""#sum"");; y -= step ; Tl.DrawLatex(x1, y, ""#perp"") ; Tl.DrawText(x2, y, ""#perp"");; y -= step ; Tl.DrawLatex(x1, y, ""#forall"") ; Tl.DrawText(x2, y, ""#forall"");; y -= step ; Tl.DrawLatex(x1, y, ""#spade"") ; Tl.DrawText(x2, y, ""#spade"");; y -= step ; Tl.DrawLatex(x1, y, ""#Rgothic"") ; Tl.DrawText(x2, y, ""#Rgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#GT"") ; Tl.DrawText(x2, y, ""#GT"");; y -= step ; Tl.DrawLatex(x1, y, ""#propto"") ; Tl.DrawText(x2, y, ""#propto"");; y -= step ; Tl.DrawLatex(x1, y, ""#notsubset"") ; Tl.DrawText(x2, y, ""#notsubse",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:15447,Availability,avail,available,15447,"au"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Upsilon : "") ; Tl.DrawLatex(x2, y, ""#Upsilon"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Phi : "") ; Tl.DrawLatex(x2, y, ""#Phi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Chi : "") ; Tl.DrawLatex(x2, y, ""#Chi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Psi : "") ; Tl.DrawLatex(x2, y, ""#Psi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Omega : "") ; Tl.DrawLatex(x2, y, ""#Omega"");. // Draw the variations; x1 = 0.73; x2 = x1+0.2;; y = 0.7500 ; Tl.DrawLatex(x1, y, ""varepsilon : "") ; Tl.DrawLatex(x2, y, ""#varepsilon"");; y = 0.6375 ; Tl.DrawLatex(x1, y, ""vartheta : "") ; Tl.DrawLatex(x2, y, ""#vartheta"");; y = 0.2625 ; Tl.DrawLatex(x1, y, ""varsigma : "") ; Tl.DrawLatex(x2, y, ""#varsigma"");; y = 0.1875 ; Tl.DrawLatex(x1, y, ""varUpsilon : "") ; Tl.DrawLatex(x2, y, ""#varUpsilon"");; y = 0.1500 ; Tl.DrawLatex(x1, y, ""varphi : "") ; Tl.DrawLatex(x2, y, ""#varphi"");; y = 0.0375 ; Tl.DrawLatex(x1, y, ""varomega : "") ; Tl.DrawLatex(x2, y, ""#varomega"");. return Gl;; }. Accents; Several kind of accents are available:. #hat = ; #check = ; #acute = ; #grave = ; #dot = ; #ddot = ; #tilde = . The special sign: #slash draws a slash on top of the text between brackets:. #slash{E}_{T} : . Bar and vectors sign are done the following way:. #bar{a}: ; #vec{a}: . Changing Style; One can change the font, the text color, or the text size at any time using :; #font[font-number]{...}, #color[color-number]{...}; and #scale[scale-factor]{...}; Examples:. #font[12]{Times Italic} and #font[22]{Times bold} : ; #color[2]{Red} and #color[4]{Blue} : ; #scale[1.2]{Bigger} and #scale[0.8]{Smaller} : . Alignment Rules; The TText alignment rules apply to the TLatex objects with one exception; concerning the vertical alignment:. if the vertical alignment = 1 , subscripts are not taken into account ; if the vertical alignment = 0 , the text is aligned to the box surrounding; the full text with sub and superscripts. This is illustrated by the following example:. Picture; Source. {; TCanvas Tlva(""Tlva"",""T",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:17795,Availability,down,down,17795,"awLatex(.2,.9,""K_{S}"");; latex.DrawLatex(.3,.9,""K^{*0}"");; latex.DrawLatex(.2,.8,longstring);. latex.SetTextAlign(12); //centered; latex.DrawLatex(.2,.6,""K_{S}"");; latex.DrawLatex(.3,.6,""K^{*0}"");; latex.DrawLatex(.2,.5,longstring);. latex.SetTextAlign(11); //default bottom alignment; latex.DrawLatex(.2,.4,""K_{S}"");; latex.DrawLatex(.3,.4,""K^{*0}"");; latex.DrawLatex(.2,.3,longstring);. latex.SetTextAlign(10); //special bottom alignment; latex.DrawLatex(.2,.2,""K_{S}"");; latex.DrawLatex(.3,.2,""K^{*0}"");; latex.DrawLatex(.2,.1,longstring);. latex.SetTextAlign(12);; latex.SetTextFont(72);; latex.DrawLatex(.1,.80,""13"");; latex.DrawLatex(.1,.55,""12"");; latex.DrawLatex(.1,.35,""11"");; latex.DrawLatex(.1,.18,""10"");; return Tlva;; }. Character Adjustement; The two commands #kern and #lower enable a better control; over character placement. The command #kern[(Float_t)dx]{text} moves; the output string horizontally by the fraction dx of its length.; Similarly, #lower[(Float_t)dy]{text} shifts the text up or down by; the fraction dy of its height.; Examples:. Positive k#kern[0.3]{e}#kern[0.3]{r}#kern[0.3]{n}#kern[0.3]{i}#kern[0.3]{n}#kern[0.3]{g}:. Negative k#kern[-0.3]{e}#kern[-0.3]{r}#kern[-0.3]{n}#kern[-0.3]{i}#kern[-0.3]{n}#kern[-0.3]{g}:. Vertical a#lower[0.2]{d}#lower[0.4]{j}#lower[0.1]{u}#lower[-0.1]{s}#lower[-0.3]{t}#lower[-0.4]{m}#lower[-0.2]{e}#lower[0.1]{n}t:. Italic and Boldface; Text can be turned italic or boldface using the commands; #it and #bf.; Examples:. #bf{bold}, #it{italic}, #bf{#it{bold italic}}, #bf{#bf{unbold}}}:. abc#alpha#beta#gamma, #it{abc#alpha#beta#gamma}:. Examples. Picture; Source. {; TCanvas ex1(""ex1"",""Latex"",500,600);; TLatex Tl;; Tl.SetTextAlign(12);; Tl.SetTextSize(0.04);; Tl.DrawLatex(0.1,0.8,""1) C(x) = d #sqrt{#frac{2}{#lambdaD}} #int^{x}_{0}cos(#frac{#pi}{2}t^{2})dt"");; Tl.DrawLatex(0.1,0.6,""2) C(x) = d #sqrt{#frac{2}{#lambdaD}} #int^{x}cos(#frac{#pi}{2}t^{2})dt"");; Tl.DrawLatex(0.1,0.4,""3) R = |A|^{2} = #frac{1}{2}(#[]{#frac{1}{2}+C(V)}^{",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:21840,Availability,error,error,21840,"idTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TLatex*DrawLatex(Double_t x, Double_t y, const char* text); TLatex*DrawLatexNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetHeight() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; v",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:21924,Availability,error,error,21924,"x, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TLatex*DrawLatex(Double_t x, Double_t y, const char* text); TLatex*DrawLatexNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetHeight() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:30850,Availability,error,error,30850,"atic TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TLatex::(anonymous)kTextNDC; static TText::(anonymous)TText::kTextNDC; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const Char_t*fError!error code; Double_tfFactorPos!Relative position of subscripts and superscripts; Double_tfFactorSize!Relative size of subscripts and superscripts; Bool_tfItalic!Currently inside italic operator; Int_tfLimitFactorSizelower bound for subscripts/superscripts size; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; Double_tfOriginSizeFont size of the starting font; Int_tfPos!Current position in array fTabSize;; Bool_tfShow!is true during the second pass (Painting); Int_tfTabMax!Maximum allocation for array fTabSize;; FormSize_t*fTabSize!array of values for the different zones; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; void*TText::fWcsTitle!Used by TMathText; Double_tTText::fXX position of text (left,center,etc..); Double_tTText::fYY position of text (left,center,etc..). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLatex(); Default constructor. TLatex(Double_t x, Double_t y, const char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextS",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:32990,Availability,down,down,32990,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. TLatex * DrawLatexNDC(Double_t x, Double_t y, const char* text); Draw this TLatex with new coordinates in NDC. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (rig",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:33145,Availability,down,down,33145,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. TLatex * DrawLatexNDC(Double_t x, Double_t y, const char* text); Draw this TLatex with new coordinates in NDC. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (rig",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLatex.html:33290,Availability,down,down,33290,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. TLatex * DrawLatexNDC(Double_t x, Double_t y, const char* text); Draw this TLatex with new coordinates in NDC. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (rig",MatchSource.WIKI,root/html604/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLatex.html
https://root.cern/root/html604/TLeaf.html:1318,Availability,error,error,1318," virtual~TLeaf(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeafCount() const",MatchSource.WIKI,root/html604/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeaf.html
https://root.cern/root/html604/TLeaf.html:1402,Availability,error,error,1402,"Leaf(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeafCount() const; virtual TLeaf*GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tGetLenStatic() const; virtual Int_tGetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual I",MatchSource.WIKI,root/html604/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeaf.html
https://root.cern/root/html604/TLeaf.html:9263,Integrability,rout,routine,9263,"ent of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, return countval = 1 and the pointer to; the leaf named nelem, otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; return countval = nelem and a null pointer.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]; where nelem and nelem2 are non-negative integers) then; return countval = product of all dimension sizes and a null pointer.; If leaf name has the form var[... (and does not match the previous 2; cases) return countval = -1 and null pointer;; Otherwise return countval = 1 and a null pointer. Int_t GetLen() const; -- Return the number of effective elements of this leaf. Int_t ResetAddress(void* add, Bool_t destructor = kFALSE); -- Helper routine for TLeafX::SetAddress. The return value is non-zero if we owned the old; value buffer and must delete it now. The size; of the value buffer is recalculated and stored,; and a decision is made whether or not we own the; new value buffer. void SetLeafCount(TLeaf* leaf); -- Set the leaf count of this leaf. void Streamer(TBuffer& ); -- Stream a class object. Double_t GetValue(Int_t i = 0) const; { return 0.0; }. void PrintValue(Int_t i = 0) const; {}. void SetAddress(void* add = 0); {}. void Export(TClonesArray* , Int_t ); {}. TBranch * GetBranch() const; { return fBranch; }. TLeaf * GetLeafCount() const; { return fLeafCount; }. Int_t GetLenStatic() const; { return fLen; }. Int_t GetLenType() const; { return fLenType; }. Int_t GetMaximum() const; { return 0; }. Int_t GetMinimum() const; { return 0; }. Int_t GetNdata() const; { return fNdata; }. Int_t GetOffset() const; { return fOffset; }. void * GetValuePointer() const; { return 0; }. const char * GetTypeName()",MatchSource.WIKI,root/html604/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeaf.html
https://root.cern/root/html604/TLeaf.html:7520,Modifiability,variab,variable,7520,"tic TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TLeaf::(anonymous)kIndirectAddress; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*fBranch! Pointer to supporting branch (we do not own the branch); Bool_tfIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tfIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tfLenNumber of fixed length elements; Int_tfLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tfNdata! Number of elements in fAddress data buffer; Int_tfOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeaf(). TLeaf(TBranch* parent, const char* name, const char* type); Create a Leaf. See the TTree and TBranch constructors for explanation of parameters. TLeaf(const TLeaf& ); copy constructor. TLeaf& operator=(const TLeaf& ); assignment operator. ~TLeaf(); -- Destructor. void Browse(TBrowser* b); Browse the content of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, return countval = 1 and the poi",MatchSource.WIKI,root/html604/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeaf.html
https://root.cern/root/html604/TLeafB.html:1284,Availability,error,error,1284," virtual~TLeafB(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLe",MatchSource.WIKI,root/html604/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafB.html
https://root.cern/root/html604/TLeafB.html:1368,Availability,error,error,1368," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html604/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafB.html
https://root.cern/root/html604/TLeafB.html:7776,Modifiability,variab,variable,7776,"atic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Char_tfMaximumMaximum value if leaf range is specified; Char_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Char_t**fPointer!Address of a pointer to data buffer!; TStringTNamed::fTitleobject title; Char_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafB(); -- Default constructor. TLeafB(TBranch* parent, const char* name, const char* type); -- Create a LeafB. ~TLeafB(); -- Destructor. void Export(TClonesArray* list, Int_t n); -- Export element from local leaf buffer to a ClonesArray. void FillBasket(TBuffer& b); -- Pack leaf elements into Basket output buffer. const char * GetTypeName() const; -- Returns name of leaf type. void Import(TClonesArray* list, Int_t n); -- Import element from ClonesArray into local leaf buffer. void PrintValue(In",MatchSource.WIKI,root/html604/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafB.html
https://root.cern/root/html604/TLeafC.html:1282,Availability,error,error,1282," virtual~TLeafC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf",MatchSource.WIKI,root/html604/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafC.html
https://root.cern/root/html604/TLeafC.html:1366,Availability,error,error,1366," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html604/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafC.html
https://root.cern/root/html604/TLeafC.html:291,Modifiability,variab,variable,291,". TLeafC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TLeafC. class TLeafC: public TLeaf. A TLeaf for a variable length string. Function Members (Methods); public:. virtual~TLeafC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf",MatchSource.WIKI,root/html604/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafC.html
https://root.cern/root/html604/TLeafC.html:7804,Modifiability,variab,variable,7804,"static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Int_tfMaximumMaximum value if leaf range is specified; Int_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Char_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Char_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafC(); Default constructor for LeafC*-*-*-*-*-*-*-*-; *-* ============================. TLeafC(TBranch* parent, const char* name, const char* type); Create a LeafC*-*-; *-* ==============; -. ~TLeafC(); Default destructor for a LeafC*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Ba",MatchSource.WIKI,root/html604/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafC.html
https://root.cern/root/html604/TLeafD.html:1291,Availability,error,error,1291," virtual~TLeafD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virt",MatchSource.WIKI,root/html604/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafD.html
https://root.cern/root/html604/TLeafD.html:1375,Availability,error,error,1375," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html604/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafD.html
https://root.cern/root/html604/TLeafD.html:7728,Modifiability,variab,variable,7728,"c TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Double_tfMaximumMaximum value if leaf range is specified; Double_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Double_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Double_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements ",MatchSource.WIKI,root/html604/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafD.html
https://root.cern/root/html604/TLeafD.html:9733,Usability,simpl,simple,9733,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a double from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafD.html
https://root.cern/root/html604/TLeafElement.html:1379,Availability,error,error,1379," virtual~TLeafElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTLeaf::FillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafElement.html
https://root.cern/root/html604/TLeafElement.html:1463,Availability,error,error,1463," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTLeaf::FillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdata() const; virtual ch",MatchSource.WIKI,root/html604/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafElement.html
https://root.cern/root/html604/TLeafElement.html:7949,Modifiability,variab,variable,7949,"tatic TLeaf::(anonymous)TLeaf::kIndirectAddress; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fAbsAddress! Absolute leaf Address; TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Int_tfIDelement serial number in fInfo; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Int_tfTypeleaf type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafElement(); Default constructor for LeafObject. TLeafElement(TBranch* parent, const char* name, Int_t id, Int_t type); Create a LeafObject. ~TLeafElement(); Default destructor for a LeafObject. TMethodCall * GetMethodCall(const char* name); Returns pointer to method corresponding to name name is a string; with the general form ""method(list of params)"" If list of params is; omitted, () is assumed;. Bool_t IsOnTerminalBranch() const; Return true if this leaf is does not have any sub-branch/leaf. TLeafElement(). Int_t GetLen() const; {return ((TB",MatchSource.WIKI,root/html604/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafElement.html
https://root.cern/root/html604/TLeafF.html:1291,Availability,error,error,1291," virtual~TLeafF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virt",MatchSource.WIKI,root/html604/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafF.html
https://root.cern/root/html604/TLeafF.html:1375,Availability,error,error,1375," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html604/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafF.html
https://root.cern/root/html604/TLeafF.html:7728,Modifiability,variab,variable,7728,"ic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Float_tfMaximumMaximum value if leaf range is specified; Float_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Float_t**fPointer!Addresss of pointer to data buffer!; TStringTNamed::fTitleobject title; Float_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafF(); Default constructor for LeafF*-*-*-*-*-*-*-*-; *-* ============================. TLeafF(TBranch* parent, const char* name, const char* type); Create a LeafF*-*-; *-* ==============; -. ~TLeafF(); Default destructor for a LeafF*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements i",MatchSource.WIKI,root/html604/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafF.html
https://root.cern/root/html604/TLeafF.html:9730,Usability,simpl,simple,9730,". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafF(); Default constructor for LeafF*-*-*-*-*-*-*-*-; *-* ============================. TLeafF(TBranch* parent, const char* name, const char* type); Create a LeafF*-*-; *-* ==============; -. ~TLeafF(); Default destructor for a LeafF*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a float from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafF(). const char * GetTypeName() const; {return ""Float_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafF.html
https://root.cern/root/html604/TLeafI.html:1278,Availability,error,error,1278," virtual~TLeafI(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLe",MatchSource.WIKI,root/html604/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafI.html
https://root.cern/root/html604/TLeafI.html:1362,Availability,error,error,1362," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html604/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafI.html
https://root.cern/root/html604/TLeafI.html:7771,Modifiability,variab,variable,7771," static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Int_tfMaximumMaximum value if leaf range is specified; Int_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in B",MatchSource.WIKI,root/html604/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafI.html
https://root.cern/root/html604/TLeafI.html:9161,Usability,simpl,simple,9161,"Array object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read an integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafI(). Int_t GetMaximum() const; {return fMaximum;}. Int_t GetMinimum() const; {return fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Int",MatchSource.WIKI,root/html604/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafI.html
https://root.cern/root/html604/TLeafL.html:1284,Availability,error,error,1284," virtual~TLeafL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLe",MatchSource.WIKI,root/html604/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafL.html
https://root.cern/root/html604/TLeafL.html:1368,Availability,error,error,1368," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html604/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafL.html
https://root.cern/root/html604/TLeafL.html:7769,Modifiability,variab,variable,7769,"c TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Long64_tfMaximumMaximum value if leaf range is specified; Long64_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf element",MatchSource.WIKI,root/html604/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafL.html
https://root.cern/root/html604/TLeafL.html:9171,Usability,simpl,simple,9171,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* =",MatchSource.WIKI,root/html604/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafL.html
https://root.cern/root/html604/TLeafL.html:9367,Usability,simpl,simple,9367,"s; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Long64_t GetValueLong64(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { r",MatchSource.WIKI,root/html604/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafL.html
https://root.cern/root/html604/TLeafL.html:10265,Usability,simpl,simple,10265,"===================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Long64_t GetValueLong64(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t max); {fMaximum = max;}. void SetMinimum(Long64_t min); {fMinimum = min;}. » Author: Rene Brun 19/12/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafL.html
https://root.cern/root/html604/TLeafO.html:1274,Availability,error,error,1274," virtual~TLeafO(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::",MatchSource.WIKI,root/html604/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafO.html
https://root.cern/root/html604/TLeafO.html:1358,Availability,error,error,1358," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html604/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafO.html
https://root.cern/root/html604/TLeafO.html:7769,Modifiability,variab,variable,7769,"atic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Bool_tfMaximumMaximum value if leaf range is specified; Bool_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Bool_t**fPointer!Address of a pointer to data buffer!; TStringTNamed::fTitleobject title; Bool_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafO(); Default constructor for LeafB*-*-*-*-*-*-*-*-; *-* ============================. TLeafO(TBranch* parent, const char* name, const char* type); Create a LeafB*-*-; *-* ==============; -. ~TLeafO(); Default destructor for a LeafB*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in ",MatchSource.WIKI,root/html604/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafO.html
https://root.cern/root/html604/TLeafObject.html:1315,Availability,error,error,1315," virtual~TLeafObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; TClass*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const",MatchSource.WIKI,root/html604/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafObject.html
https://root.cern/root/html604/TLeafObject.html:1399,Availability,error,error,1399," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; TClass*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html604/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafObject.html
https://root.cern/root/html604/TLeafObject.html:8010,Modifiability,variab,variable,8010,"usBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TLeafObject::(anonymous)kWarn; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); TClassReffClass! pointer to class; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; void**fObjAddress! Address of Pointer to object; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Bool_tfVirtualSupport for polymorphism, when set classname is written with object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafObject(); Default constructor for LeafObject*-*-*-*-*-*-*-*-; *-* =================================. TLeafObject(TBranch* parent, const char* name, const char* type); Create a LeafObject*-*-; *-* ==================; -. ~TLeafObject(); Default destructor for a LeafObject*-*-*-*-*-*-; *-* ==================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. TMethodCall * GetMethodCall(const char* name); -*Returns pointer",MatchSource.WIKI,root/html604/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafObject.html
https://root.cern/root/html604/TLeafObject.html:8431,Modifiability,polymorphi,polymorphism,8431,"usBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TLeafObject::(anonymous)kWarn; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); TClassReffClass! pointer to class; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; void**fObjAddress! Address of Pointer to object; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Bool_tfVirtualSupport for polymorphism, when set classname is written with object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafObject(); Default constructor for LeafObject*-*-*-*-*-*-*-*-; *-* =================================. TLeafObject(TBranch* parent, const char* name, const char* type); Create a LeafObject*-*-; *-* ==================; -. ~TLeafObject(); Default destructor for a LeafObject*-*-*-*-*-*-; *-* ==================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. TMethodCall * GetMethodCall(const char* name); -*Returns pointer",MatchSource.WIKI,root/html604/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafObject.html
https://root.cern/root/html604/TLeafS.html:1284,Availability,error,error,1284," virtual~TLeafS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLe",MatchSource.WIKI,root/html604/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafS.html
https://root.cern/root/html604/TLeafS.html:1368,Availability,error,error,1368," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html604/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafS.html
https://root.cern/root/html604/TLeafS.html:7781,Modifiability,variab,variable,7781,"tic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLeaf::(anonymous)TLeaf::kNewValue; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Short_tfMaximumMaximum value if leaf range is specified; Short_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Short_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Short_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafS(); Default constructor for LeafS*-*-*-*-*-*-*-*-; *-* ============================. TLeafS(TBranch* parent, const char* name, const char* type); Create a LeafS*-*-; *-* ==============; -. ~TLeafS(); Default destructor for a LeafS*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in",MatchSource.WIKI,root/html604/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafS.html
https://root.cern/root/html604/TLeafS.html:9178,Usability,simpl,simple,9178,"ay object (if one); Short_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Short_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafS(); Default constructor for LeafS*-*-*-*-*-*-*-*-; *-* ============================. TLeafS(TBranch* parent, const char* name, const char* type); Create a LeafS*-*-; *-* ==============; -. ~TLeafS(); Default destructor for a LeafS*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a integer integer from std::istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafS(). Int_t GetMaximum() const; { return fMaximum; }. Int_t GetMinimum() const; { return fMinimum; }. void * GetValuePointer() const; {return fValue;}. void Set",MatchSource.WIKI,root/html604/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLeafS.html
https://root.cern/root/html604/TLegend.html:2228,Availability,error,error,2228,"matching; name is found, the corresponding object is added in the legend using its pointer. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignment, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interesting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a lege",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:3657,Availability,error,error,3657,"-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:6366,Availability,error,error,6366,"onvertNDCtoPad(); virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteEntry()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditEntryAttFill(); virtual voidEditEntryAttLine(); virtual voidEditEntryAttMarker(); virtual voidEditEntryAttText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Float_tGetColumnSeparation() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TLegendEntry*GetEntry() const; Float_tGetEntrySeparation() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetHeader() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLine",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:6450,Availability,error,error,6450,"Option_t* option = """")MENU ; virtual voidDeleteEntry()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditEntryAttFill(); virtual voidEditEntryAttLine(); virtual voidEditEntryAttMarker(); virtual voidEditEntryAttText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Float_tGetColumnSeparation() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TLegendEntry*GetEntry() const; Float_tGetEntrySeparation() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetHeader() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*GetListOfPrimitives() const; Float_tGetMargin() const; virtual ",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18338,Availability,error,error,18338,"or.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalised coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constructor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18959,Availability,error,error,18959,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:2286,Modifiability,inherit,inherits,2286,";. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignment, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interesting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by refere",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:3463,Modifiability,inherit,inherits,3463,"-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:3540,Modifiability,inherit,inherits,3540,"-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:3621,Modifiability,inherit,inherits,3621,"-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18144,Modifiability,inherit,inherits,18144,"or.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalised coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constructor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18221,Modifiability,inherit,inherits,18221,"or.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalised coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constructor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18302,Modifiability,inherit,inherits,18302,"or.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalised coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constructor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18765,Modifiability,inherit,inherits,18765,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18842,Modifiability,inherit,inherits,18842,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:18923,Modifiability,inherit,inherits,18923,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:1002,Performance,perform,performed,1002,"ex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TLegend. class TLegend: public TPave, public TAttText. Legend class; This class displays a legend box (TPaveText) containing several legend entries.; Each legend entry is made of a reference to a ROOT object, a text label and an; option specifying which graphical attributes (marker/line/fill) should be; displayed. The following example shows how to create a legend. In this example the legend; contains a histogram, a function and a graph. The histogram is put in the legend; using its reference pointer whereas the graph and the function are added; using their names. Note that, because TGraph constructors do not have the; TGraph name as parameter, the graph name should be specified using the; SetName method. When an object is added by name, a scan is performed on the list of objects; contained in the current pad (gPad) and also in the possible; TMultiGraph and THStack present in the pad. If a matching; name is found, the corresponding object is added in the legend using its pointer. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHead",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegend.html:2593,Usability,simpl,simply,2593,"Blue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignment, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interesting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);; TLegend attributes can be changed using; gStyle. The default settings are:. SetLegendBorderSize(1);; SetLegendFillColor(0);; SetLegendFont(42);; SetLegendTextSize(0.);. The global attributes change the default values for the next created legends. Text attributes can be also changed individually on each legend entry:. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMar",MatchSource.WIKI,root/html604/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegend.html
https://root.cern/root/html604/TLegendEntry.html:1536,Availability,error,error,1536,"t::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual TObject*GetObject() const; vir",MatchSource.WIKI,root/html604/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegendEntry.html
https://root.cern/root/html604/TLegendEntry.html:1620,Availability,error,error,1620,"* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html604/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegendEntry.html
https://root.cern/root/html604/TLegendEntry.html:10321,Modifiability,inherit,inherits,10321,"rker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TObject*fObjectpointer to object being represented by this entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to std::cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. vo",MatchSource.WIKI,root/html604/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegendEntry.html
https://root.cern/root/html604/TLegendEntry.html:10391,Modifiability,inherit,inherits,10391,"is entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to std::cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void SetOption(Option_t* option = ""lpf""); { fOption = option; }. TLegendEntry& operator=(const TLegendEntry& ). » Author: Matthew.Ada",MatchSource.WIKI,root/html604/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegendEntry.html
https://root.cern/root/html604/TLegendEntry.html:10470,Modifiability,inherit,inherits,10470,"is entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to std::cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void SetOption(Option_t* option = ""lpf""); { fOption = option; }. TLegendEntry& operator=(const TLegendEntry& ). » Author: Matthew.Ada",MatchSource.WIKI,root/html604/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLegendEntry.html
https://root.cern/root/html604/TLibraryDocInfo.html:1487,Availability,error,error,1487,"Info(); voidTObject::AbstractMethod(const char* method) const; voidAddDependency(const string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; set<string>&GetModules(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const ch",MatchSource.WIKI,root/html604/TLibraryDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLibraryDocInfo.html
https://root.cern/root/html604/TLibraryDocInfo.html:1571,Availability,error,error,1571,"st string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; set<string>&GetModules(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const cha",MatchSource.WIKI,root/html604/TLibraryDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLibraryDocInfo.html
https://root.cern/root/html604/TLimit.html:748,Availability,avail,available,748,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffe",MatchSource.WIKI,root/html604/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimit.html
https://root.cern/root/html604/TLimit.html:303,Energy Efficiency,adapt,adapted,303,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffe",MatchSource.WIKI,root/html604/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimit.html
https://root.cern/root/html604/TLimit.html:2820,Integrability,wrap,wrapped,2820,"= 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLimit(); TLimit(const TLimit&). protected:. static boolFluctuate(TLimitDataSource* input, TLimitDataSource* output, bool init, TRandom*, bool stat = false); static Double_tLogLikelihood(Double_t s, Double_t b, Double_t b2, Double_t d). Data Members; private:. static TOrdCollection*fgSystNamesCollection of systematics names; static TArrayD*fgTablea log table... just to speed up calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");;",MatchSource.WIKI,root/html604/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimit.html
https://root.cern/root/html604/TLimit.html:303,Modifiability,adapt,adapted,303,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffe",MatchSource.WIKI,root/html604/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimit.html
https://root.cern/root/html604/TLimit.html:3557,Performance,perform,performed,3557,"mentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");; infile->cd();; TH1* sh=(TH1*)infile->Get(""signal"");; TH1* bh=(TH1*)infile->Get(""background"");; TH1* dh=(TH1*)infile->Get(""data"");; TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);; TConfidenceLevel *myconfidence = TLimit::ComputeLimit(mydatasource,50000);; std::cout << "" CLs : "" << myconfidence->CLs() << std::endl;; std::cout << "" CLsb : "" << myconfidence->CLsb() << std::endl;; std::cout << "" CLb : "" << myconfidence->CLb() << std::endl;; std::cout << ""< CLs > : "" << myconfidence->GetExpectedCLs_b() << std::endl;; std::cout << ""< CLsb > : "" << myconfidence->GetExpectedCLsb_b() << std::endl;; std::cout << ""< CLb > : "" << myconfidence->GetExpectedCLb_b() << std::end",MatchSource.WIKI,root/html604/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimit.html
https://root.cern/root/html604/TLimit.html:2417,Testability,log,log,2417,"dom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLimit(); TLimit(const TLimit&). protected:. static boolFluctuate(TLimitDataSource* input, TLimitDataSource* output, bool init, TRandom*, bool stat = false); static Double_tLogLikelihood(Double_t s, Double_t b, Double_t b2, Double_t d). Data Members; private:. static TOrdCollection*fgSystNamesCollection of systematics names; static TArrayD*fgTablea log table... just to speed up calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, ",MatchSource.WIKI,root/html604/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimit.html
https://root.cern/root/html604/TLimitDataSource.html:1492,Availability,error,error,1492," char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObjArray*GetErrorNames(); virtual TObjArray*GetErrorOnBackground(); virtual TObjArray*GetErrorOnSignal(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObjArray*GetSignal(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual ",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:1576,Availability,error,error,1576,"el(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObjArray*GetErrorNames(); virtual TObjArray*GetErrorOnBackground(); virtual TObjArray*GetErrorOnSignal(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObjArray*GetSignal(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vir",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:6447,Availability,error,error,6447,"ect::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:6507,Availability,error,error,6507,"ect::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:6575,Availability,error,error,6575,"ect::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:7338,Availability,error,error,7338,"eping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bin has to be seen as; an error source (relative).; names is an array of strings containing the names of the sources.; Sources with the same name are correlated. void SetOwner(bool swtch = kTRUE); Gives to the TLimitDataSource the ownership of the various objects; given as input.; Objects are then deleted by the TLimitDataSource destructor. TLimitDataSource(). virtual ~TLimitDataSource(); {}. TObjArray* GetSignal(); { return &fSignal;}. TObjArray* GetBackground(); { return &fBackground;}. TObjArray* GetCandidates(); { return &fCandidates;}. TObjArray* GetErrorOnSignal(); { return &fErrorOnSignal;}. TObjArray* GetErrorOnBackground(); { return &fErrorOnBackground;}. TObjArray* GetErrorNames(); { return &fIds;}. » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppor",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:7432,Availability,error,error,7432,"g); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bin has to be seen as; an error source (relative).; names is an array of strings containing the names of the sources.; Sources with the same name are correlated. void SetOwner(bool swtch = kTRUE); Gives to the TLimitDataSource the ownership of the various objects; given as input.; Objects are then deleted by the TLimitDataSource destructor. TLimitDataSource(). virtual ~TLimitDataSource(); {}. TObjArray* GetSignal(); { return &fSignal;}. TObjArray* GetBackground(); { return &fBackground;}. TObjArray* GetCandidates(); { return &fCandidates;}. TObjArray* GetErrorOnSignal(); { return &fErrorOnSignal;}. TObjArray* GetErrorOnBackground(); { return &fErrorOnBackground;}. TObjArray* GetErrorNames(); { return &fIds;}. » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:348,Integrability,interface,interface,348,". TLimitDataSource. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimitDataSource. class TLimitDataSource: public TObject. TLimitDataSource. This class serves as interface to feed data into the TLimit routines. Function Members (Methods); public:. virtual~TLimitDataSource(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLimitDataSource.html:387,Integrability,rout,routines,387,". TLimitDataSource. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimitDataSource. class TLimitDataSource: public TObject. TLimitDataSource. This class serves as interface to feed data into the TLimit routines. Function Members (Methods); public:. virtual~TLimitDataSource(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html604/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLimitDataSource.html
https://root.cern/root/html604/TLine.html:1540,Availability,error,error,1540,"c TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_t",MatchSource.WIKI,root/html604/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLine.html
https://root.cern/root/html604/TLine.html:1624,Availability,error,error,1624,"::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2() const; virtual Bool_tTObject::",MatchSource.WIKI,root/html604/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLine.html
https://root.cern/root/html604/TLine.html:8627,Deployability,release,released,8627,"th; Double_tfX1X of 1st point; Double_tfX2X of 2nd point; Double_tfY1Y of 1st point; Double_tfY2Y of 2nd point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLine(); Line default constructor. TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Line normal constructor. ~TLine(); Line default destructor. TLine(const TLine& line); Line copy constructor. void Copy(TObject& line) const; Copy this line to line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. TLine * DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates in NDC. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event.; This member function is called when a line is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the l",MatchSource.WIKI,root/html604/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLine.html
https://root.cern/root/html604/TLine.html:8721,Deployability,release,released,8721,"d point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLine(); Line default constructor. TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Line normal constructor. ~TLine(); Line default destructor. TLine(const TLine& line); Line copy constructor. void Copy(TObject& line) const; Copy this line to line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. TLine * DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates in NDC. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event.; This member function is called when a line is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis als",MatchSource.WIKI,root/html604/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLine.html
https://root.cern/root/html604/TLine.html:9706,Modifiability,inherit,inheritance,9706," to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void SetVertical(Bool_t set = kTRUE); Force the line to be drawn vertically.; Makes fX2 equal to fX1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void Streamer(TBuffer& ); Stream an object of class TLine. Rectangle_t GetBBox(); Return the bounding Box of the Line. TPoint GetBBoxCenter(); Return the center of the BoundingBox as TPoint in pixels. void SetBBoxCenter(const TPoint& p); Set center of the BoundingBox. void SetBBoxCenterX(const Int_t x); Set X coordinate of the center of the BoundingBox. void SetBBoxCenterY(const Int_t y); Set Y coordinate of the center of the BoundingBox. void SetBBoxX1(const Int_t x); Set lefthandside of BoundingBox to a value; (resize in x direction on left). void SetBBoxX2(const Int_t x); Set righthandside of BoundingBox to a value; (resize in x direction on right). void SetBBoxY1(const Int_t y); Set top of BoundingBox to a value (resize in y direction on top). void SetBBoxY2(const Int_t ",MatchSource.WIKI,root/html604/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLine.html
https://root.cern/root/html604/TLine.html:9891,Modifiability,inherit,inheritance,9891,"ttributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void SetVertical(Bool_t set = kTRUE); Force the line to be drawn vertically.; Makes fX2 equal to fX1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void Streamer(TBuffer& ); Stream an object of class TLine. Rectangle_t GetBBox(); Return the bounding Box of the Line. TPoint GetBBoxCenter(); Return the center of the BoundingBox as TPoint in pixels. void SetBBoxCenter(const TPoint& p); Set center of the BoundingBox. void SetBBoxCenterX(const Int_t x); Set X coordinate of the center of the BoundingBox. void SetBBoxCenterY(const Int_t y); Set Y coordinate of the center of the BoundingBox. void SetBBoxX1(const Int_t x); Set lefthandside of BoundingBox to a value; (resize in x direction on left). void SetBBoxX2(const Int_t x); Set righthandside of BoundingBox to a value; (resize in x direction on right). void SetBBoxY1(const Int_t y); Set top of BoundingBox to a value (resize in y direction on top). void SetBBoxY2(const Int_t y); Set bottom of BoundingBox to a value; (resize in y direction on bottom). Double_t GetX1() const; {return fX1;}. Double_t GetX2() const; {return fX2;}. Double_t GetY1() const; {retur",MatchSource.WIKI,root/html604/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLine.html
https://root.cern/root/html604/TLinearFitter.html:5792,Availability,error,errors,5792,"a(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points a",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:5998,Availability,robust,robust,5998,"();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. virtual~TLinearFitter(); voidTObject::AbstractMethod(const ch",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:6682,Availability,robust,robust,6682," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")M",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:6819,Availability,error,errors,6819,"t be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:8220,Availability,error,error,8220,"ual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(); virtual Int_tEvalRobust(Double_t h = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidFixParameter(Int_t ipar, Double_t parvalue); virtual voidGetAtbVector(TVectorD& v); virtual Double_tGetChisquare(); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:8304,Availability,error,error,8304,"ual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(); virtual Int_tEvalRobust(Double_t h = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidFixParameter(Int_t ipar, Double_t parvalue); virtual voidGetAtbVector(TVectorD& v); virtual Double_tGetChisquare(); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:19203,Availability,error,errors,19203,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability; static map<TString,TFormula*>fgFormulaMap! map of basis functions and formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function Store",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:19275,Availability,robust,robust,19275,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability; static map<TString,TFormula*>fgFormulaMap! map of basis functions and formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function Store",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:19491,Availability,robust,robust,19491,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability; static map<TString,TFormula*>fgFormulaMap! map of basis functions and formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function Store",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:19929,Availability,robust,robust,19929,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability; static map<TString,TFormula*>fgFormulaMap! map of basis functions and formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function Store",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:22435,Availability,error,error,22435," of the following kind:; TFormula(""f"", ""x++y++z++x*x"") or; TFormula(""f"", ""x[0]++x[1]++x[2]*x[2]"");; Other than the look, it's in no; way different from the regular formula, it can be evaluated,; drawn, etc.; The option is to store or not to store the data; If you don't want to store the data, choose """" for the option, or run; StoreData(kFalse) member function after the constructor. TLinearFitter(const TLinearFitter& tlf); Copy ctor. ~TLinearFitter(); Linear fitter cleanup. TLinearFitter& operator=(const TLinearFitter& tlf); Assignment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates t",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:23555,Availability,error,errors,23555,"_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting fu",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:24931,Availability,error,errors,24931,"ouble_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function the argu",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:24944,Availability,error,errors,24944,"ouble_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function the argu",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:25181,Availability,error,error,25181,"ouble_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function the argu",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:25734,Availability,error,errors,25734,"eter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function the argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list.",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:26086,Availability,error,error,26086,"ch bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function the argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:26386,Availability,robust,robust,26386,"; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function the argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus(x, 0, 1)++y""; fills the array of functions. void SetFormula(TFormula* function); Set the fitting function. Bool_t UpdateMatrix(); Update the design matrix after the formula has been changed. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); To use in TGraph::Fit and TH1::Fit(). void PrintResults(Int_t level,",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:27505,Availability,error,errors,27505,"t fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus(x, 0, 1)++y""; fills the array of functions. void SetFormula(TFormula* function); Set the fitting function. Bool_t UpdateMatrix(); Update the design matrix after the formula has been changed. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); To use in TGraph::Fit and TH1::Fit(). void PrintResults(Int_t level, Double_t amin = 0) const; Level = 3 (to be consistent with minuit) prints parameters and parameter; errors. Int_t GraphLinearFitter(Double_t h); Used in TGraph::Fit(). Int_t Graph2DLinearFitter(Double_t h); Minimisation function for a TGraph2D. Int_t MultiGraphLinearFitter(Double_t h); Minimisation function for a TMultiGraph. Int_t HistLinearFitter(); Minimization function for H1s using a Chisquare method. void Streamer(TBuffer& ). Int_t EvalRobust(Double_t h = -1); Finds the parameters of the fitted function in case data contains; outliers.; Parameter h stands for the minimal fraction of good points in the; dataset (h < 1, i.e. for 70% of good points take h=0.7).; The default value of h*Npoints is (Npoints + Nparameters+1)/2; If the user provides a value of h smaller than above, default is taken; See class description for the algorithm details. void CreateSubset(Int_t ntotal, Int_t h, Int_t* index); Creates a p-subset to start; ntotal - total number of points from which the subset is chosen. Double_t CStep(Int_t step, Int",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:19331,Deployability,release,released,19331,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability; static map<TString,TFormula*>fgFormulaMap! map of basis functions and formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function Store",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:538,Integrability,depend,dependency,538,". TLinearFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearFitter. class TLinearFitter: public TVirtualFitter. The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is. y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x). Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula sy",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:2607,Modifiability,variab,variables,2607,"ion by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional formula, one can create a; TF123 based on a linear expression and pass this function; to the fitter:; --Example:; TLinearFitter *lf = new TLinearFitter();; TF2 *f2 = new TF2(""f2"", ""x ++ y ++ x*x*y*y"", -2, 2, -2, 2);; lf->SetFormula(f2);; --The results of the fit are then stored in the function,; just like when the TH1::Fit or TGraph::Fit is used; --A linear function of this kind is by no means different; from any other function, it can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:4285,Modifiability,variab,variables,4285,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:5756,Modifiability,variab,variable,5756,"a(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points a",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:20236,Modifiability,variab,variable,20236,".stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability; static map<TString,TFormula*>fgFormulaMap! map of basis functions and formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands for number of dimensions in the fitting formula; The input data is stored. If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); First parameter stands for number of dimensions in the fitting formula; Second parameter is the fitting formula: see class description for formula syntax; Options:; The option is to store or not to store the data; If you don't want to store the",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:22861,Modifiability,variab,variables,22861,"gnment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisqua",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:22907,Modifiability,variab,variables,22907,"gnment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisqua",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:24445,Modifiability,inherit,inherits,24445,"Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; T",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:837,Performance,perform,performed,837,". TLinearFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearFitter. class TLinearFitter: public TVirtualFitter. The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is. y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x). Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula sy",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:4189,Performance,perform,performance,4189,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:6672,Performance,perform,perform,6672," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")M",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:17998,Performance,cache,cache,17998,"eted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)TVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for nu",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:19916,Performance,perform,performing,19916,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability; static map<TString,TFormula*>fgFormulaMap! map of basis functions and formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function Store",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:5174,Security,access,access,5174,"d give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficie",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:1669,Usability,simpl,simply,1669,"is sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearFitter.html:5028,Usability,clear,cleared,5028," ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recomme",MatchSource.WIKI,root/html604/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearFitter.html
https://root.cern/root/html604/TLinearGradient.html:2220,Availability,error,error,2220,"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html604/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearGradient.html
https://root.cern/root/html604/TLinearGradient.html:2304,Availability,error,error,2304,"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html604/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearGradient.html
https://root.cern/root/html604/TLinearGradient.html:344,Modifiability,extend,extends,344,". TLinearGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLinearGradient. class TLinearGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. virtual~TLinearGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html604/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearGradient.html
https://root.cern/root/html604/TLinearGradient.html:455,Modifiability,inherit,inheriting,455,". TLinearGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLinearGradient. class TLinearGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. virtual~TLinearGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html604/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearGradient.html
https://root.cern/root/html604/TLinearGradient.html:11323,Modifiability,inherit,inherited,11323,"CannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TColorGradient::ECoordinateModeTColorGradient::kObjectBoundingMode; static TObject::(anonymous)TObject::kOverwrite; static TColorGradient::ECoordinateModeTColorGradient::kPadMode; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; Int_tTColor::fNumberColor number identifier; TStringTNamed::fTitleobject title. private:. TColorGradient::PointfEnd; TColorGradient::PointfStart. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearGradient(). TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). void SetStartEnd(const TColorGradient::Point& p1, const TColorGradient::Point& p2). const TColorGradient::Point & GetStart() const. const TColorGradient::Point & GetEnd() const. TLinearGradient(); With C++11 we'll use inherited constructors!!!. TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearGradient.html
https://root.cern/root/html604/TLinearGradient.html:391,Usability,simpl,simple,391,". TLinearGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLinearGradient. class TLinearGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. virtual~TLinearGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html604/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearGradient.html
https://root.cern/root/html604/TLinearMinimizer.html:5724,Availability,error,errors,5724,"bleUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer&operator=(const TLinearMinimizer& rhs); TLinearMinimizer(const TLinearMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const RO",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:6330,Availability,robust,robust,6330,"l stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer&operator=(const TLinearMinimizer& rhs); TLinearMinimizer(const TLinearMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum fu",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:6582,Availability,error,error,6582,"options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:8051,Availability,error,error,8051,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:8061,Availability,error,error,8061,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:8131,Availability,error,errors,8131,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:8394,Availability,error,errors,8394,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:395,Integrability,interface,interface,395,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:577,Integrability,depend,dependence,577,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:742,Modifiability,plug-in,plug-in,742,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:759,Modifiability,plug-in,plug-in,759,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:6228,Modifiability,plug-in,plug-ins,6228,"erance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer&operator=(const TLinearMinimizer& rhs); TLinearMinimizer(const TLinearMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double )",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:7005,Modifiability,variab,variable,7005,"ctor<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:7211,Modifiability,variab,variable,7211," needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:7795,Modifiability,variab,variables,7795,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:7892,Modifiability,variab,variables,7892,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:8308,Modifiability,variab,variable,8308,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:8366,Modifiability,variab,variables,8366,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:6789,Performance,perform,performing,6789,"intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { ",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:5741,Security,validat,validated,5741,"bleUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer&operator=(const TLinearMinimizer& rhs); TLinearMinimizer(const TLinearMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const RO",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLinearMinimizer.html:343,Usability,simpl,simple,343,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar",MatchSource.WIKI,root/html604/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLinearMinimizer.html
https://root.cern/root/html604/TLineEditor.html:4473,Availability,error,error,4473," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLineEditor.html
https://root.cern/root/html604/TLineEditor.html:4557,Availability,error,error,4557,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLineEditor.html
https://root.cern/root/html604/TLineEditor.html:18390,Availability,mask,mask,18390,,MatchSource.WIKI,root/html604/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLineEditor.html
https://root.cern/root/html604/TLink.html:1758,Availability,error,error,1758,"nst; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTText::Copy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidTText::GetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTText::Get",MatchSource.WIKI,root/html604/TLink.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLink.html
https://root.cern/root/html604/TLink.html:1842,Availability,error,error,1842,"(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTText::Copy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidTText::GetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTText::GetTextAdvance(UInt_t& a, const char* text, const Bool_t kern = kTRUE) const; virtual S",MatchSource.WIKI,root/html604/TLink.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLink.html
https://root.cern/root/html604/TList.html:3795,Availability,error,error,3795,"se(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; vi",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TList.html:3879,Availability,error,error,3879,"const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() cons",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TList.html:436,Integrability,wrap,wrapped,436,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . Function Members (Methods); public:. virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObje",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TList.html:801,Integrability,wrap,wrapper,801,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . Function Members (Methods); public:. virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObje",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TList.html:1268,Integrability,wrap,wrap,1268,"inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . Function Members (Methods); public:. virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual ",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TList.html:324,Modifiability,inherit,inheriting,324,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . Function Members (Methods); public:. virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObje",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TList.html:11263,Performance,cache,cache,11263,"BitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*fFirst! pointer to first entry in linked list; TObjLink*fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TList(); Delete the list. Objects are not deleted unless the TList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add ob",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TList.html:14586,Security,access,access,14586,"nd using the; object's IsEqual() method. Returns 0 if obj is last in list. TObject * At(Int_t idx) const; Returns the object at position idx. Returns 0 if idx is out of range. TObject * Before(const TObject* obj) const; Returns the object before object obj. Obj is found using the; object's IsEqual() method. Returns 0 if obj is first in list. void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects; unless the TList is the owner (set via SetOwner()) and option; ""nodelete"" is not set.; If option=""nodelete"" then don't delete any heap objects that were; marked with the kCanDelete bit, otherwise these objects will be; deleted (this option is used by THashTable::Clear()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). void DeleteLink(TObjLink* lnk); Delete a TObjLink object. TObject * FindObject(const char* name) const; Find an object in this list using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. This method overrides the generic FindObject(); of TCollection for efficiency reasons. TObject * FindObject(const TObject* obj) const; Find an object in this list using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; This method overrides the generic FindObject() of TCollection for; efficiency reasons. TObjLink * FindLink(const TObject* obj, Int_t& idx) const; Returns the TObjLink object that contains object obj. In idx it returns; the position of the object in the list. TObject * First() const; Return the first object in the list. Returns 0 when list is empty. TObject ** GetObject",MatchSource.WIKI,root/html604/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TList.html
https://root.cern/root/html604/TListOfDataMembers.html:2609,Availability,error,error,2609,":Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TDictionary*Find(TListOfDataMembers::DeclId_t id) const; virtual TObject*FindObject(const char* name) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); TDictionary*Get(TListOfDataMembers::DeclId_t id); TDictionary*Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*THashList::GetListForObject(const char* name) const; TList*THashList::GetListForObject(con",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:2693,Availability,error,error,2693,"tual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TDictionary*Find(TListOfDataMembers::DeclId_t id) const; virtual TObject*FindObject(const char* name) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); TDictionary*Get(TListOfDataMembers::DeclId_t id); TDictionary*Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*THashList::GetListForObject(const char* name) const; TList*THashList::GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual cha",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:14773,Availability,avail,available,14773,"eturn (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfDataMembers(const TListOfDataMembers& ). TListOfDataMembers& operator=(const TListOfDat",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:10774,Performance,cache,cache,10774,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TDataMember*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TDataMember for unloaded DataMembers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfDataMembers(TClass* cl = 0); Constructor. ~TListOfDataMembers(); Destructor. void MapObject(TObject* obj); Add a pair<id, object> to the map of data members and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add ob",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:11501,Performance,load,load,11501,"s; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TDataMember*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TDataMember for unloaded DataMembers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfDataMembers(TClass* cl = 0); Constructor. ~TListOfDataMembers(); Destructor. void MapObject(TObject* obj); Add a pair<id, object> to the map of data members and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing a",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:14152,Performance,perform,performed,14152,"nsert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a data member just by name or create it if its not already in the list. TDictionary * Find(TListOfDataMembers::DeclId_t id) const; Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object ",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:391,Security,access,access,391,". TListOfDataMembers. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TListOfDataMembers. class TListOfDataMembers: public THashList. TListOfDataMembers. A collection of TDataMember objects designed for fast access given a; DeclId_t and for keep track of TDataMember that were described; unloaded data member. Function Members (Methods); public:. virtual~TListOfDataMembers(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tTHashList::AverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject*",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:14719,Security,hash,hash,14719,"a member corresponding to the Decl 'id'. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused.",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:14737,Security,hash,hash,14737,"a member corresponding to the Decl 'id'. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused.",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfDataMembers.html:14754,Security,hash,hash,14754,"eturn (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfDataMembers(const TListOfDataMembers& ). TListOfDataMembers& operator=(const TListOfDat",MatchSource.WIKI,root/html604/TListOfDataMembers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html
https://root.cern/root/html604/TListOfEnums.html:2560,Availability,error,error,2560,":Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TEnum*Find(TListOfEnums::DeclId_t id) const; virtual TObject*THashList::FindObject(const char* name) const; virtual TObject*THashList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*THashList::GetListForObject(const char* name) const; TList*THashList::GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtu",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:2644,Availability,error,error,2644,"tual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TEnum*Find(TListOfEnums::DeclId_t id) const; virtual TObject*THashList::FindObject(const char* name) const; virtual TObject*THashList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*THashList::GetListForObject(const char* name) const; TList*THashList::GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual TEnum*GetObject(const char*) const; virtual char*TObject::GetObjectInfo(Int_t px,",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:14250,Availability,avail,available,14250,")). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;}. TExMap * GetIds(); { return fIds;}. TEnum * FindUnloaded(const char* name); { return (TEnum*",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:13797,Integrability,rout,routine,13797,"obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. ",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:10753,Performance,cache,cache,10753,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TEnum*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TEnum for unloaded Enums. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfEnums(TClass* cl = 0); Constructor. ~TListOfEnums(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list a",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:11474,Performance,load,load,11474,"nCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TEnum*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TEnum for unloaded Enums. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfEnums(TClass* cl = 0); Constructor. ~TListOfEnums(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one w",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:13757,Performance,load,loaded,13757,"t object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the dec",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:361,Security,access,access,361,". TListOfEnums. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TListOfEnums. class TListOfEnums: public THashList. TListOfEnums. A collection of TEnum objects designed for fast access given a; DeclId_t and for keep track of TEnum that were described; unloaded enum. Function Members (Methods); public:. virtual~TListOfEnums(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tTHashList::AverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& o",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:14196,Security,hash,hash,14196,"om the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:14214,Security,hash,hash,14214,"om the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnums.html:14231,Security,hash,hash,14231,")). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;}. TExMap * GetIds(); { return fIds;}. TEnum * FindUnloaded(const char* name); { return (TEnum*",MatchSource.WIKI,root/html604/TListOfEnums.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnums.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:2582,Availability,error,error,2582,":Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TEnum*TListOfEnums::Find(TListOfEnums::DeclId_t id) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; TList*THashList::GetListForObject(const char* name) const; TList*THashList::GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual TEnum*GetObject(const char*) const;",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:2666,Availability,error,error,2666,"tual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TEnum*TListOfEnums::Find(TListOfEnums::DeclId_t id) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; TList*THashList::GetListForObject(const char* name) const; TList*THashList::GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual TEnum*GetObject(const char*) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**Get",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:13589,Availability,avail,available,13589,"ject before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:13235,Integrability,rout,routine,13235,"ert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfE",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:10656,Performance,cache,cache,10656,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfEnumsWithLock(TClass* cl = 0). ~TListOfEnumsWithLock(); Destructor. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, O",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:13195,Performance,load,loaded,13195,"same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLas",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:396,Security,access,access,396,". TListOfEnumsWithLock. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TListOfEnumsWithLock. class TListOfEnumsWithLock: public TListOfEnums. TListOfEnumsWithLock. A collection of TEnum objects designed for fast access given a; DeclId_t and for keep track of TEnum that were described; unloaded enum. Function Members (Methods); public:. virtual~TListOfEnumsWithLock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; Float_tTHashList::AverageCollisions() const; virtual TObject*Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTO",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:13535,Security,hash,hash,13535,"ct before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page ha",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:13553,Security,hash,hash,13553,"ct before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page ha",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfEnumsWithLock.html:13570,Security,hash,hash,13570,"ject before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT",MatchSource.WIKI,root/html604/TListOfEnumsWithLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html
https://root.cern/root/html604/TListOfFunctions.html:2571,Availability,error,error,2571,":Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TFunction*Find(TListOfFunctions::DeclId_t id) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); TFunction*Get(TListOfFunctions::DeclId_t id); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; virtual TList*GetListForObject(const char* name) const; virtual TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual c",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:2655,Availability,error,error,2655,"tual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TFunction*Find(TListOfFunctions::DeclId_t id) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); TFunction*Get(TListOfFunctions::DeclId_t id); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; virtual TList*GetListForObject(const char* name) const; virtual TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:13412,Availability,avail,available,13412," for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all oth",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:13578,Availability,avail,available,13578," list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it use",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:13749,Availability,avail,available,13749," object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj)",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:14592,Availability,avail,available,14592,"t new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() cons",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:10546,Performance,cache,cache,10546,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctions(TClass* cl); Constructor. ~TListOfFunctions(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list a",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:11215,Performance,load,load,11215,"anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctions(TClass* cl); Constructor. ~TListOfFunctions(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end o",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:381,Security,access,access,381,". TListOfFunctions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TListOfFunctions. class TListOfFunctions: public THashList. TListOfFunctions. A collection of TFunction objects designed for fast access given a; DeclId_t and for keep track of TFunction that were described; unloaded function. Function Members (Methods); public:. virtual~TListOfFunctions(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; Float_tTHashList::AverageCollisions() const; virtual TObject*Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:14538,Security,hash,hash,14538,"rn the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:14556,Security,hash,hash,14556,"rn the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctions.html:14573,Security,hash,hash,14573,"t new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() cons",MatchSource.WIKI,root/html604/TListOfFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:2632,Availability,error,error,2632,":Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); TFunctionTemplate*Get(TListOfFunctionTemplates::DeclId_t id); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual TList*GetListForObject(const char* name) const; virtual TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:2716,Availability,error,error,2716,"tual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); TFunctionTemplate*Get(TListOfFunctionTemplates::DeclId_t id); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual TList*GetListForObject(const char* name) const; virtual TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetOb",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:13533,Availability,avail,available,13533," for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called be",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:13699,Availability,avail,available,13699," list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:13870,Availability,avail,available,13870," object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TFunction object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a function just by name or create it if its not already in the list. TList* GetListForObjectNonConst(const char* name); Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to t",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:14559,Availability,avail,available,14559,"ion-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last gen",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:10651,Performance,cache,cache,10651,"itsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctionTemplates(TClass* cl); Constructor. ~TListOfFunctionTemplates(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginni",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:11320,Performance,load,load,11320,"anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctionTemplates(TClass* cl); Constructor. ~TListOfFunctionTemplates(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add obj",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:413,Security,access,access,413,". TListOfFunctionTemplates. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TListOfFunctionTemplates. class TListOfFunctionTemplates: public THashList. TListOfFunctionTemplates. A collection of TFunction objects designed for fast access given a; DeclId_t and for keep track of TFunction that were described; unloaded function. Function Members (Methods); public:. virtual~TListOfFunctionTemplates(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tTHashList::AverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:14505,Security,hash,hash,14505,"f overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » ",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:14523,Security,hash,hash,14523,"f overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » ",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TListOfFunctionTemplates.html:14540,Security,hash,hash,14540,"ion-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last gen",MatchSource.WIKI,root/html604/TListOfFunctionTemplates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html
https://root.cern/root/html604/TLockFile.html:1519,Availability,error,error,1519," virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIco",MatchSource.WIKI,root/html604/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockFile.html
https://root.cern/root/html604/TLockFile.html:1603,Availability,error,error,1603," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockFile.html
https://root.cern/root/html604/TLockFile.html:376,Deployability,release,released,376,". TLockFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TLockFile. class TLockFile: public TObject. TLockFile. Lock an object using a file.; Constructor blocks until lock is obtained. Lock is released in the; destructor. Use it in scope-blocks like:; {; TLockFile lock(""path.to.lock.file"");; do something you need the lock for; } // lock is automatically released. Function Members (Methods); public:. virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIco",MatchSource.WIKI,root/html604/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockFile.html
https://root.cern/root/html604/TLockFile.html:539,Deployability,release,released,539,". TLockFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TLockFile. class TLockFile: public TObject. TLockFile. Lock an object using a file.; Constructor blocks until lock is obtained. Lock is released in the; destructor. Use it in scope-blocks like:; {; TLockFile lock(""path.to.lock.file"");; do something you need the lock for; } // lock is automatically released. Function Members (Methods); public:. virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIco",MatchSource.WIKI,root/html604/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockFile.html
https://root.cern/root/html604/TLockGuard.html:376,Availability,avail,available,376,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockGuard.html
https://root.cern/root/html604/TLockGuard.html:320,Integrability,interface,interface,320,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockGuard.html
https://root.cern/root/html604/TLockGuard.html:419,Performance,load,loaded,419,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockGuard.html
https://root.cern/root/html604/TLockGuard.html:521,Safety,safe,safe,521,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockGuard.html
https://root.cern/root/html604/TLockGuard.html:775,Safety,safe,safe,775,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLockGuard.html
https://root.cern/root/html604/TLorentzRotation.html:5061,Availability,error,error,5061,"t::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TLorentzRotation&Boost(const TVector3&); TLorentzRotation&Boost(Double_t, Double_t, Double_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzRotation.html
https://root.cern/root/html604/TLorentzRotation.html:5145,Availability,error,error,5145,"* option = """"); TLorentzRotation&Boost(const TVector3&); TLorentzRotation&Boost(Double_t, Double_t, Double_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzRotation.html
https://root.cern/root/html604/TLorentzRotation.html:2216,Testability,test,test,2216," an other TLorentzRotation,; by a pure TRotation or by a boost:;   TLorentzRotation l;      // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);               //  rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:;            ; | xx  yx  zx -tx |;            ; |               ; |;            ; | xy  yy  zy -ty |;            ; |    ",MatchSource.WIKI,root/html604/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzRotation.html
https://root.cern/root/html604/TLorentzRotation.html:2257,Testability,test,test,2257,"TRotation or by a boost:;   TLorentzRotation l;      // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);               //  rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:;            ; | xx  yx  zx -tx |;            ; |               ; |;            ; | xy  yy  zy -ty |;            ; |               ; |;            ; | xz  yz  ",MatchSource.WIKI,root/html604/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzRotation.html
https://root.cern/root/html604/TLorentzRotation.html:2309,Testability,test,test,2309,"     // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);               //  rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:;            ; | xx  yx  zx -tx |;            ; |               ; |;            ; | xy  yy  zy -ty |;            ; |               ; |;            ; | xz  yz  zz -tz |;            ; |               ; |;     ",MatchSource.WIKI,root/html604/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzRotation.html
https://root.cern/root/html604/TLorentzVector.html:8239,Availability,error,error,8239," const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TLorentzVector&) const; Double_tDeltaR(const TLorentzVector&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TLorentzVector&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TLorentzVector&) const; virtual voidTObject::Dump() constMENU ; Double_tE() const; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEt() const; Double_tEt(const TVector3&) const; Double_tEt2() const; Double_tEt2(const TVector3&) const; Double_tEta() const; TVector2EtaPhiVector(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGamma() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZT(Double_t* carray) const; voidGetXYZT(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:8323,Availability,error,error,8323,"::Copy(TObject& object) const; Double_tCosTheta() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TLorentzVector&) const; Double_tDeltaR(const TLorentzVector&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TLorentzVector&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TLorentzVector&) const; virtual voidTObject::Dump() constMENU ; Double_tE() const; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEt() const; Double_tEt(const TVector3&) const; Double_tEt2() const; Double_tEt2(const TVector3&) const; Double_tEta() const; TVector2EtaPhiVector(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGamma() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZT(Double_t* carray) const; voidGetXYZT(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:951,Energy Efficiency,energy,energy,951,". TLorentzVector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TLorentzVector. class TLorentzVector: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = ",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:1774,Energy Efficiency,energy,energy,1774,"asha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one component by one call you can use the SetVect(); function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():;   v.SetVect(TVector3(1,2,3));;   v.SetXYZT(x,y,z,t);;",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:4427,Energy Efficiency,energy,energy,4427,"r convenience there are two more set functions SetPtEtaPhiE(pt,eta,phi,e);; and SetPtEtaPhiM(pt,eta,phi,m);. Arithmetic and comparison operators; The TLorentzVector class provides operators to add, subtract or; compare four-vectors:;   v3 = -v1;;   v1 = v2+v3;;   v1+= v3;;   v1 = v2 + v3;;   v1-= v3;;   if (v1 == v2) {...};   if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,;    i.e.   s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therfore:;           mag2; = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation aro",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:6372,Energy Efficiency,adapt,adapt,6372,"st(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly. Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;   TLorentzRotation l;;   v.Transform(l);;   v = l*v;     or    ; v *= l;  // Attention v = l*v. Function Members (Methods); public:. virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3&); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) ",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:15457,Energy Efficiency,energy,energy,15457,"TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TLorentzVector::(anonymous)kNUM_COORDINATES; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TLorentzVector::(anonymous)kSIZE; static TObject::(anonymous)TObject::kSingleKey; static TLorentzVector::(anonymous)kT; static TObject::(anonymous)TObject::kWriteDelete; static TLorentzVector::(anonymous)kX; static TLorentzVector::(anonymous)kY; static TLorentzVector::(anonymous)kZ; static TObject::(anonymous)TObject::kZombie. private:. Double_tfEtime or energy of (x,y,z,t) or (px,py,pz,e); TVector3fP3 vector component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLorentzVector(); {}. TLorentzVector(Double_t x, Double_t y, Double_t z, Double_t t); {}. TLorentzVector(const Double_t* carray); {}. TLorentzVector(const Float_t* carray); {}. TLorentzVector(const TVector3& vector3, Double_t t); {}. TLorentzVector(const TLorentzVector& lorentzvector); {}. ~TLorentzVector(); {}. void Boost(Double_t , Double_t , Double_t ); Boost this Lorentz vector. Double_t Rapidity() const; return rapidity. TLorentzVector & Transform(const TLorentzRotation& ); Transform this Lorentzvector. void Streamer(TBuffer& ); Stream an object of class TLorentzVector. void Print(Option_t* option = """") const; Print the TLorentz vector components as (x,y,z,t) and (P,eta,phi,E) representations. Double_t X() const; { return fP.X(); }. Double_t Y() const; { return fP.Y(); }. Double_t Z() const; { return fP.Z(); }. Double_t T() const; { return fE; }. vo",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:1060,Modifiability,variab,variable,1060,"k Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TLorentzVector. class TLorentzVector: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; y",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:4691,Modifiability,parameteriz,parameterized,4691,"act or; compare four-vectors:;   v3 = -v1;;   v1 = v2+v3;;   v1+= v3;;   v1 = v2 + v3;;   v1-= v3;;   if (v1 == v2) {...};   if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,;    i.e.   s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therfore:;           mag2; = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:6372,Modifiability,adapt,adapt,6372,"st(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly. Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;   TLorentzRotation l;;   v.Transform(l);;   v = l*v;     or    ; v *= l;  // Attention v = l*v. Function Members (Methods); public:. virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3&); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) ",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:5138,Performance,perform,performs,5138,"tive mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus()",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:1443,Security,access,access,1443," ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one com",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TLorentzVector.html:1935,Security,access,accessed,1935,"Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one component by one call you can use the SetVect(); function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():;   v.SetVect(TVector3(1,2,3));;   v.SetXYZT(x,y,z,t);;   v.SetPxPyPzE(px,py,pz,e);;   v.SetXYZM(x,y,z,m);   //   -> ; v=(x,y,z,e=Sqrt(x*x+y*y+z*z+m*m)). Vector components in noncartesian coordinate systems; There are a couple of memberfunctions to get and set the TVector3; part of the parameters in; spherical coordinate systems:;   Double_t m, theta, cost, phi, pp, pp2, ppv2, pp2v2;;   m = v.Rho();;   t = v.Theta();;   cost = v.",MatchSource.WIKI,root/html604/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TLorentzVector.html
https://root.cern/root/html604/TMacro.html:2335,Availability,error,error,2335," virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t ",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:2428,Availability,error,error,2428,") const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtu",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:2512,Availability,error,error,2512,"d(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTO",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:9078,Availability,error,error,9078,"& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void Set",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:9235,Availability,error,error,9235," performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() const; {return fLines;}. » Author: Rene Brun 16/08/2005 » Copyright (C) 1995-2005, Rene Brun an",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:9346,Availability,error,error,9346,"stem.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() const; {return fLines;}. » Author: Rene Brun 16/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:19; This page has been automat",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:722,Deployability,update,updated,722,". TMacro. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMacro. class TMacro: public TNamed. TMacro. Class supporting a collection of lines with C++ code.; A TMacro can be executed, saved to a ROOT file, edited, etc. A macro can be built line by line by calling the AddLine function.; or it can be created directly from a file via the special constructor; when the first argument is a file name. A macro can be executed via the Exec function.; Arguments can be specified when calling Exec. A macro can be drawn in a pad. When the pad is updated, the macro is; automatically executed. The code in the macro can be saved via the SaveSource function.; If the macro is in the list of primitives of a pad/canvas, the macro; will be saved in the script generated by TCanvas::SaveSource. A macro can be written to a ROOT file via TObject::Write. Examples:; TMacro m(""Peaks.C""); //macro m with name ""Peaks"" is created; from file Peaks.C; m.Exec(); //macro executed with default arguments; m.Exec(""4""); //macro executed with argument; m.SaveSource(""newPeaks.C"");; TFile f(""mymacros.root"",""recreate"");; m.Write(); //macro saved to file with name ""Peaks"". Function Members (Methods); public:. virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t ",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:8294,Integrability,depend,depending,8294,"otected:. TList*fLinescollection of lines; TStringTNamed::fNameobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this mac",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:8323,Modifiability,variab,variable,8323,"otected:. TList*fLinescollection of lines; TStringTNamed::fNameobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this mac",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:8268,Performance,perform,performed,8268,"otected:. TList*fLinescollection of lines; TStringTNamed::fNameobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this mac",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:9168,Performance,load,loading,9168," lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLi",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:8969,Security,checksum,checksum,8969,"cro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp.",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:8898,Testability,log,log,8898,"ill be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void Sa",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMacro.html:8930,Testability,log,log,8930,"ename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Sa",MatchSource.WIKI,root/html604/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMacro.html
https://root.cern/root/html604/TMap.html:2277,Availability,error,error,2277,"ual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* keyname) const; virtual TObject*FindObject(const TObject* key) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; const THashTable*GetTable() const; virtual const char*TObject::GetTit",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:2361,Availability,error,error,2361,"t char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* keyname) const; virtual TObject*FindObject(const TObject* key) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; const THashTable*GetTable() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TObject*GetValue(const char*",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:11162,Availability,down,downcast,11162,"ts in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; Returns a pointer to the value associated with key. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key f",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:11417,Availability,down,downcast,11417,"ption = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; Returns a pointer to the value associated with key. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key from the map. Returns the; key object or 0 in case key was not found. If map is the owner; of values, the value is deleted. TPair * RemoveEntry(TObject* key); Remove (key,value) pair with key from the map. Returns the; pair object or 0 in case the key was ",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:365,Energy Efficiency,efficient,efficient,365,". TMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TMap. class TMap: public TCollection. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constM",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:10504,Energy Efficiency,allocate,allocated,10504,"s() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Va",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:10627,Energy Efficiency,allocate,allocated,10627,"tSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) con",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:10756,Energy Efficiency,allocate,allocated,10756," the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; R",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:9752,Integrability,depend,depending,9752,"c TMap::(anonymous)kIsOwnerValue. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:12811,Integrability,depend,depending,12811,"(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key from the map. Returns the; key object or 0 in case key was not found. If map is the owner; of values, the value is deleted. TPair * RemoveEntry(TObject* key); Remove (key,value) pair with key from the map. Returns the; pair object or 0 in case the key was not found.; It is caller's responsibility to delete the pair and, eventually,; the key and value objects. void SetOwnerValue(Bool_t enable = kTRUE); Set whether this map is the owner (enable==true); of its values. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is deleted. The objects might also be deleted or destructed when Clear; is called (depending on the collection). void SetOwnerKeyValue(Bool_t ownkeys = kTRUE, Bool_t ownvals = kTRUE); Set ownership for keys and values. void Streamer(TBuffer& ); Stream all key/value pairs in the map to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this map. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this map. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:615,Modifiability,inherit,inherit,615,". TMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TMap. class TMap: public TCollection. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constM",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:451,Security,hash,hash,451,". TMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TMap. class TMap: public TCollection. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constM",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:9570,Security,hash,hashtable,9570,"kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; static TCollection::(anonymous)TCollection::kIsOwner; static TMap::(anonymous)kIsOwnerValue. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); ",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:10182,Security,hash,hash,10182,"is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMap.html:10350,Security,hash,hash,10350,"d(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const;",MatchSource.WIKI,root/html604/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMap.html
https://root.cern/root/html604/TMapFile.html:2414,Availability,robust,robust,2414,"directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size = kDefaultMapSize, const char* title = """"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Dr",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:3657,Availability,error,error,3657," option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size = kDefaultMapSize, const char* title = """"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObject*Get(const char* name, TObject* retObj = 0); void*GetBaseAddr() const; void*GetBreakval() const; TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFd() const; TMapRec*GetFirst() const; virtual const char*TObject::GetIconName() const; TMapRec*GetLast() const; void*GetMmallocDesc() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; Int_tGetSize() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:3741,Availability,error,error,3741,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size = kDefaultMapSize, const char* title = """"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObject*Get(const char* name, TObject* retObj = 0); void*GetBaseAddr() const; void*GetBreakval() const; TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFd() const; TMapRec*GetFirst() const; virtual const char*TObject::GetIconName() const; TMapRec*GetLast() const; void*GetMmallocDesc() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; Int_tGetSize() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject:",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:12397,Availability,error,error,12397,"ce the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t GetBestBuffer(); Return the best buffer size for objects in this fil",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:12472,Availability,error,error,12472,"t* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t GetBestBuffer(); Return the best buffer size for objects in this file. The best buffer size is estimated based on the current mean value; and s",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:9117,Deployability,update,update,9117,"StatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. ULong_tfBaseAddrBase address of mapped memory region; TList*fBrowseListList of KeyMapFile objects; TDirectory*fDirectoryPointer to directory associated to this mapfile; Int_tfFdDescriptor of mapped file; TMapRec*fFirstList of streamed objects is shared memory; TObject*fGettingDon't deadlock in update mode, when from Get() Add() is called; TMapRec*fLastLast object in list of shared objects; void*fMmallocDescPointer to mmalloc descriptor; char*fNameName of mapped file; Long_tfOffsetOffset in bytes for region mapped by reader; char*fOptionDirectory creation options; Int_tfSemaphoreModification semaphore (or getpid() for WIN32); Int_tfSizeOriginal start size of memory mapped region; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written sofar; char*fTitleTitle of mapped file; Int_tfVersionROOT version (or -1 for shadow map file); Bool_tfWritableTRUE if mapped file opened in RDWR mode; Int_tfWrittenNumber of objects written sofar; static Long_tfgMapAddressMap to this address, set address via SetMapAddress(); static void*fgMmallocDescUsed in Close() and operator delete(); ULong_tfhSemaphoreHANDLE of WIN32 Mutex object to implement semaphore. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMapFile(); Default ctor. Does not much except setting some basic values. TMapFile(const char* name, const char* title, Option_t* option, Int_t size, TMapFile*& newMapFile); Create a memory mapped file. This opens a file (to which the; memory will be mapped) and attaches a memory region to i",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:1405,Energy Efficiency,allocate,allocate,1405,") also whenever the mapped object(s) change(s); call Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:12081,Energy Efficiency,allocate,allocated,12081,"operator has been made private. Use Close() to properly; terminate a TMapFile (also done via the TROOT dtor). void InitDirectory(); Create the directory associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents ",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:12244,Integrability,synchroniz,synchronizing,12244," associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuf",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:2148,Modifiability,inherit,inheritance,2148,"w the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size =",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:904,Security,access,access,904,". TMapFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TMapFile. class TMapFile: public TObject. TMapFile. This class implements a shared memory region mapped to a file.; Objects can be placed into this shared memory area using the Add(); member function. To actually place a copy of the object is shared; memory call Update() also whenever the mapped object(s) change(s); call Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is d",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:12258,Security,access,access,12258," associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuf",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapFile.html:1762,Usability,simpl,simple,1762,"e address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual co",MatchSource.WIKI,root/html604/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapFile.html
https://root.cern/root/html604/TMapRec.html:2395,Availability,robust,robust,2395,"directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. ~TMapRec(); void*GetBuffer(Long_t offset = 0) const; Int_tGetBufSize() const; const char*GetClassName(Long_t offset = 0) const; const char*GetName(Long_t offset = 0) const; TMapRec*GetNext(Long_t offset = 0) const; TObject*GetObject() const; TMapRec(const char* name, const TObject* obj, Int_t size, void* buf). private:. TMapRec&operator=(const TMapRec&); TMapRec(const TMapRec&). Data Members; private:. Int_tfBufSizebuffer size; void*fBufferbuffer containing object of class name; char*fClassNameclass name; char*fNameobject name; TMapRec*fNextnext MapRec in list; TObject*fObjectpointer to original object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMapRec(const char* name, const TObject* obj, Int_t size, void* buf); Constructor. ~TMapRec(); Destructor. TObject * GetObject() const; This method returns a pointer to the original object. NOTE: this pointer; is only valid in th",MatchSource.WIKI,root/html604/TMapRec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapRec.html
https://root.cern/root/html604/TMapRec.html:1386,Energy Efficiency,allocate,allocate,1386,") also whenever the mapped object(s) change(s); call Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. ~TMapRec(); void",MatchSource.WIKI,root/html604/TMapRec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapRec.html
https://root.cern/root/html604/TMapRec.html:2129,Modifiability,inherit,inheritance,2129,"w the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. ~TMapRec(); void*GetBuffer(Long_t offset = 0) const; Int_tGetBufSize() const; const char*GetClassName(Long_t offset = 0) const; const char*GetName(Long_t offset = 0) const; TMapRec*GetNext(Long_t offset = 0) const; TObject*GetObject() const; TMapRec(const char* name, const TObject* obj, Int_t size, void* buf). private:. TMapRec&operator=(const TMapRec&); TMapRec(const TMapRec&). Data Members; private:. Int_tfBufSizebuffer size; void*fBufferbuffer containing object of class name; char*fClassNameclass name; char*fNameobject name; TMapRec*fNextnext MapRec in list; TObject*fObjectpointer to original object. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root/html604/TMapRec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapRec.html
https://root.cern/root/html604/TMapRec.html:885,Security,access,access,885,". TMapRec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TMapRec. class TMapRec. TMapFile. This class implements a shared memory region mapped to a file.; Objects can be placed into this shared memory area using the Add(); member function. To actually place a copy of the object is shared; memory call Update() also whenever the mapped object(s) change(s); call Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFil",MatchSource.WIKI,root/html604/TMapRec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapRec.html
https://root.cern/root/html604/TMapRec.html:1743,Usability,simpl,simple,1743,"e address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. ~TMapRec(); void*GetBuffer(Long_t offset = 0) const; Int_tGetBufSize() const; const char*GetClassName(Long_t offset = 0) const; const char*GetName(Long_t offset = 0) const; TMapRec*GetNext(Long_t offset = 0) const; TObject*GetObject() const; TMapRec(const char* name, const TObjec",MatchSource.WIKI,root/html604/TMapRec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMapRec.html
https://root.cern/root/html604/TMarker.html:1406,Availability,error,error,1406," virtual~TMarker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttMarker::GetMarkerColor() co",MatchSource.WIKI,root/html604/TMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMarker.html
https://root.cern/root/html604/TMarker.html:1490,Availability,error,error,1490,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX() const; Double_tGetY() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual UL",MatchSource.WIKI,root/html604/TMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMarker.html
https://root.cern/root/html604/TMarker.html:8332,Deployability,release,released,8332,"ted Members; Includes; Libraries. Function documentation; TMarker(); Marker default constructor. TMarker(Double_t x, Double_t y, Int_t marker); Marker normal constructor. ~TMarker(); Marker default destructor. TMarker(const TMarker& marker); Marker copy constructor. void Copy(TObject& marker) const; Copy this marker to marker. void DisplayMarkerTypes(); Display the table of markers with their numbers. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a marker. Compute the closest distance of approach from point px,py to this marker.; The distance is computed in pixels units. void Draw(Option_t* option = """"); Draw this marker with its current attributes. void DrawMarker(Double_t x, Double_t y); Draw this marker with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a marker is clicked with the locator. If Left button is clicked on a marker, the marker is moved to; a new position when the mouse button is released. void ls(Option_t* option = """") const; List this marker with its attributes. void Paint(Option_t* option = """"); Paint this marker with its current attributes. void PaintMarker(Double_t x, Double_t y); Draw this marker with new coordinates. void PaintMarkerNDC(Double_t u, Double_t v); Draw this marker with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this marker with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void Streamer(TBuffer& ); Stream an object of class TMarker. Rectangle_t GetBBox(); Return the bounding Box of the Line. TPoint GetBBoxCenter(); Return the center of the BoundingBox as TPoint in pixels. void SetBBoxCenter(const TPoint& p); Set center of the BoundingBox. void SetBBoxCenterX(const Int_t x); Set X coordinate of the cen",MatchSource.WIKI,root/html604/TMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMarker.html
https://root.cern/root/html604/TMarker3DBox.html:1866,Availability,error,error,1866,"AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGetDirection(Float_t& theta, Float_t& phi) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPosition(Fl",MatchSource.WIKI,root/html604/TMarker3DBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMarker3DBox.html
https://root.cern/root/html604/TMarker3DBox.html:1950,Availability,error,error,1950,"ption = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGetDirection(Float_t& theta, Float_t& phi) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPosition(Float_t& x, Float_t& y, Float_t& z) const; TObject*GetRefObject() const; virtual voidG",MatchSource.WIKI,root/html604/TMarker3DBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMarker3DBox.html
https://root.cern/root/html604/TMaterial.html:1327,Availability,error,error,1327," virtual~TMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA() const; virtual Float_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TO",MatchSource.WIKI,root/html604/TMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMaterial.html
https://root.cern/root/html604/TMaterial.html:1411,Availability,error,error,1411,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA() const; virtual Float_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tGetInterLength() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetRadLength() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() cons",MatchSource.WIKI,root/html604/TMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMaterial.html
https://root.cern/root/html604/TMaterial.html:315,Safety,detect,detector,315,". TMaterial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMaterial. class TMaterial: public TNamed, public TAttFill. Manages a detector material. See class TGeometry. Function Members (Methods); public:. virtual~TMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA() const; virtual Float_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TO",MatchSource.WIKI,root/html604/TMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMaterial.html
https://root.cern/root/html604/TMath.html:7153,Availability,error,error,7153," Double_tSinH(Double_t); Double_tSq(Double_t x); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t); Double_tTanH(Double_t); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the norma",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:7291,Availability,error,error,7291,"veH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t); Double_tTanH(Double_t); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the normalized lower incomplete gamma function P(a,x) as defined in the; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:7438,Availability,error,error,7438,"ble_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t); Double_tTanH(Double_t); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the normalized lower incomplete gamma function P(a,x) as defined in the; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, D",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:7548,Availability,error,error,7548,"e_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the normalized lower incomplete gamma function P(a,x) as defined in the; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, B",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13066,Availability,error,error,13066,"nst Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; ",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:15751,Availability,error,error,15751,"convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t[4] coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates r",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:15973,Availability,error,error,15973,"just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t[4] coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to th",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13282,Deployability,integrat,integrated,13282,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:17685,Deployability,continuous,continuous,17685,"urned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased; regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array'",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:23998,Deployability,continuous,continuous,23998,"atural lower and upper limits. Double_t BetaIncomplete(Double_t x, Double_t a, Double_t b); Calculates the incomplete Beta-function. Double_t Binomial(Int_t n, Int_t k); Calculate the binomial coefficient n over k. Double_t BinomialI(Double_t p, Int_t n, Int_t k); Suppose an event occurs with probability _p_ per trial; Then the probability P of its occuring _k_ or more times; in _n_ trials is termed a cumulative binomial probability; the formula is P = sum_from_j=k_to_n(TMath::Binomial(n, j)*; *TMath::Power(p, j)*TMath::Power(1-p, n-j); For _n_ larger than 12 BetaIncomplete is a much better way; to evaluate the sum than would be the straightforward sum calculation; for _n_ smaller than 12 either method is acceptable; (""Numerical Recipes""); --implementation by Anna Kreshuk. Double_t CauchyDist(Double_t x, Double_t t = 0, Double_t s = 1); Computes the density of Cauchy distribution at point x; by default, standard Cauchy distribution is used (t=0, s=1); t is the location parameter; s is the scale parameter; The Cauchy distribution, also called Lorentzian distribution,; is a continuous distribution describing resonance behavior; The mean and standard deviation of the Cauchy distribution are undefined.; The practical meaning of this is that collecting 1,000 data points gives; no more accurate an estimate of the mean and standard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:9194,Energy Efficiency,adapt,adapted,9194,"he; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mu is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; (most proble value) is at x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for any x integer argument it is correct.; BUT for non-integer x values, it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note ",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:11292,Energy Efficiency,power,powerful,11292,"I(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13388,Energy Efficiency,adapt,adapted,13388,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:15900,Energy Efficiency,adapt,adapted,15900," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t[4] coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:17287,Energy Efficiency,allocate,allocated,17287,"ject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t[4] coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; ",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:17378,Energy Efficiency,allocate,allocated,17378,"ble_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased; regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and F",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:28499,Energy Efficiency,adapt,adapted,28499,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:292,Integrability,rout,routines,292,". TMath. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMath. namespace TMath. TMath. Encapsulate math routines. Function Members (Methods); public:. Short_tAbs(Short_t d); Int_tAbs(Int_t d); Long_tAbs(Long_t d); Long64_tAbs(Long64_t d); Float_tAbs(Float_t d); Double_tAbs(Double_t d); LongDouble_tAbs(LongDouble_t d); Double_tACos(Double_t); Double_tACosH(Double_t); Bool_tAreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Bool_tAreEqualRel(Double_t af, Double_t bf, Double_t relPrec); Double_tASin(Double_t); Double_tASinH(Double_t); Double_tATan(Double_t); Double_tATan2(Double_t, Double_t); Double_tATanH(Double_t); Double_tBesselI(Int_t n, Double_t x); Double_tBesselI0(Double_t x); Double_tBesselI1(Double_t x); Double_tBesselJ0(Double_t x); Double_tBesselJ1(Double_t x); Double_tBesselK(Int_t n, Double_t x); Double_tBesselK0(Double_t x); Double_tBesselK1(Double_t x); Double_tBesselY0(Double_t x); Double_tBesselY1(Double_t x); Double_tBeta(Double_t p, Double_t q); Double_tBetaCf(Double_t x, Double_t a, Double_t b); Double_tBetaDist(Double_t x, Double_t p, Double_t q); Double_tBetaDistI(Double_t x, Double_t p, Double_t q); Double_tBetaIncomplete(Double_t x, Double_t a, Double_t b); Double_tBinomial(Int_t n, Int_t k); Double_tBinomialI(Double_t p, Int_t n, Int_t k); Double_tBreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); voidBubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); voidBubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Double_tC(); Double_tCauchyDist(Double_t x, Double_t t = 0, Double_t s = 1); Double_tCcgs(); Double_tCeil(Double_t x); Int_tCeilNint(Double_t x); Double_tChisquareQuantile(Double_t p, Double_t ndf); Double_tCos(Double_t); Double_tCosH(Double_t); Double_tCUncertainty(); Double_tDegToRad(); Double_tDiLog(Double_t x); Double_tE(); Double_tEr",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:9219,Integrability,rout,routine,9219,"he; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mu is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; (most proble value) is at x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for any x integer argument it is correct.; BUT for non-integer x values, it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note ",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13282,Integrability,integrat,integrated,13282,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13422,Integrability,rout,routine,13422,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:28520,Integrability,rout,routine,28520,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:9194,Modifiability,adapt,adapted,9194,"he; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mu is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; (most proble value) is at x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for any x integer argument it is correct.; BUT for non-integer x values, it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note ",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13388,Modifiability,adapt,adapted,13388,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:15900,Modifiability,adapt,adapted,15900," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t[4] coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:25253,Modifiability,variab,variable,25253,"andard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() impl",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:28499,Modifiability,adapt,adapted,28499,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:28888,Modifiability,variab,variable,28888,"e shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distrib",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:29448,Modifiability,variab,variable,29448,"f; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Computes quantiles of the Student's t-distribution; 1st argument is the probability, at which the quantile is computed; 2nd argument - the number of degrees of freedom of the; Student distribution; When the 3rd argument lower_tail i",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:15017,Performance,perform,perform,15017,"a++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:19179,Security,hash,hash,19179,"pe=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) ",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:19370,Security,hash,hash,19370," Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-S",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:19401,Security,hash,hash,19401,"istician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for ",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:19471,Security,hash,hash,19471,"ackage {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; A",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:11204,Testability,test,test,11204,"e values of par, it is better to call; TMath::Gaus(x,par,sqrt(par),kTRUE). /*. */. Double_t PoissonI(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:11302,Testability,test,test,11302,"I(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:12194,Testability,test,test,12194,"est statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:12326,Testability,test,test,12326,"est statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:12783,Testability,test,test,12783,"*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two so",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13207,Testability,test,test,13207,"ether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (i",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:13225,Testability,test,test,13225,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:15303,Testability,test,test,15303,"ase, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubi",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:19564,Testability,test,tested,19564,"t to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Dou",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:25402,Testability,test,testing,25402,"/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Doub",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:25831,Testability,test,test,25831,"na Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu = 0, Double_t beta = 1); Computes the density function of Gamma distribution at point x.; gamma - shape parameter; mu - location parameter; beta - scale parameter. The definition can be found in ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda366b.htm; use now impleme",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:25902,Testability,test,test,25902,"grees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu = 0, Double_t beta = 1); Computes the density function of Gamma distribution at point x.; gamma - shape parameter; mu - location parameter; beta - scale parameter. The definition can be found in ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda366b.htm; use now implementation in ROOT::Math::gamma_pdf. /*; ; */. Double_t LaplaceDist(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the probability density function of Laplace distributi",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:27840,Testability,log,lognormal,27840,"lace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LaplaceDistI(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the distribution function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at wh",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:29120,Testability,test,tests,29120,"; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Dou",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMath.html:29161,Testability,test,tests,29161,"; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Dou",MatchSource.WIKI,root/html604/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMath.html
https://root.cern/root/html604/TMathText.html:2345,Availability,avail,available,2345,"\\left( \\prod_f {d^3p_f\\over (2\\pi)^3} {1\\over 2E_f} \\right) \\left| \\mathscr{M} \\left(m_A - \\left\\{p_f\\right\\} \\right) \\right|^2 (2\\pi)^4 \\delta^{(4)} \\left(p_A - \\sum p_f \\right)"");; l.DrawMathText(0.50, 0.425, ""4\\mathrm{Re}\\left\\{{2\\over 1-\\Delta\\alpha} \\chi(s) \\left[ \\^{g}_\\nu^e \\^{g}_\\nu^f (1 + \\cos^2\\theta) + \\^{g}_a^e \\^{g}_a^f \\cos\\theta \\right] \\right\\}"");; l.DrawMathText(0.50, 0.330, ""p(n) = {1\\over\\pi\\sqrt{2}} \\sum_{k = 1}^\\infty \\sqrt{k} A_k(n) {d\\over dn} {\\sinh \\left\\{ {\\pi\\over k} \\sqrt{2\\over 3} \\sqrt{n - {1\\over 24}} \\right\\} \\over \\sqrt{n - {1\\over 24}}}"");; l.DrawMathText(0.13, 0.150, ""{(\\ell+1)C_{\\ell}^{TE} \\over 2\\pi}"");; l.DrawMathText(0.27, 0.110, ""\\mathbb{N} \\subset \\mathbb{R}"");; l.DrawMathText(0.63, 0.100, ""\\hbox{RHIC スピン物理 Нью-Йорк}"");. c1->Print(""c1.gif"");; c1->Print(""c1.jpg"");; c1->Print(""c1.png"");; c1->Print(""c1.ps"");; c1->Print(""c1.eps"");. return c1;; }. The list of all available symbols is given in the following example:. Picture; Source. // This macro draw all possible symbols provided by TMathtext; //Author: Olivier Couet. {; TCanvas *c1 = new TCanvas(""mathtext"",""TMathText symbol"",1200,1400);. TMathText l;; l.SetTextSize(0.013);; l.SetTextFont(132);. // Draw 1st Column; l.SetTextAlign(12);; float y, step, x1, x2;; y = 0.99; step = 0.0126; x1 = 0.01; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\\""""); l.DrawText(x2, y, ""\\\"""");; y -= step ; l.DrawMathText(x1, y, ""\\'""); l.DrawText(x2, y, ""\\'"");; y -= step ; l.DrawMathText(x1, y, ""\\.""); l.DrawText(x2, y, ""\\."");; y -= step ; l.DrawMathText(x1, y, ""\\=""); l.DrawText(x2, y, ""\\="");; y -= step ; l.DrawMathText(x1, y, ""\\Box""); l.DrawText(x2, y, ""\\Box"");; y -= step ; l.DrawMathText(x1, y, ""\\Bumpeq""); l.DrawText(x2, y, ""\\Bumpeq"");; y -= step ; l.DrawMathText(x1, y, ""\\Cap""); l.DrawText(x2, y, ""\\Cap"");; y -= step ; l.DrawMathText(x1, y, ""\\Cup""); l.DrawText(x2, y, ""\\Cup"");; y -= step ; l.DrawMathText(x1, y, ""\\Delta""); l.D",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:14819,Availability,down,downarrow,14819,"diamond""); l.DrawText(x2, y, ""\\diamond"");; y -= step ; l.DrawMathText(x1, y, ""\\diamondsuit""); l.DrawText(x2, y, ""\\diamondsuit"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; ",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:14853,Availability,down,downarrow,14853,"; y -= step ; l.DrawMathText(x1, y, ""\\diamondsuit""); l.DrawText(x2, y, ""\\diamondsuit"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqc",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:14904,Availability,down,downdownarrows,14904,"dsuit""); l.DrawText(x2, y, ""\\diamondsuit"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -=",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:14943,Availability,down,downdownarrows,14943,"-= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.Dra",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:14999,Availability,down,downdownharpoons,14999,"DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathT",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15040,Availability,down,downdownharpoons,15040,"athText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15098,Availability,down,downharpoonleft,15098,"\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15138,Availability,down,downharpoonleft,15138,"\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantles",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15195,Availability,down,downharpoonright,15195," l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15236,Availability,down,downharpoonright,15236,"ext(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.D",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15294,Availability,down,downuparrows,15294,"rawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y, """,MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15331,Availability,down,downuparrows,15331,"y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y, ""\\eta"");; y -= step ; l.DrawMathText(x1, y, """,MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15385,Availability,down,downupharpoons,15385," y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y, ""\\eta"");; y -= step ; l.DrawMathText(x1, y, ""\\eth""); l.DrawText(x2, y, ""\\eth"");; y -= step",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:15424,Availability,down,downupharpoons,15424,""");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y, ""\\eta"");; y -= step ; l.DrawMathText(x1, y, ""\\eth""); l.DrawText(x2, y, ""\\eth"");; y -= step ; l.DrawMathText(x1, y, ""\\exists""); l.DrawTex",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:54169,Availability,error,error,54169,"ual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:54253,Availability,error,error,54253,"are(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual void",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:52199,Testability,log,log,52199,", ""\\csc"");; y -= step ; l.DrawMathText(x1, y, ""\\deg""); l.DrawText(x2, y, ""\\deg"");; y -= step ; l.DrawMathText(x1, y, ""\\det""); l.DrawText(x2, y, ""\\det"");; y -= step ; l.DrawMathText(x1, y, ""\\dim""); l.DrawText(x2, y, ""\\dim"");; y -= step ; l.DrawMathText(x1, y, ""\\exp""); l.DrawText(x2, y, ""\\exp"");; y -= step ; l.DrawMathText(x1, y, ""\\gcd""); l.DrawText(x2, y, ""\\gcd"");; y -= step ; l.DrawMathText(x1, y, ""\\hom""); l.DrawText(x2, y, ""\\hom"");; y -= step ; l.DrawMathText(x1, y, ""\\inf""); l.DrawText(x2, y, ""\\inf"");; y -= step ; l.DrawMathText(x1, y, ""\\ker""); l.DrawText(x2, y, ""\\ker"");; y -= step ; l.DrawMathText(x1, y, ""\\lg""); l.DrawText(x2, y, ""\\lg"");; y -= step ; l.DrawMathText(x1, y, ""\\lim""); l.DrawText(x2, y, ""\\lim"");; y -= step ; l.DrawMathText(x1, y, ""\\liminf""); l.DrawText(x2, y, ""\\liminf"");; y -= step ; l.DrawMathText(x1, y, ""\\limsup""); l.DrawText(x2, y, ""\\limsup"");; y -= step ; l.DrawMathText(x1, y, ""\\ln""); l.DrawText(x2, y, ""\\ln"");; y -= step ; l.DrawMathText(x1, y, ""\\log""); l.DrawText(x2, y, ""\\log"");; y -= step ; l.DrawMathText(x1, y, ""\\max""); l.DrawText(x2, y, ""\\max"");; y -= step ; l.DrawMathText(x1, y, ""\\min""); l.DrawText(x2, y, ""\\min"");; y -= step ; l.DrawMathText(x1, y, ""\\sec""); l.DrawText(x2, y, ""\\sec"");; y -= step ; l.DrawMathText(x1, y, ""\\sin""); l.DrawText(x2, y, ""\\sin"");; y -= step ; l.DrawMathText(x1, y, ""\\sinh""); l.DrawText(x2, y, ""\\sinh"");; y -= step ; l.DrawMathText(x1, y, ""\\sup""); l.DrawText(x2, y, ""\\sup"");; y -= step ; l.DrawMathText(x1, y, ""\\tan""); l.DrawText(x2, y, ""\\tan"");; y -= step ; l.DrawMathText(x1, y, ""\\tanh""); l.DrawText(x2, y, ""\\tanh"");. return c1;; }. Function Members (Methods); public:. virtual~TMathText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMathText.html:52227,Testability,log,log,52227,"ext(x1, y, ""\\deg""); l.DrawText(x2, y, ""\\deg"");; y -= step ; l.DrawMathText(x1, y, ""\\det""); l.DrawText(x2, y, ""\\det"");; y -= step ; l.DrawMathText(x1, y, ""\\dim""); l.DrawText(x2, y, ""\\dim"");; y -= step ; l.DrawMathText(x1, y, ""\\exp""); l.DrawText(x2, y, ""\\exp"");; y -= step ; l.DrawMathText(x1, y, ""\\gcd""); l.DrawText(x2, y, ""\\gcd"");; y -= step ; l.DrawMathText(x1, y, ""\\hom""); l.DrawText(x2, y, ""\\hom"");; y -= step ; l.DrawMathText(x1, y, ""\\inf""); l.DrawText(x2, y, ""\\inf"");; y -= step ; l.DrawMathText(x1, y, ""\\ker""); l.DrawText(x2, y, ""\\ker"");; y -= step ; l.DrawMathText(x1, y, ""\\lg""); l.DrawText(x2, y, ""\\lg"");; y -= step ; l.DrawMathText(x1, y, ""\\lim""); l.DrawText(x2, y, ""\\lim"");; y -= step ; l.DrawMathText(x1, y, ""\\liminf""); l.DrawText(x2, y, ""\\liminf"");; y -= step ; l.DrawMathText(x1, y, ""\\limsup""); l.DrawText(x2, y, ""\\limsup"");; y -= step ; l.DrawMathText(x1, y, ""\\ln""); l.DrawText(x2, y, ""\\ln"");; y -= step ; l.DrawMathText(x1, y, ""\\log""); l.DrawText(x2, y, ""\\log"");; y -= step ; l.DrawMathText(x1, y, ""\\max""); l.DrawText(x2, y, ""\\max"");; y -= step ; l.DrawMathText(x1, y, ""\\min""); l.DrawText(x2, y, ""\\min"");; y -= step ; l.DrawMathText(x1, y, ""\\sec""); l.DrawText(x2, y, ""\\sec"");; y -= step ; l.DrawMathText(x1, y, ""\\sin""); l.DrawText(x2, y, ""\\sin"");; y -= step ; l.DrawMathText(x1, y, ""\\sinh""); l.DrawText(x2, y, ""\\sinh"");; y -= step ; l.DrawMathText(x1, y, ""\\sup""); l.DrawText(x2, y, ""\\sup"");; y -= step ; l.DrawMathText(x1, y, ""\\tan""); l.DrawText(x2, y, ""\\tan"");; y -= step ; l.DrawMathText(x1, y, ""\\tanh""); l.DrawText(x2, y, ""\\tanh"");. return c1;; }. Function Members (Methods); public:. virtual~TMathText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const",MatchSource.WIKI,root/html604/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMathText.html
https://root.cern/root/html604/TMatrixTBase_double_.html:822,Availability,avail,available,822,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:3983,Availability,down,down,3983,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:7454,Availability,avail,available,7454,"c_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual vo",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:8772,Availability,error,error,8772,"(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:8856,Availability,error,error,8856,"; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:2031,Deployability,integrat,integrated,2031,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:2545,Deployability,install,installation,2545,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:2583,Deployability,install,installation,2583,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:1988,Energy Efficiency,efficient,efficient,1988,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:2454,Energy Efficiency,adapt,adapted,2454,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:3259,Energy Efficiency,adapt,adapted,3259,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:3315,Energy Efficiency,efficient,efficiently,3315,"; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices,",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:4342,Energy Efficiency,efficient,efficient,4342,"or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:2031,Integrability,integrat,integrated,2031,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:3101,Integrability,rout,routines,3101,"age examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) ca",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:3298,Integrability,rout,routines,3298,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:2454,Modifiability,adapt,adapted,2454,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:3259,Modifiability,adapt,adapted,3259,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:3955,Performance,optimiz,optimized,3955,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:851,Safety,avoid,avoiding,851,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:2133,Testability,test,test,2133," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:4688,Testability,test,test,4688,"; from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; st",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:6650,Testability,test,test,6650,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Op",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:6277,Usability,simpl,simple,6277,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_double_.html:6950,Usability,simpl,simple,6950,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virt",MatchSource.WIKI,root/html604/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:819,Availability,avail,available,819,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:3980,Availability,down,down,3980,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:7451,Availability,avail,available,7451,"c_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObje",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:8761,Availability,error,error,8761,"ply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:8845,Availability,error,error,8845,"b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*T",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:2028,Deployability,integrat,integrated,2028,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:2542,Deployability,install,installation,2542,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:2580,Deployability,install,installation,2580,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:1985,Energy Efficiency,efficient,efficient,1985,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:2451,Energy Efficiency,adapt,adapted,2451,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:3256,Energy Efficiency,adapt,adapted,3256,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:3312,Energy Efficiency,efficient,efficiently,3312,"; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices,",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:4339,Energy Efficiency,efficient,efficient,4339,"or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:2028,Integrability,integrat,integrated,2028,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:3098,Integrability,rout,routines,3098,"age examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) ca",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:3295,Integrability,rout,routines,3295,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:2451,Modifiability,adapt,adapted,2451,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:3256,Modifiability,adapt,adapted,3256,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:3952,Performance,optimiz,optimized,3952,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:848,Safety,avoid,avoiding,848,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:2130,Testability,test,test,2130," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:4685,Testability,test,test,4685,"; from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; st",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:6647,Testability,test,test,6647,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Opti",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:6274,Usability,simpl,simple,6274,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTBase_float_.html:6947,Usability,simpl,simple,6947,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual co",MatchSource.WIKI,root/html604/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTBase_float_.html
https://root.cern/root/html604/TMatrixTCramerInv.html:402,Energy Efficiency,adapt,adapted,402,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTCramerInv.html
https://root.cern/root/html604/TMatrixTCramerInv.html:367,Integrability,rout,routines,367,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTCramerInv.html
https://root.cern/root/html604/TMatrixTCramerInv.html:415,Integrability,rout,routines,415,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTCramerInv.html
https://root.cern/root/html604/TMatrixTCramerInv.html:402,Modifiability,adapt,adapted,402,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTCramerInv.html
https://root.cern/root/html604/TMatrixTLazy_double_.html:573,Availability,avail,available,573,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption(",MatchSource.WIKI,root/html604/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTLazy_double_.html
https://root.cern/root/html604/TMatrixTLazy_double_.html:1551,Availability,error,error,1551," virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption(",MatchSource.WIKI,root/html604/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTLazy_double_.html
https://root.cern/root/html604/TMatrixTLazy_double_.html:1635,Availability,error,error,1635," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html604/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTLazy_double_.html
https://root.cern/root/html604/TMatrixTLazy_float_.html:570,Availability,avail,available,570,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root/html604/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTLazy_float_.html
https://root.cern/root/html604/TMatrixTLazy_float_.html:1547,Availability,error,error,1547," virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root/html604/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTLazy_float_.html
https://root.cern/root/html604/TMatrixTLazy_float_.html:1631,Availability,error,error,1631," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html604/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTLazy_float_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:4223,Availability,error,error,4223," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:4307,Availability,error,error,4307,"oidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:18815,Energy Efficiency,allocate,allocated,18815,"WorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:19041,Energy Efficiency,allocate,allocated,19041,"_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:19267,Energy Efficiency,allocate,allocated,19267,"). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<E",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:19491,Energy Efficiency,allocate,allocated,19491,"nt_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy m",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:19709,Energy Efficiency,allocate,allocated,19709,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:19937,Energy Efficiency,allocate,allocated,19937,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:20159,Energy Efficiency,allocate,allocated,20159,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source t",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:20381,Energy Efficiency,allocate,allocated,20381,"lement> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b;",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:21425,Energy Efficiency,allocate,allocated,21425,"ubtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:21666,Energy Efficiency,allocate,allocated,21666,"Nelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:2198,Integrability,rout,routine,2198,"+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . Function Members (Methods); public:. virtual~TMatrixTSparse<double>(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&TMatrixTBase<double>::Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&TMatrixTBase<double>::Apply(const TElementPosActionT<double>& action); virtu",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:22879,Integrability,depend,depends,22879,"zeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<double>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:2320,Modifiability,flexible,flexible,2320,"e matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . Function Members (Methods); public:. virtual~TMatrixTSparse<double>(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&TMatrixTBase<double>::Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&TMatrixTBase<double>::Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObje",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:1566,Performance,perform,performance,1566,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is sm",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_double_.html:840,Security,access,access,840,". TMatrixTSparse<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSparse<double>. class TMatrixTSparse<double>: public TMatrixTBase<double>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); wher",MatchSource.WIKI,root/html604/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_double_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:4204,Availability,error,error,4204,"owser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNo",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:4288,Availability,error,error,4288,"tual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:18583,Energy Efficiency,allocate,allocated,18583,":kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:18809,Energy Efficiency,allocate,allocated,18809,"nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:19035,Energy Efficiency,allocate,allocated,19035,"at). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<E",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:19259,Energy Efficiency,allocate,allocated,19259,"Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy ma",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:19477,Energy Efficiency,allocate,allocated,19477,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/co",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:19705,Energy Efficiency,allocate,allocated,19705,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(I",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:19927,Energy Efficiency,allocate,allocated,19927,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to s",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:20149,Energy Efficiency,allocate,allocated,20149,"lement> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:21190,Energy Efficiency,allocate,allocated,21190,"x subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:21431,Energy Efficiency,allocate,allocated,21431," fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:2194,Integrability,rout,routine,2194,"+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . Function Members (Methods); public:. virtual~TMatrixTSparse<float>(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&TMatrixTBase<float>::Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&TMatrixTBase<float>::Apply(const TElementPosActionT<float>& action); virtual voidTO",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:22642,Integrability,depend,depends,22642,"onzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<float>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The n",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:2316,Modifiability,flexible,flexible,2316,"e matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . Function Members (Methods); public:. virtual~TMatrixTSparse<float>(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&TMatrixTBase<float>::Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&TMatrixTBase<float>::Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compar",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:1562,Performance,perform,performance,1562,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is sm",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSparse_float_.html:836,Security,access,access,836,". TMatrixTSparse<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSparse<float>. class TMatrixTSparse<float>: public TMatrixTBase<float>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it",MatchSource.WIKI,root/html604/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSparse_float_.html
https://root.cern/root/html604/TMatrixTSymCramerInv.html:414,Energy Efficiency,adapt,adapted,414,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymCramerInv.html
https://root.cern/root/html604/TMatrixTSymCramerInv.html:379,Integrability,rout,routines,379,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymCramerInv.html
https://root.cern/root/html604/TMatrixTSymCramerInv.html:427,Integrability,rout,routines,427,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymCramerInv.html
https://root.cern/root/html604/TMatrixTSymCramerInv.html:414,Modifiability,adapt,adapted,414,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods). Class Charts; Function documentation. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymCramerInv.html
https://root.cern/root/html604/TMatrixTSymLazy_double_.html:582,Availability,avail,available,582,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDt",MatchSource.WIKI,root/html604/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymLazy_double_.html
https://root.cern/root/html604/TMatrixTSymLazy_double_.html:1563,Availability,error,error,1563," virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDt",MatchSource.WIKI,root/html604/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymLazy_double_.html
https://root.cern/root/html604/TMatrixTSymLazy_double_.html:1647,Availability,error,error,1647," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html604/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymLazy_double_.html
https://root.cern/root/html604/TMatrixTSymLazy_float_.html:579,Availability,avail,available,579,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html604/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymLazy_float_.html
https://root.cern/root/html604/TMatrixTSymLazy_float_.html:1559,Availability,error,error,1559," virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html604/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymLazy_float_.html
https://root.cern/root/html604/TMatrixTSymLazy_float_.html:1643,Availability,error,error,1643," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html604/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSymLazy_float_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:2083,Availability,error,error,2083,"ect::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:2167,Availability,error,error,2167,"Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTM",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:492,Deployability,update,updated,492,". TMatrixTSym<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSym<double>. class TMatrixTSym<double>: public TMatrixTBase<double>. TMatrixTSym. Template class of a symmetric matrix in the linear algebra package. Note that in this implementation both matrix element m[i][j] and; m[j][i] are updated and stored in memory . However, when making the; object persistent only the upper right triangle is stored . Function Members (Methods); public:. virtual~TMatrixTSym<double>(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:19112,Energy Efficiency,efficient,efficient,19112,". TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:19452,Energy Efficiency,efficient,efficient,19452,"m<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Ele",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:19844,Energy Efficiency,efficient,efficient,19844," = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:16114,Integrability,depend,depends,16114,"ound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starti",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:16545,Integrability,depend,depends,16545," Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetMatrixArray(const double* data, Option_t* option = """"). TMatrixTBase<Element> &TMatrixTSym<Element> Shift(Int_t row_shift, Int_t col_shift). TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set siz",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:19176,Integrability,rout,routine,19176,". TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:19516,Integrability,rout,routine,19516,"m<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Ele",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:19908,Integrability,rout,routine,19908," = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_double_.html:18443,Security,access,access,18443,"MatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient",MatchSource.WIKI,root/html604/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_double_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:2065,Availability,error,error,2065,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:2149,Availability,error,error,2149,"bject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:488,Deployability,update,updated,488,". TMatrixTSym<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSym<float>. class TMatrixTSym<float>: public TMatrixTBase<float>. TMatrixTSym. Template class of a symmetric matrix in the linear algebra package. Note that in this implementation both matrix element m[i][j] and; m[j][i] are updated and stored in memory . However, when making the; object persistent only the upper right triangle is stored . Function Members (Methods); public:. virtual~TMatrixTSym<float>(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual void",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:18751,Energy Efficiency,efficient,efficient,18751,"nst. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSy",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:19091,Energy Efficiency,efficient,efficient,19091,"TSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Eleme",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:19481,Energy Efficiency,efficient,efficient,19481,"ha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(float val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the s",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:15760,Integrability,depend,depends,15760,"lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting ",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:16190,Integrability,depend,depends,16190,"a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetMatrixArray(const float* data, Option_t* option = """"). TMatrixTBase<Element> &TMatrixTSym<Element> Shift(Int_t row_shift, Int_t col_shift). TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size o",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:18815,Integrability,rout,routine,18815,"nst. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSy",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:19155,Integrability,rout,routine,19155,"TSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Eleme",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:19545,Integrability,rout,routine,19545,"ha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(float val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the s",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixTSym_float_.html:18085,Security,access,access,18085,"MatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient th",MatchSource.WIKI,root/html604/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixTSym_float_.html
https://root.cern/root/html604/TMatrixT_double_.html:1915,Availability,error,error,1915,"ect::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<",MatchSource.WIKI,root/html604/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_double_.html
https://root.cern/root/html604/TMatrixT_double_.html:1999,Availability,error,error,1999,"Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTM",MatchSource.WIKI,root/html604/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_double_.html
https://root.cern/root/html604/TMatrixT_double_.html:18502,Integrability,rout,routine,18502,"lement> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A general and B symmetric.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A symmetric and B symmetric.; (Actually copied for the moment routine for B general); Create a matrix C such that C = A * B. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_l",MatchSource.WIKI,root/html604/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_double_.html
https://root.cern/root/html604/TMatrixT_double_.html:19724,Integrability,depend,depends,19724," = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, th",MatchSource.WIKI,root/html604/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_double_.html
https://root.cern/root/html604/TMatrixT_float_.html:1895,Availability,error,error,1895,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root/html604/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_float_.html
https://root.cern/root/html604/TMatrixT_float_.html:1979,Availability,error,error,1979,"bject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase",MatchSource.WIKI,root/html604/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_float_.html
https://root.cern/root/html604/TMatrixT_float_.html:18095,Integrability,rout,routine,18095,"lement> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A general and B symmetric.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A symmetric and B symmetric.; (Actually copied for the moment routine for B general); Create a matrix C such that C = A * B. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lw",MatchSource.WIKI,root/html604/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_float_.html
https://root.cern/root/html604/TMatrixT_float_.html:19315,Integrability,depend,depends,19315,"j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, the",MatchSource.WIKI,root/html604/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMatrixT_float_.html
https://root.cern/root/html604/TMCVerbose.html:1611,Availability,error,error,1611,"idAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::",MatchSource.WIKI,root/html604/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMCVerbose.html
https://root.cern/root/html604/TMCVerbose.html:1695,Availability,error,error,1695,"dBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html604/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMCVerbose.html
https://root.cern/root/html604/TMD5.html:508,Availability,avail,available,508,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!t",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4161,Availability,error,error,4161,"tring. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4440,Availability,error,error,4440,"f 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4674,Availability,error,error,4674,"this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4984,Availability,error,error,4984,"this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:292,Integrability,message,message-digest,292,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!t",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:701,Integrability,message,message,701,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!t",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:1910,Integrability,message,message,1910,"al~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-di",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:1950,Integrability,message,message,1950,"al~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-di",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:2794,Integrability,message,message-digest,2794,"64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:2837,Integrability,message,message,2837,"64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:2940,Integrability,message,message-digest,2940,"igest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns check",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:2983,Integrability,message,message,2983,"igest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns check",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:3115,Integrability,message,message,3115,"; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Return",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:3666,Integrability,rout,routine,3666,", UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case t",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:2405,Safety,avoid,avoids,2405,"erNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of ",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:2549,Safety,avoid,avoids,2549,", UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the add",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4743,Safety,safe,safely,4743,"this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:5064,Safety,safe,safely,5064,"this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:3538,Security,hash,hash,3538," operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:3955,Security,checksum,checksum,3955,"st operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest ar",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4255,Security,checksum,checksum,4255," len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t[4] buf, const UChar_t[64] in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 19",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4533,Security,checksum,checksum,4533,"this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:4914,Security,checksum,checksum,4914,"this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t[16] digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMD5.html:567,Testability,test,tested,567,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!t",MatchSource.WIKI,root/html604/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMD5.html
https://root.cern/root/html604/TMehrotraSolver.html:2301,Availability,error,error,2301,"taBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBase::DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::H",MatchSource.WIKI,root/html604/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMehrotraSolver.html
https://root.cern/root/html604/TMehrotraSolver.html:2385,Availability,error,error,2385," virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBase::DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject",MatchSource.WIKI,root/html604/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMehrotraSolver.html
https://root.cern/root/html604/TMehrotraSolver.html:9270,Energy Efficiency,monitor,monitor,9270,"ouble_tTQpSolverBase::fMutoltermination parameters; Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMehrotraSolver.html
https://root.cern/root/html604/TMehrotraSolver.html:9245,Performance,optimiz,optimization,9245,"ouble_tTQpSolverBase::fMutoltermination parameters; Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMehrotraSolver.html
https://root.cern/root/html604/TMehrotraSolver.html:397,Safety,predict,predictor-corrector,397,". TMehrotraSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TMehrotraSolver. class TMehrotraSolver: public TQpSolverBase. TMehrotraSolver. Derived class of TQpSolverBase implementing the original Mehrotra; predictor-corrector algorithm. Function Members (Methods); public:. virtual~TMehrotraSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBas",MatchSource.WIKI,root/html604/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMehrotraSolver.html
https://root.cern/root/html604/TMemberInspector.html:3029,Availability,error,error,3029,"ector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberInspector(); Construct a member inspector. ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void Inspect(TClass* cl, const char* parent, const char* name, const void* addr); Obsolete signature. void GenericShowMembers(const char* topClassName, const void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(const TObject& obj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. void InspectMember(const char* topclassname, const void* pobj, const char* name, Bool_t transient); Routine driving the visiting of the class information/data members. void InspectMember(TClass* cl, const void* pobj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. kUnset, // No Inspect(). TMemberInspector(const TMemberInspector& ). TMemberInspector & operator=(const TMemberInspector& ). EObjectPointerState GetObjectValidity() const; { return fObjectPointerState; }. void SetObjectValidity(TMemberInspector::EObjectPointerState val); { fObjectPointerState = val; }. obj. IsA(). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-",MatchSource.WIKI,root/html604/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemberInspector.html
https://root.cern/root/html604/TMemberInspector.html:3035,Integrability,message,message,3035,"ector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberInspector(); Construct a member inspector. ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void Inspect(TClass* cl, const char* parent, const char* name, const void* addr); Obsolete signature. void GenericShowMembers(const char* topClassName, const void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(const TObject& obj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. void InspectMember(const char* topclassname, const void* pobj, const char* name, Bool_t transient); Routine driving the visiting of the class information/data members. void InspectMember(TClass* cl, const void* pobj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. kUnset, // No Inspect(). TMemberInspector(const TMemberInspector& ). TMemberInspector & operator=(const TMemberInspector& ). EObjectPointerState GetObjectValidity() const; { return fObjectPointerState; }. void SetObjectValidity(TMemberInspector::EObjectPointerState val); { fObjectPointerState = val; }. obj. IsA(). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-",MatchSource.WIKI,root/html604/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemberInspector.html
https://root.cern/root/html604/TMemberInspector.html:3011,Safety,avoid,avoid,3011,"ector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberInspector(); Construct a member inspector. ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void Inspect(TClass* cl, const char* parent, const char* name, const void* addr); Obsolete signature. void GenericShowMembers(const char* topClassName, const void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(const TObject& obj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. void InspectMember(const char* topclassname, const void* pobj, const char* name, Bool_t transient); Routine driving the visiting of the class information/data members. void InspectMember(TClass* cl, const void* pobj, const char* name, Bool_t isTransient); Routine driving the visiting of the class information/data members. kUnset, // No Inspect(). TMemberInspector(const TMemberInspector& ). TMemberInspector & operator=(const TMemberInspector& ). EObjectPointerState GetObjectValidity() const; { return fObjectPointerState; }. void SetObjectValidity(TMemberInspector::EObjectPointerState val); { fObjectPointerState = val; }. obj. IsA(). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-",MatchSource.WIKI,root/html604/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemberInspector.html
https://root.cern/root/html604/TMemberInspector.html:335,Security,access,accessing,335,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods); public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, const void* obj, Bool_t transientMember); TMemberInspector::EObjectPointerStateGetObjectValidity() const; const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr, Bool_t); voidInspectMember(const TObject& obj, const char* name, Bool_t isTransient); voidInspectMember(const char* topclassname, const void* pobj, const char* name, Bool_t transient); voidInspectMember(TClass* cl, const void* pobj, const char* name, Bool_t isTransient); virtual TClass*IsA() const; voidRemoveFromParent(Ssiz_t startingAt); voidSetObjectValidity(TMemberInspector::EObjectPointerState val); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMemberInspector(). private:. TMemberInspector&operator=(const TMemberInspector&); TMemberInspector(const TMemberInspector&). Data Members; public:. static TMemberInspector::EObjectPointerStatekNoObjectGiven; static TMemberInspector::EObjectPointerStatekUnset; static TMemberInspector::EObjectPointerStatekValidObjectGiven. private:. TMemberInspector::EObjectPointerStatefObjectPointe",MatchSource.WIKI,root/html604/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemberInspector.html
https://root.cern/root/html604/TMemberStreamer.html:1522,Modifiability,variab,variable,1522,". TMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TMemberStreamer. class TMemberStreamer. TMemberStreamer is used to stream a data member. The address passed to operator() will be the address of the data; member. Function Members (Methods); public:. virtual~TMemberStreamer(); virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* pmember, Int_t size = 0); TMemberStreamer&operator=(const TMemberStreamer& rhs); virtual voidSetOnFileClass(const TClass* cl); TMemberStreamer(MemberStreamerFunc_t pointer); TMemberStreamer(const TMemberStreamer& rhs). protected:. TMemberStreamer(). Data Members; private:. TClassReffOnFileClass; MemberStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberStreamer(); {}. TMemberStreamer(MemberStreamerFunc_t pointer); {}. TMemberStreamer(const TMemberStreamer& rhs); {}. TMemberStreamer & operator=(const TMemberStreamer& rhs); { fStreamer = rhs.fStreamer; return *this; }. virtual ~TMemberStreamer(); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. void operator()(TBuffer& b, void* pmember, Int_t size = 0); The address passed to operator() will be the address of the data member.; If the data member is a variable size array, 'size' is the number of elements; to read/write. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemberStreamer.html
https://root.cern/root/html604/TMemFile.html:3090,Availability,error,error,3090,"ateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenH",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:3174,Availability,error,error,3174,"t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetB",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:25144,Availability,alive,alive,25144," Libraries. Function documentation; TMemFile(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const char* name, char* buffer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const TMemFile& orig); Copying the content of the TMemFile into another TMemFile. ~TMemFile(); Close and clean-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe all the data from the permanent buffer but keep, the in-memory object; alive. void ResetObjects(TDirectoryFile* , TFileMergeInfo* ) const; Wipe all the data from the permanent buffer but keep, the in-memory object; alive. Int_t SysRead(Int_t fd, void* buf, Int_t len); Read specified number of bytes from current offset into the buffer.; See documentation for TFile::SysRead(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Seek to a specified position in the file. See TFile::SysSeek().; Note that TMemFile does not support seeks when the file is open for write. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a file in 'MemFile'. Int_t SysClose(Int_t fd); Close the mem file. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Write a buffer into the file;. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Perform a stat on the HDFS file; see TFile::SysStat(). Int_t SysSync(Int_t fd); Sync remaining data to disk;; Nothing to do here. void",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:25288,Availability,alive,alive,25288,"ual Constructor. See the TFile constructor for details. TMemFile(const char* name, char* buffer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Usual Constructor. See the TFile constructor for details. TMemFile(const TMemFile& orig); Copying the content of the TMemFile into another TMemFile. ~TMemFile(); Close and clean-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe all the data from the permanent buffer but keep, the in-memory object; alive. void ResetObjects(TDirectoryFile* , TFileMergeInfo* ) const; Wipe all the data from the permanent buffer but keep, the in-memory object; alive. Int_t SysRead(Int_t fd, void* buf, Int_t len); Read specified number of bytes from current offset into the buffer.; See documentation for TFile::SysRead(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Seek to a specified position in the file. See TFile::SysSeek().; Note that TMemFile does not support seeks when the file is open for write. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a file in 'MemFile'. Int_t SysClose(Int_t fd); Close the mem file. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Write a buffer into the file;. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Perform a stat on the HDFS file; see TFile::SysStat(). Int_t SysSync(Int_t fd); Sync remaining data to disk;; Nothing to do here. void ResetErrno() const; ResetErrno; simply calls TSystem::ResetErrno(). TMemBlock & operator=(const TMemFile& ). Long64_t MemRead(Int_t ",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:11796,Performance,cache,cacheDir,11796,", const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetO",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:11923,Performance,cache,cache,11923,"TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:12042,Performance,cache,cache,12042," voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:19492,Performance,cache,cache,19492,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:19554,Performance,cache,cache,19554,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:19626,Performance,cache,cache,19626,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:21362,Performance,cache,cache,21362,,MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:21645,Performance,cache,cache,21645,"; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile:",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:23041,Performance,cache,cache,23041,"real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:23071,Performance,cache,cached,23071,"real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:12999,Safety,timeout,timeout,12999,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; I",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemFile.html:26122,Usability,simpl,simply,26122," clean-up HDFS file. Long64_t CopyTo(void* to, Long64_t maxsize) const; Copy the binary representation of the TMemFile into; the memory area starting at 'to' and of length at most 'maxsize'; returns the number of bytes actually copied. void CopyTo(TBuffer& tobuf) const; Copy the binary representation of the TMemFile into; the TBuffer tobuf. Long64_t GetSize() const; Return the current size of the memory file. void Print(Option_t* option = """") const. void ResetAfterMerge(TFileMergeInfo* ); Wipe all the data from the permanent buffer but keep, the in-memory object; alive. void ResetObjects(TDirectoryFile* , TFileMergeInfo* ) const; Wipe all the data from the permanent buffer but keep, the in-memory object; alive. Int_t SysRead(Int_t fd, void* buf, Int_t len); Read specified number of bytes from current offset into the buffer.; See documentation for TFile::SysRead(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Seek to a specified position in the file. See TFile::SysSeek().; Note that TMemFile does not support seeks when the file is open for write. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a file in 'MemFile'. Int_t SysClose(Int_t fd); Close the mem file. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Write a buffer into the file;. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Perform a stat on the HDFS file; see TFile::SysStat(). Int_t SysSync(Int_t fd); Sync remaining data to disk;; Nothing to do here. void ResetErrno() const; ResetErrno; simply calls TSystem::ResetErrno(). TMemBlock & operator=(const TMemFile& ). Long64_t MemRead(Int_t fd, void* buf, Long64_t len) const. » Author: Philippe Canal, May 2011 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-18 17:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemFile.html
https://root.cern/root/html604/TMemStat.html:4502,Availability,error,error,4502,"virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:4586,Availability,error,error,4586,"oidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:3043,Deployability,update,updated,3043,"m.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; v",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:3063,Deployability,update,update,3063,"t.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); ",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:7256,Deployability,update,update,7256,"queID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMemStat&operator=(const TMemStat&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:9575,Deployability,update,update,9575,"t level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfIsActiveis object attached to MemStat. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); Supported options:; ""gnubuiltin"" - if declared, then MemStat will use gcc build-in function,; otherwise glibc backtrace will be used. Note: Currently MemStat uses a hard-coded output file name (for writing) = ""memstat.root"";. ~TMemStat(); destructor. void Close(); close the TMemStat manager. void Disable(); Disable memory statistics. void Enable(); Enable memory statistics. void Show(Double_t update = 0.10000000000000001, Int_t nbigleaks = 20, const char* fname = ""*""); Show results. TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000). » Author: Anar Manafov (A.Manafov@gsi.de) 2008-03-02 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/memstat:$Id$ » Last generated: 2015-06-18 17:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:395,Energy Efficiency,allocate,allocated,395,". TMemStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » MEMSTAT; » TMemStat. class TMemStat: public TObject. TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMem",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:1713,Integrability,depend,depending,1713,"ot > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of ",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStat.html:787,Modifiability,variab,variable,787,". TMemStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » MEMSTAT; » TMemStat. class TMemStat: public TObject. TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMem",MatchSource.WIKI,root/html604/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStat.html
https://root.cern/root/html604/TMemStatShow.html:4891,Availability,error,error,4891,"idTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidEventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static voidEventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) co",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:4975,Availability,error,error,4975,"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidEventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static voidEventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFillBTString(Int_t bin, Int_t mode, TString& btstring); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:3271,Deployability,update,updated,3271,"es 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation.; When moving the mouse on this canvas, a tooltip shows the backtrace for the allocations; at the address at the mouse position. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks. if <=0 canvas2 and canvas3 are not shown; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Author: Rene Brun 7 July 2010. Function Members (Methods); public:. virtual~TMemStatShow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) co",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:3291,Deployability,update,update,3291,"10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation.; When moving the mouse on this canvas, a tooltip shows the backtrace for the allocations; at the address at the mouse position. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks. if <=0 canvas2 and canvas3 are not shown; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Author: Rene Brun 7 July 2010. Function Members (Methods); public:. virtual~TMemStatShow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Del",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:7858,Deployability,update,update,7858,"od, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMemStatShow&operator=(const TMemStatShow&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); static voidSetAddressRange(Long64_t nbytes = 0, Long64_t first = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetEntryRange(Long64_t nentries = 0, Long64_t first = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidShow(Double_t update = 0.",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:11848,Deployability,update,update,11848," specify a memory address range to process (static function).; This function can be used to restrict the range of memory addresses; to be analyzed. For example whem TmemStat is run on a 64 bits machine and; the results visualized on a 32 bits machine, it might be necessary to; restrict the analysis range to the addresses below 2 Gigabytes, eg; TMemStatShow::SetMemoryRange(500000000,0); //analyse only the first 500 MBytes; -first : first address to process (default is 0); -nbytes : number of addresses in bytes to process starting at first; if 0 (default), then all addresses are processed. void SetEntryRange(Long64_t nentries = 0, Long64_t first = 0); specify a range of entries to process (static function); -first : first entry to process (default is 0); -nentries : number of entries to process starting at first; if 0 (default), then all entries are processed; call this function when the amount of data collected in the Tree is large; and therefore making the analysis slow. void Show(Double_t update = 0.10000000000000001, Int_t nbigleaks = 20, const char* fname = ""*""); function called by TMemStat::Show; Open the memstat data file, then call TTree::Draw to precompute; the arrays of positions and nbytes per entry.; update is the time interval in the data file in seconds after which; the display is updated. For example is the job producing the memstat.root file; took 100s to execute, an update of 0.1s will generate 1000 time views of; the memory use.; the histogram hbigleaks will contain the nbigleaks largest leaks; if fname==""*"" (default), the most recent file memstat*.root will be taken. void EventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the allocatios histogram. void EventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the histogram of leaks. void FillBTString(Int_t bin, Int_t mode, TString& btstring); static: fill btstring with the tracebac",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:12073,Deployability,update,update,12073,"o; restrict the analysis range to the addresses below 2 Gigabytes, eg; TMemStatShow::SetMemoryRange(500000000,0); //analyse only the first 500 MBytes; -first : first address to process (default is 0); -nbytes : number of addresses in bytes to process starting at first; if 0 (default), then all addresses are processed. void SetEntryRange(Long64_t nentries = 0, Long64_t first = 0); specify a range of entries to process (static function); -first : first entry to process (default is 0); -nentries : number of entries to process starting at first; if 0 (default), then all entries are processed; call this function when the amount of data collected in the Tree is large; and therefore making the analysis slow. void Show(Double_t update = 0.10000000000000001, Int_t nbigleaks = 20, const char* fname = ""*""); function called by TMemStat::Show; Open the memstat data file, then call TTree::Draw to precompute; the arrays of positions and nbytes per entry.; update is the time interval in the data file in seconds after which; the display is updated. For example is the job producing the memstat.root file; took 100s to execute, an update of 0.1s will generate 1000 time views of; the memory use.; the histogram hbigleaks will contain the nbigleaks largest leaks; if fname==""*"" (default), the most recent file memstat*.root will be taken. void EventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the allocatios histogram. void EventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the histogram of leaks. void FillBTString(Int_t bin, Int_t mode, TString& btstring); static: fill btstring with the traceback corresponding to entry in T; btstring must be initialized in calling function. TMemStatShow(); {;}. virtual ~TMemStatShow(); {;}. » Author: Rene Brun 21/09/2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last genera",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:12157,Deployability,update,updated,12157,"o; restrict the analysis range to the addresses below 2 Gigabytes, eg; TMemStatShow::SetMemoryRange(500000000,0); //analyse only the first 500 MBytes; -first : first address to process (default is 0); -nbytes : number of addresses in bytes to process starting at first; if 0 (default), then all addresses are processed. void SetEntryRange(Long64_t nentries = 0, Long64_t first = 0); specify a range of entries to process (static function); -first : first entry to process (default is 0); -nentries : number of entries to process starting at first; if 0 (default), then all entries are processed; call this function when the amount of data collected in the Tree is large; and therefore making the analysis slow. void Show(Double_t update = 0.10000000000000001, Int_t nbigleaks = 20, const char* fname = ""*""); function called by TMemStat::Show; Open the memstat data file, then call TTree::Draw to precompute; the arrays of positions and nbytes per entry.; update is the time interval in the data file in seconds after which; the display is updated. For example is the job producing the memstat.root file; took 100s to execute, an update of 0.1s will generate 1000 time views of; the memory use.; the histogram hbigleaks will contain the nbigleaks largest leaks; if fname==""*"" (default), the most recent file memstat*.root will be taken. void EventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the allocatios histogram. void EventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the histogram of leaks. void FillBTString(Int_t bin, Int_t mode, TString& btstring); static: fill btstring with the traceback corresponding to entry in T; btstring must be initialized in calling function. TMemStatShow(); {;}. virtual ~TMemStatShow(); {;}. » Author: Rene Brun 21/09/2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last genera",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:12247,Deployability,update,update,12247,"nalyse only the first 500 MBytes; -first : first address to process (default is 0); -nbytes : number of addresses in bytes to process starting at first; if 0 (default), then all addresses are processed. void SetEntryRange(Long64_t nentries = 0, Long64_t first = 0); specify a range of entries to process (static function); -first : first entry to process (default is 0); -nentries : number of entries to process starting at first; if 0 (default), then all entries are processed; call this function when the amount of data collected in the Tree is large; and therefore making the analysis slow. void Show(Double_t update = 0.10000000000000001, Int_t nbigleaks = 20, const char* fname = ""*""); function called by TMemStat::Show; Open the memstat data file, then call TTree::Draw to precompute; the arrays of positions and nbytes per entry.; update is the time interval in the data file in seconds after which; the display is updated. For example is the job producing the memstat.root file; took 100s to execute, an update of 0.1s will generate 1000 time views of; the memory use.; the histogram hbigleaks will contain the nbigleaks largest leaks; if fname==""*"" (default), the most recent file memstat*.root will be taken. void EventInfo1(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the allocatios histogram. void EventInfo2(Int_t event, Int_t px, Int_t py, TObject* selected); static: draw the tooltip showing the backtrace for the histogram of leaks. void FillBTString(Int_t bin, Int_t mode, TString& btstring); static: fill btstring with the traceback corresponding to entry in T; btstring must be initialized in calling function. TMemStatShow(); {;}. virtual ~TMemStatShow(); {;}. » Author: Rene Brun 21/09/2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:495,Energy Efficiency,allocate,allocated,495,". TMemStatShow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TMemStatShow. class TMemStatShow: public TObject. Utility class post-processing the file generated by TMemStat (default memstat.root). TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:1813,Integrability,depend,depending,1813,"ot > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation.; When moving the mouse on this canvas, a tooltip shows the backtrace for the allocations; at the address at the mouse position. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse o",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMemStatShow.html:887,Modifiability,variab,variable,887,". TMemStatShow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TMemStatShow. class TMemStatShow: public TObject. Utility class post-processing the file generated by TMemStat (default memstat.root). TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.",MatchSource.WIKI,root/html604/TMemStatShow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMemStatShow.html
https://root.cern/root/html604/TMergerInfo.html:1671,Availability,error,error,1671,"idAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vir",MatchSource.WIKI,root/html604/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMergerInfo.html
https://root.cern/root/html604/TMergerInfo.html:1755,Availability,error,error,1755,"ppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_t",MatchSource.WIKI,root/html604/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMergerInfo.html
https://root.cern/root/html604/TMergerInfo.html:506,Integrability,message,messages,506,". TMergerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TMergerInfo. class TMergerInfo: public TObject. TProof. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the worker servers, it keeps track of how many workers are; running, it keeps track of the workers running status, it broadcasts; messages to all workers, it collects results, etc. Function Members (Methods); public:. virtual~TMergerInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindOb",MatchSource.WIKI,root/html604/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMergerInfo.html
https://root.cern/root/html604/TMessage.html:2729,Availability,error,error,2729," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObj",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:2813,Availability,error,error,2813,"l TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtu",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25511,Availability,error,error,25511,"at was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 ",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25759,Availability,error,error,25759,"(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects ca",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:22701,Integrability,message,message,22701,"ading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:22813,Integrability,message,message,22813,"ading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:22902,Integrability,message,message,22902,"ading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:23446,Integrability,message,message,23446,"fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteI",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:23478,Integrability,message,message,23478," buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writin",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:23544,Integrability,message,message,23544,"::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was re",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:23592,Integrability,message,message,23592,"::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was re",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:23688,Integrability,message,message,23688,"he message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:23840,Integrability,message,message,23840,"ar*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message leng",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:23912,Integrability,message,message,23912,"ar*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message leng",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:24088,Integrability,message,message,24088," WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kM",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:24515,Integrability,message,message,24515,"OOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the mess",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:24631,Integrability,message,message,24631,"are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise re",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:24771,Integrability,message,message,24771,"g process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwi",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:24854,Integrability,message,message,24854,"ed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support fo",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:24893,Integrability,message,message,24893,"ed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support fo",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25021,Integrability,message,message,25021," reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSock",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25091,Integrability,message,message,25091,". ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to st",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25374,Integrability,message,message,25374,"ction returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. USh",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25387,Integrability,message,message,25387,"VirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is alre",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25464,Integrability,message,message,25464,"VirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is alre",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25554,Integrability,message,message,25554,"at was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 ",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25666,Integrability,message,message,25666,"amerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompre",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25679,Integrability,message,message,25679,"he StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() co",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:25833,Integrability,message,message,25833,"t again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects cannot be copied or assigned. void operator=(const TMessag",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:26446,Integrability,message,message,26446,"e compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TMessage(const TMessage& ); TMessage objects cannot be copied or assigned. void operator=(const TMessage& ). Bool_t TestBitNumber(UInt_t bitnumber) const; used by friend TSocket. { return fBitsPIDs.TestBitNumber(bitnumber); }. TClass * GetClass() const; { return fClass;}. void Reset(). UInt_t What() const; { return fWhat; }. void EnableSchemaEvolution(Bool_t enable = kTRUE); { fEvolution = enable; }. Bool_t UsesSchemaEvolution() const; { return fEvolution; }. TList * GetStreamerInfos() const; { return fInfos; }. char * CompBuffer() const; { return fBufComp; }. Int_t CompLength() const; { return (Int_t)(fBufCompCur - fBufComp); }. » Author: Fons Rademakers 19/12/96 » Copyright (C) 1995-20",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:392,Modifiability,inherit,inherits,392,". TMessage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TMessage. class TMessage: public TBufferFile. TMessage. Message buffer class used for serializing objects and sending them; over a network. This class inherits from TBuffer the basic I/O; serializer. Function Members (Methods); public:. virtual~TMessage(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTBufferFile::ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tTBufferFile::ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tTBufferFile::ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); vir",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:22475,Modifiability,extend,extending,22475,"fMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of mes",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessage.html:21621,Performance,cache,cache,21621,"fer::kRead; static TObject::(anonymous)TObject::kSingleKey; static TBufferFile::(anonymous)TBufferFile::kStreamedMemberWise; static TBufferFile::(anonymous)TBufferFile::kTextBasedStreaming; static TBufferFile::(anonymous)TBufferFile::kUser1; static TBufferFile::(anonymous)TBufferFile::kUser2; static TBufferFile::(anonymous)TBufferFile::kUser3; static TBuffer::EModeTBuffer::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; TBuffer::CacheList_tTBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fB",MatchSource.WIKI,root/html604/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessage.html
https://root.cern/root/html604/TMessageHandler.html:4159,Availability,error,error,4159," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGet",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:4243,Availability,error,error,4243,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTotalMessageCount() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tHandleD",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:682,Deployability,install,install,682,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:346,Integrability,message,messages,346,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:450,Integrability,message,messages,450,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:570,Integrability,message,message,570,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:623,Integrability,message,message,623,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:665,Integrability,message,message,665,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:704,Integrability,message,message,704,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:734,Integrability,message,message,734,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:829,Integrability,message,message,829,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:875,Integrability,message,message,875,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:924,Integrability,message,message,924,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:970,Integrability,message,message,970,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:10227,Integrability,message,message,10227,"ic TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:10275,Integrability,message,message,10275,"ic TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:10313,Integrability,message,messages,10313,"ic TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:10618,Integrability,message,message,10618,"ic TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:10767,Integrability,message,messages,10767,"ic TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, c",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11067,Integrability,message,message,11067,"nonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11123,Integrability,message,message,11123,"nonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const TClass*fClassclass for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11211,Integrability,message,message,11211,"s for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Ren",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11273,Integrability,message,message,11273,"s for which message has to be handled; Int_t*fCntscount per message; Bool_tfDerivedif true handle messages also for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Ren",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11312,Integrability,message,message,11312,"o for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » L",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11343,Integrability,message,messages,11343,"o for derived classes; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » L",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11424,Integrability,message,message,11424,"to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. F",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11507,Integrability,message,messages,11507,"ect; Int_tfMessIdmessage id (often matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general plea",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11573,Integrability,message,message,11573,"n matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11769,Integrability,message,message,11769,"n matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11813,Integrability,message,message,11813,"n matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:11846,Integrability,message,messages,11846,"n matching specific enum in fClass); Int_t*fMessIdsmessage ids; const TObject*fMessObjobject generating message; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfSizenumber of different messages handled; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); Create a new message handler for class cl and add it to the list; of message handlers. TMessageHandler(const char* cl, Bool_t derived = kTRUE); Create a new message handler for class named cl and add it to the list; of message handlers. void Add(); Add this message handler to the list of messages handlers. Int_t GetMessageCount(Int_t messId) const; Return counter for message with ID=messid. Int_t GetTotalMessageCount() const; Return total number of messages. void HandleMessage(Int_t id, const TObject* obj); Store message origin, keep statistics and call Notify(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Print(Option_t* option = """") const; Print statistics for this message handler. void Remove(); Remove this message handler from the list of messages handlers. void * GetSender(); { return this; }. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE). virtual ~TMessageHandler(). Int_t GetSize() const; { return fSize; }. Bool_t HandleDerived() const; { return fDerived; }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. void Notified(); { Emit(""Notified()""); }. » Author: Rene Brun 11/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:609,Security,access,access,609,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:819,Testability,log,logged,819,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:865,Testability,log,logged,865,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:914,Testability,log,logged,914,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMessageHandler.html:960,Testability,log,logged,960,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html604/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMessageHandler.html
https://root.cern/root/html604/TMethod.html:1547,Availability,error,error,1547," virtual~TMethod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Long_tTFunction::ExtraProperty() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindO",MatchSource.WIKI,root/html604/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethod.html
https://root.cern/root/html604/TMethod.html:1631,Availability,error,error,1631,"t char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Long_tTFunction::ExtraProperty() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClass() const; virtual const char*GetCommentString(); TDictionary::DeclId_tTFunction::GetDeclId() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetN",MatchSource.WIKI,root/html604/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethod.html
https://root.cern/root/html604/TMethod.html:10400,Deployability,update,updates,10400,"ns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 are data fields in the same class.; (""pointers"" to data members). TMethodCall * GetterMethod(); Return call environment for the getter method in case this is a; *TOGGLE method (for the context menu). Bool_t IsValid(); Return true if this function object is pointing to a currently; loaded function. If a function is unloaded after the TMethod; is created, the TMethod will be set to be invalid. TMethodCall * SetterMethod(); Return call environment for this method in case this is a; *TOGGLE method which takes a single boolean or integer argument. TList * GetListOfMethodArgs(); Returns methodarg list and additionally updates fDataMember in TMethod by; calling FindDataMember();. void SetMenuItem(const char* docstring); Set the menu item as prescribed in the doctstring. Bool_t Update(MethodInfo_t* info); Update the TMethod to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). void SetMenuItem(const char* docstring). TClass * GetClass() const; { return fClass; }. EMenuItemKind IsMenuItem() const; { return fMenuItem; }. const char * Getter() const; { return fGetter; }. » Author: Rene Brun 09/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethod.html
https://root.cern/root/html604/TMethod.html:10062,Performance,load,loaded,10062,"ethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 are data fields in the same class.; (""pointers"" to data members). TMethodCall * GetterMethod(); Return call environment for the getter method in case this is a; *TOGGLE method (for the context menu). Bool_t IsValid(); Return true if this function object is pointing to a currently; loaded function. If a function is unloaded after the TMethod; is created, the TMethod will be set to be invalid. TMethodCall * SetterMethod(); Return call environment for this method in case this is a; *TOGGLE method which takes a single boolean or integer argument. TList * GetListOfMethodArgs(); Returns methodarg list and additionally updates fDataMember in TMethod by; calling FindDataMember();. void SetMenuItem(const char* docstring); Set the menu item as prescribed in the doctstring. Bool_t Update(MethodInfo_t* info); Update the TMethod to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). void SetMenuItem(const char* docstring). TClass * GetClass() const; { return fClass; }. EMenuItemKind IsMenuItem() const; { return fMenuItem; }. const char * Getter() const; { return fGetter; }. » Author: Rene Brun 09/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » ",MatchSource.WIKI,root/html604/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethod.html
https://root.cern/root/html604/TMethodArg.html:1584,Availability,error,error,1584," virtual~TMethodArg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAtt",MatchSource.WIKI,root/html604/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodArg.html
https://root.cern/root/html604/TMethodArg.html:1668,Availability,error,error,1668,"method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TDataMember*GetDataMember() const; const char*GetDefault() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; ",MatchSource.WIKI,root/html604/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodArg.html
https://root.cern/root/html604/TMethodArg.html:9457,Usability,learn,learn,9457," Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". std::string GetTypeNormalizedName() const; Get the normalized name of the return type. A normalized name is fully; qualified and has all typedef desugared except for the 'special' typedef; which include Double32_t, Float16_t, [U]Long64_t and std::string. It; also has std:: removed [This is subject to change]. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to specify list of options or current value for your; MethodArg (i.e. it is used as initial values in argument-asking dialogs; popped up from context-meny),you can get this value from one of data; members of the class.; The only restriction is, that this DataMember object must have its; Getter/Setter methods set-up correctly - for details look at TDataMember.; To learn how to specify the data member to which the argument should; ""point"", look at TMethod. This is TMethod which sets up fDataMember,; so it could work correctly. void Update(MethodArgInfo_t* info); Update fInfo (to 0 for unloading and non-zero for reloading).; This takes ownership of 'info'. TMethodArg(const TMethodArg& ). TMethodArg& operator=(const TMethodArg& ). TFunction * GetMethod() const; { return fMethod; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodArg.html
https://root.cern/root/html604/TMethodBrowsable.html:3162,Availability,error,error,3162,,MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:3246,Availability,error,error,3246,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); ",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:11201,Integrability,depend,depending,11201,"h::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:11378,Integrability,depend,depending,11378,"h::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:435,Modifiability,extend,extend,435,". TMethodBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; ",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:1162,Performance,cache,cached,1162,"ROOT; » TREE; » TREE; » TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TMethodBrowsabl",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:1223,Performance,cache,cached,1223,"ROOT; » TREE; » TREE; » TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TMethodBrowsabl",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:10913,Security,access,access,10913,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or sug",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:10943,Security,access,access,10943,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or sug",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:1410,Usability,simpl,simple,1410,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); vir",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodBrowsable.html:9597,Usability,simpl,simple,9597,"ect::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMethod*fMethodpointer to a method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Constructor.; Links a TBranchElement to a TMethod, allowing the TBrowser to; browse simple methods. The c'tor sets the name for a method ""Class::Method(params) const""; to ""Method(params)"", title to TMethod::GetPrototype. void GetBrowsableMethodsForClass(TClass* cl, TList& list); Given a class, this methods fills list with TMethodBrowsables; for the class and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being brows",MatchSource.WIKI,root/html604/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodBrowsable.html
https://root.cern/root/html604/TMethodCall.html:9127,Energy Efficiency,efficient,efficient,9127,"alling ~xxx; CallFunc_t*fFuncCINT method invocation environment; TFunction*fMetPtrpointer to the method or function info; TStringfMethodmethod name; Long_tfOffsetoffset added to object pointer before method invocation; TStringfParamsargument string; TStringfProtoprototype string; TMethodCall::EReturnTypefRetTypemethod return type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, CallFunc_t* callfunc, Long_t offset = 0); Create a method invocation environment for a specific class, method; described by the callfunc. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(TFunction* func); Create a global function invocation environment base on a TFunction object.; To execute the function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment bas",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:9452,Energy Efficiency,efficient,efficient,9452,"n type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, CallFunc_t* callfunc, Long_t offset = 0); Create a method invocation environment for a specific class, method; described by the callfunc. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(TFunction* func); Create a global function invocation environment base on a TFunction object.; To execute the function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment based on; the CallFunc object and the TClass describing the function context. void Init(TFunction* func); Initialize the method invocation environment based on; the TFunction object. void Init(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE); Initialize the method invocation environment. Neces",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:9723,Energy Efficiency,efficient,efficient,9723,"ethod invocation environment for a specific class, method; described by the callfunc. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(TFunction* func); Create a global function invocation environment base on a TFunction object.; To execute the function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment based on; the CallFunc object and the TClass describing the function context. void Init(TFunction* func); Initialize the method invocation environment based on; the TFunction object. void Init(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(.",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:10671,Energy Efficiency,efficient,efficient,10671,"; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment based on; the CallFunc object and the TClass describing the function context. void Init(TFunction* func); Initialize the method invocation environment based on; the TFunction object. void Init(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, Bool_t objectIsConst, TClass* cl, const ClassInfo_t* cinfo, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:11041,Energy Efficiency,efficient,efficient,11041,"CallFunc_t* func, Long_t offset = 0); Initialize the method invocation environment based on; the CallFunc object and the TClass describing the function context. void Init(TFunction* func); Initialize the method invocation environment based on; the TFunction object. void Init(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, Bool_t objectIsConst, TClass* cl, const ClassInfo_t* cinfo, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:11787,Energy Efficiency,efficient,efficient,11787,"lize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, Bool_t objectIsConst, TClass* cl, const ClassInfo_t* cinfo, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the spec",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:12225,Energy Efficiency,efficient,efficient,12225,"ClassInfo_t* cinfo, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* par",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:334,Integrability,interface,interface,334,". TMethodCall. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TMethodCall. class TMethodCall: public TObject. TMethodCall. Method or function calling interface. Objects of this class contain; the (CINT) environment to call a global function or a method for an; object of a specific class with the desired arguments. This class is; espicially useful when a method has to be called more times for; different objects and/or with different arguments. If a function or; method needs to be called only once one better uses; TInterpreter::Execute(). Function Members (Methods); public:. virtual~TMethodCall(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCallDtorOnly(Bool_t set = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecute(); voidExecute(void* object); voidExecute(const char* params); voidExecute(Long_t& retLong); voidExecute(Double_t& retDouble); voidExecute(void* object, const char* params); voidExecute(void* object, Long_t& retLong); voidExecute(void* object, Double_t& retDouble); voidExecute(void* object, char** retText); voidExecute(const char* para",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:12619,Performance,cache,cached,12619," information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(void* object, char** retText); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, char** retText); Execute the method for the specified object and argument values. void SetParamPtrs(voi",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMethodCall.html:12391,Usability,usab,usable,12391," and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(vo",MatchSource.WIKI,root/html604/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMethodCall.html
https://root.cern/root/html604/TMinuit.html:3439,Availability,down,down,3439,"lected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it i",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:4112,Availability,error,error,4112,"it b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakn",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:4177,Availability,error,error,4177,"it b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakn",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:4224,Availability,error,errors,4224,"it b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakn",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:4799,Availability,error,error,4799,"alue gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:6446,Availability,error,errors,6446,"imits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels s",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:6563,Availability,error,error,6563,"n the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:6595,Availability,error,errors,6595,"n the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:6812,Availability,error,errors,6812,"ause the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carri",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:6950,Availability,error,error,6950,"if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given po",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:6989,Availability,error,error,6989," to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by t",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:7035,Availability,error,errors,7035," to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by t",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:7171,Availability,reliab,reliability,7171,"/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indic",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:7196,Availability,error,error,7196,"/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indic",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:7388,Availability,error,error,7388,"F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:7730,Availability,error,error,7730,"ore common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:7820,Availability,error,errors,7820,". Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlat",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:8067,Availability,error,errors,8067,"retation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which ha",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:8163,Availability,error,error,8163,"MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so h",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:8212,Availability,reliab,reliable,8212,"MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so h",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:8528,Availability,error,errors,8528,"ort DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them,",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:8730,Availability,error,error,8730,"liability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:9135,Availability,error,errors,9135," there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:9332,Availability,error,errors,9332,"are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; tha",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:9407,Availability,error,errors,9407,"ed but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data poi",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:9472,Availability,error,errors,9472,"lieves the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other pr",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:9565,Availability,error,errors,9565,"lieves the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other pr",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:10147,Availability,recover,recovers,10147,"s been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly sc",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:10567,Availability,error,error,10567,"of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of expo",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:10872,Availability,error,errors,10872,"hat it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:11295,Availability,error,error,11295," minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the sec",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:11811,Availability,error,errors,11811," roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:11911,Availability,error,errors,11911," roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:11959,Availability,error,errors,11959,"ral, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:12035,Availability,error,errors,12035," are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in extern",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:12344,Availability,error,error,12344," of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:12469,Availability,error,error,12469," of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:12778,Availability,error,error,12778,"errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; e",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:12842,Availability,error,error,12842,"errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; e",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:13130,Availability,error,error,13130,"g that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:13237,Availability,error,errors,13237,"rts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:13380,Availability,error,error,13380," exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* opti",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:13635,Availability,error,errors,13635,"ransformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired limits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:13727,Availability,error,error,13727,"mits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:13825,Availability,error,error,13825,"mits). Therefore the internal error matrix kept by; Minuit must be transformed to an external error matrix for the user.; This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; where DEXDIN is the derivative of the external value with respect to the; internal value at the minimum. This is a linearization of the; transformation, and is the only way to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:14124,Availability,error,errors,14124,"to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArrays(); virtual In",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:14161,Availability,error,errors,14161,"to produce an error matrix in external; coordinates meaningful to the user. But when reporting the individual; parabolic errors for limited parameters, Minuit can do a little better, so; it does. In this case, Minuit actually transforms the ends of the; internal ""error bar"" to external coordinates and reports the length of; this transformed interval. Strictly speaking, it is now asymmetric, but; since the origin of the asymmetry is only an artificial transformation it; does not make much sense, so the transformed errors are symmetrized. The result of all the above is that for parameters with limits, the error; reported by Minuit is not exactly equal to the square root of the diagonal; element of the error matrix. The difference is a measure of how much the; limits deform the problem. If possible, it is suggested not to use limits; on parameters, and the problem goes away. If for some reason limits are; necessary, and you are sensitive to the difference between the two ways of; calculating the errors, it is suggested to use Minos errors which take; into account the non-linearities much more precisely. Function Members (Methods); public:. virtual~TMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildArrays(Int_t maxpar = 15); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArrays(); virtual In",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:15615,Availability,error,error,15615,"ect*Clone(const char* newname = """") const; virtual Int_tCommand(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGetNumPars() const; TObject*GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetParamete",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:15699,Availability,error,error,15699,"; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tDefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxIterations() const; TMethodCall*GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumFixedPars() const; virtual Int_tGetNumFreePars() const; virtual Int_tGetNumPars() const; TObject*GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; virtual TObjec",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:19181,Availability,toler,toler,19181,"l voidmncuve(); virtual voidmnderi(); virtual voidmndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); virtual voidmneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); virtual voidmnemat(Double_t* emat, Int_t ndim); virtual voidmnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); virtual voidmneval(Double_t anext, Double_t& fnext, Int_t& ierev); virtual voidmnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); virtual voidmnexin(Double_t* pint); virtual voidmnfixp(Int_t iint, Int_t& ierr); virtual voidmnfree(Int_t k); virtual voidmngrad(); virtual voidmnhelp(TString comd); virtual voidmnhelp(const char* command = """"); virtual voidmnhes1(); virtual voidmnhess(); virtual voidmnimpr(); virtual voidmninex(Double_t* pint); virtual voidmninit(Int_t i1, Int_t i2, Int_t i3); virtual voidmnlims(); virtual voidmnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); virtual voidmnmatu(Int_t kode); virtual voidmnmigr(); virtual voidmnmnos(); virtual voidmnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); virtual voidmnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); virtual voidmnpars(TString& crdbuf, Int_t& icondn); virtual voidmnpfit(Double_t* parx2p, Double_t* pary2p, Int_t npar2p, Double_t* coef2p, Double_t& sdev2p); virtual voidmnpint(Double_t& pexti, Int_t i, Double_t& pinti); virtual voidmnplot(Double_t* xpt, Double_t* ypt, char* chpt, Int_t nxypt, Int_t npagwd, Int_t npagln); virtual voidmnpout(Int_t iuext, TString& chnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; virtual voidmnprin(Int_t inkode, Double_t fval); virtual voidmnpsdf(); virtual voidmnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); virtual voidmnrn15(Double_t& val, Int_t& inseed); virtual voidmnrset(Int_t iopt); virtual voidmnsave(); virtual v",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:24389,Availability,error,errors,24389,"Minimum value found for FCN; Double_tfApsi; Double_tfBigedmBig EDM = 123456; Double_t*fBlim[fMaxpar2] Upper limits for parameters; Double_t*fCOMDplist[fMaxpar] array used in mncomd; Double_t*fCONTgcc[fMaxpar] array used in mncont; Double_t*fCONTw[fMaxpar] array used in mncont; TStringfCfrom; char*fChpt!Character to be plotted at the X,Y contour positions; TStringfCovmes[4]; TString*fCpnam[fMaxpar2] Array of parameters names; TStringfCstatu; TStringfCtitl; TStringfCundef; TStringfCvrsn; TStringfCword; Double_tfDcovarRelative change in covariance matrix; Double_t*fDgrd[fMaxpar] Uncertainties; Double_t*fDirin[fMaxpar] (Internal) step sizes for current step; Double_t*fDirins[fMaxpar] (Internal) step sizes for current step for fixed params; Double_tfEDMEstimated vertical distance to the minimum; Int_tfEmptyInitialization flag (1 = Minuit initialized); Double_tfEpsi; Double_tfEpsma2sqrt(fEpsmac); Double_tfEpsmacmachine precision for floating points:; Double_t*fErn[fMaxpar] Negative Minos errors if calculated; Double_t*fErp[fMaxpar] Positive Minos errors if calculated; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)fFCN!; Double_t*fFIXPyy[fMaxpar] array used in mnfixp; Double_tfFval3; Double_t*fG2[fMaxpar]; Double_t*fG2s[fMaxpar]; Double_t*fGRADgf[fMaxpar] array used in mngrad; Double_t*fGin[fMaxpar2]; Double_t*fGlobcc[fMaxpar] Global Correlation Coefficients; Bool_tfGraphicsModetrue if graphics mode on (default); Double_t*fGrd[fMaxpar] First derivatives; Double_t*fGrds[fMaxpar]; Double_t*fGstep[fMaxpar] Step sizes; Double_t*fGsteps[fMaxpar]; Double_t*fHESSyy[fMaxpar] array used in mnhess; Double_t*fIMPRdsav[fMaxpar] array used in mnimpr; Double_t*fIMPRy[fMaxpar] array used in mnimpr; Int_tfISW[7]Array of switches; Int_tfIcirc[2]; Int_tfIcomndNumber of commands; Int_tfIdbg[11]Array of internal debug switches; Int_t*fIpfix[fMaxpar] List of fixed parameters; Int_tfIstkrd[10]; Int_tfIstkwr[10]; Int_tfIstrat; Int_tfIsysrdstandardInput unit; Int_tfIsyssa; Int_tfIsyswrstandar",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:24449,Availability,error,errors,24449,"ig EDM = 123456; Double_t*fBlim[fMaxpar2] Upper limits for parameters; Double_t*fCOMDplist[fMaxpar] array used in mncomd; Double_t*fCONTgcc[fMaxpar] array used in mncont; Double_t*fCONTw[fMaxpar] array used in mncont; TStringfCfrom; char*fChpt!Character to be plotted at the X,Y contour positions; TStringfCovmes[4]; TString*fCpnam[fMaxpar2] Array of parameters names; TStringfCstatu; TStringfCtitl; TStringfCundef; TStringfCvrsn; TStringfCword; Double_tfDcovarRelative change in covariance matrix; Double_t*fDgrd[fMaxpar] Uncertainties; Double_t*fDirin[fMaxpar] (Internal) step sizes for current step; Double_t*fDirins[fMaxpar] (Internal) step sizes for current step for fixed params; Double_tfEDMEstimated vertical distance to the minimum; Int_tfEmptyInitialization flag (1 = Minuit initialized); Double_tfEpsi; Double_tfEpsma2sqrt(fEpsmac); Double_tfEpsmacmachine precision for floating points:; Double_t*fErn[fMaxpar] Negative Minos errors if calculated; Double_t*fErp[fMaxpar] Positive Minos errors if calculated; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)fFCN!; Double_t*fFIXPyy[fMaxpar] array used in mnfixp; Double_tfFval3; Double_t*fG2[fMaxpar]; Double_t*fG2s[fMaxpar]; Double_t*fGRADgf[fMaxpar] array used in mngrad; Double_t*fGin[fMaxpar2]; Double_t*fGlobcc[fMaxpar] Global Correlation Coefficients; Bool_tfGraphicsModetrue if graphics mode on (default); Double_t*fGrd[fMaxpar] First derivatives; Double_t*fGrds[fMaxpar]; Double_t*fGstep[fMaxpar] Step sizes; Double_t*fGsteps[fMaxpar]; Double_t*fHESSyy[fMaxpar] array used in mnhess; Double_t*fIMPRdsav[fMaxpar] array used in mnimpr; Double_t*fIMPRy[fMaxpar] array used in mnimpr; Int_tfISW[7]Array of switches; Int_tfIcirc[2]; Int_tfIcomndNumber of commands; Int_tfIdbg[11]Array of internal debug switches; Int_t*fIpfix[fMaxpar] List of fixed parameters; Int_tfIstkrd[10]; Int_tfIstkwr[10]; Int_tfIstrat; Int_tfIsysrdstandardInput unit; Int_tfIsyssa; Int_tfIsyswrstandard output unit; Int_tfItaur; Int_tfKe1cr; Int_tfKe2cr; Bool_t",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:28102,Availability,error,errors,28102,,MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:28332,Availability,error,error,28332,,MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:28575,Availability,error,error,28575,"axpar]; TObject*fPlotPointer to TGraph object created by mncont; Double_t*fPrho[fMaxpar] Minimum point of parabola; Double_t*fPstar[fMaxpar2]; Double_t*fPstst[fMaxpar]; Double_t*fSEEKxbest[fMaxpar] array used in mnseek; Double_t*fSEEKxmid[fMaxpar] array used in mnseek; Double_t*fSIMPy[fMaxpar] array used in mnsimp; Int_tfStatusStatus flag for the last called Minuit function; Double_t*fU[fMaxpar2] External (visible to user in FCN) value of parameters; Double_tfUndefiUndefined number = -54321; Double_tfUpFCN+-UP defines errors (for chisquare fits UP=1); Double_tfUpdflt; Double_t*fVERTpp[fMaxpar] array used in mnvert; Double_t*fVERTq[fMaxpar] array used in mnvert; Double_t*fVERTs[fMaxpar] array used in mnvert; Double_t*fVhmat[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; Double_tfVlimhi; Double_tfVlimlo; Double_t*fVthmat[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; TStringfWarmes[100]; Double_t*fWerr[fMaxpar] External parameters error (standard deviation, defined by UP); Double_t*fWord7[fMaxpar]; Double_t*fX[fMaxpar] Internal parameters values; Double_tfXdircr; Double_tfXmidcr; Double_t*fXpt[fMaxcpt] X array of points for contours; Double_t*fXs[fMaxpar] Internal parameters values saved for fixed params; Double_t*fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tfYdircr; Double_tfYmidcr; Double_t*fYpt[fMaxcpt] Y array of points for contours; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMinuit::(anonymous)kMAXWARN; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TOb",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:30917,Availability,avail,available,30917,"amed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuit(); Minuit normal constructor*-*-*-*-; *-* ========================. TMinuit(Int_t maxpar); Minuit normal constructor*-*-*-*-; *-* ========================. maxpar is the maximum number of parameters used with this TMinuit object. TMinuit(const TMinuit& m); Private TMinuit copy ctor. TMinuit can not be copied. ~TMinuit(); Minuit default destructor*-*-*-*-; *-* =========================. void BuildArrays(Int_t maxpar = 15); -*-*-*Create internal Minuit arrays for the maxpar parameters; *-* =======================================================. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; Function pointer is copied to Clone. Int_t Command(const char* command); execute a Minuit command; Equivalent to MNEXCM except that the command is given as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:31043,Availability,avail,available,31043,"tion; TMinuit(); Minuit normal constructor*-*-*-*-; *-* ========================. TMinuit(Int_t maxpar); Minuit normal constructor*-*-*-*-; *-* ========================. maxpar is the maximum number of parameters used with this TMinuit object. TMinuit(const TMinuit& m); Private TMinuit copy ctor. TMinuit can not be copied. ~TMinuit(); Minuit default destructor*-*-*-*-; *-* =========================. void BuildArrays(Int_t maxpar = 15); -*-*-*Create internal Minuit arrays for the maxpar parameters; *-* =======================================================. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; Function pointer is copied to Clone. Int_t Command(const char* command); execute a Minuit command; Equivalent to MNEXCM except that the command is given as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF paramet",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:31770,Availability,error,errors,31770," as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:34195,Availability,error,error,34195,"ho uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined; as fixed or free. The constant parameters are not counted. Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Mi",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:34668,Availability,error,error,34668,"lag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined; as fixed or free. The constant parameters are not counted. Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Minuit print level; printlevel = -1 quiet (also suppresse all warnings); = 0 normal; = 1 verbose. void mnamin(); Initialize AMIN*-*-*-*-; *-* ===============; *-*C Called from many places. Initializes the value of AMIN by; *-*C calling the user function. Prints out the function value and; *-*C parameter values if Print Flag value is high enough.; *. void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); -*-*Compute reasonable histogram intervals; *-* ==============",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:37915,Availability,error,errors,37915,"rmally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* ================================================; *-* Find NPTU points along a contour where the function; *-* FMIN (X(KE1),X(KE2)) = AMIN+UP; *-* where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:38674,Availability,error,errors,38674,"where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-* are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; *-* only KE1CR is varied. From MNCONT, both are varied.; *-* Crossing point is at; *-* (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); -; *. void mncuve(); -*-*-*Makes sure that the current point is a local minimum; *-* ====================================================; *-* Makes sure that the current point is a local; *-* minimum and that the error matrix exists,; *-* or at least something good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transfor",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:38694,Availability,error,error,38694,"where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-* are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; *-* only KE1CR is varied. From MNCONT, both are varied.; *-* Crossing point is at; *-* (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); -; *. void mncuve(); -*-*-*Makes sure that the current point is a local minimum; *-* ====================================================; *-* Makes sure that the current point is a local; *-* minimum and that the error matrix exists,; *-* or at least something good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transfor",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:39381,Availability,error,error,39381,"mat input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-* are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; *-* only KE1CR is varied. From MNCONT, both are varied.; *-* Crossing point is at; *-* (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); -; *. void mncuve(); -*-*-*Makes sure that the current point is a local minimum; *-* ====================================================; *-* Makes sure that the current point is a local; *-* minimum and that the error matrix exists,; *-* or at least something good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transforming the user-; *-* supplied derivatives to internal coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:40440,Availability,error,error,40440,"ng good enough for MINOS and MNCONT; *. void mnderi(); Calculates the first derivatives of FCN (GRD); *-* =============================================; *-* Calculates the first derivatives of FCN (GRD),; *-* either by finite differences or by transforming the user-; *-* supplied derivatives to internal coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable paramet",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:40759,Availability,error,errors,40759,"coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); In",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:40927,Availability,error,errors,40927,"lues; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:40982,Availability,error,error,40982,"lues; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:40994,Availability,error,error,40994,"lues; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:41098,Availability,error,error,41098," *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by setting up a call to a function; -; *-* recognized MINUIT commands:; *-* obsolete commands:; *-* IERFLG is now (94.5) defined the same as ICO",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:46294,Availability,toler,toler,46294,"MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local f",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:46617,Availability,toler,tolerance,46617," to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:47556,Availability,error,error,47556,"ion STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFL",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:47632,Availability,error,error,47632,"ion STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size of most recent successful step,; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFL",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:47867,Availability,error,error,47867,"; *-* but cannot be smaller than SLAMBG.; *. void mnmatu(Int_t kode); Prints the covariance matrix v when KODE=1*-; *-* ==========================================; *-* always prints the global correlations, and; *-* calculates and prints the individual correlation coefficients; *. void mnmigr(); Performs a local function minimization*-; *-* ======================================; *-* Performs a local function minimization using basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-*",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:49057,Availability,error,error,49057,"========================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-* parses the string CRDBUF and calls MNPARM; -; *-* output conditions:; *-* ICONDN = 0 all OK; *-* ICONDN = 1 error, attempt to define parameter is ignored; *-* ICONDN = 2 end of parameter definitions; *. void mnpfit(Double_t* parx2p, Double_t* pary2p, Int_t npar2p, Double_t* coef2p, Double_t& sdev2p); To fit a parabola to npar2p points*-; *-* ==================================; *-* npar2p no. of points; *-* parx2p(i) x value of point i; *-* pary2p(i) y value of point i; -; *-* coef2p(1...3) coefficients of the fitted parabola; *-* y=coef2p(1) + coef2p(2)*x + coef2p(3)*x**2; *-* sdev2p= variance; *-* method : chi**2 = min equation solved explicitly; *. void mnpint(Double_t& pexti, Int_t i, Double_t& pinti); Calculates the internal parameter value PINTI*-; *-* =============================================; *-* corresponding to the external value PEXTI for parameter I.; *. void mnplot(Double_t* xpt, Double_t* ypt, char* chpt, Int_t nxypt, Int_t npagwd, Int_t npagln); Plots po",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:51666,Availability,error,errors,51666,"hnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; -*Provides the user with information concerning the current status; *-* ================================================================; *-* of parameter number IUEXT. Namely, it returns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated dis",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:51821,Availability,error,errors,51821,"rns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Not",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:51851,Availability,error,errors,51851,"rns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Not",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:51902,Availability,error,errors,51902,"rns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Not",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:51961,Availability,error,errors,51961,"d (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* ======================",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:51975,Availability,error,errors,51975,"d (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* ======================",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:52950,Availability,error,errors,52950,"W[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve using MNPLOT.; *-* It may be called to scan one parameter or all parameters.; *-* retains the best function and parameter values found.; *. void mnseek(); -*-*Performs a rough (but global) minimization by monte carlo search; *-* ================================================================; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:53069,Availability,error,errors,53069,"W[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve using MNPLOT.; *-* It may be called to scan one parameter or all parameters.; *-* retains the best function and parameter values found.; *. void mnseek(); -*-*Performs a rough (but global) minimization by monte carlo search; *-* ================================================================; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:57304,Availability,error,errors,57304,"====================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}. » Author: Rene Brun, Frederick James 12/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:57463,Availability,avail,available,57463,"====================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}. » Author: Rene Brun, Frederick James 12/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:436,Deployability,patch,patch,436,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:34584,Deployability,release,release,34584,"g == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined; as fixed or free. The constant parameters are not counted. Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization function*-; *-* ===============================================; *. void SetFCN(void* fcn); To set the address of the minimization function*-; *-* ===============================================; this function is called by CINT instead of the function above; *. Int_t SetPrintLevel(Int_t printLevel = 0); set Minuit print level; printlevel = -1 quiet (also suppresse all warnings); = 0 normal; = 1 verbose. void mnamin(); Initialize AMIN*-*-*-*-; *-* ===============; *-*C Called from many places. Initializes the value of AMIN by; *-*C calling the user function. Prints out the function value and; *-*C parameter values if Print Flag value is high enough.; *. void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t& bl, Double_t& bh, Int_t& nb, D",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:48599,Deployability,update,updates,48599,"ng basically the; *-* method of Davidon-Fletcher-Powell as modified by Fletcher; *-* ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; *. void mnmnos(); Performs a MINOS error analysis*-; *-* ===============================; *-* Performs a MINOS error analysis on those parameters for; *-* which it is requested on the MINOS command by calling; *-* MNMNOT for each parameter requested.; *. void mnmnot(Int_t ilax, Int_t ilax2, Double_t& val2pl, Double_t& val2mi); Performs a MINOS error analysis on one parameter*-*-*-; *-* ================================================; *-* The parameter ILAX is varied, and the minimum of the; *-* function with respect to the other parameters is followed; *-* until it crosses the value FMIN+UP.; *. void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t& ierflg); Implements one parameter definition*-*-*-; *-* ===================================; *-* Called from MNPARS and user-callable; *-* Implements one parameter definition, that is:; *-* K (external) parameter number; *-* CNAMK parameter name; *-* UK starting value; *-* WK starting step size or uncertainty; *-* A, B lower and upper physical parameter limits; *-* and sets up (updates) the parameter lists.; *-* Output: IERFLG=0 if no problems; *-* >0 if MNPARM unable to implement definition; *. void mnpars(TString& crdbuf, Int_t& icondn); Implements one parameter definition*-*-*-*-*-; *-* =========== =======================; *-* Called from MNREAD and user-callable; *-* Implements one parameter definition, that is:; *-* parses the string CRDBUF and calls MNPARM; -; *-* output conditions:; *-* ICONDN = 0 all OK; *-* ICONDN = 1 error, attempt to define parameter is ignored; *-* ICONDN = 2 end of parameter definitions; *. void mnpfit(Double_t* parx2p, Double_t* pary2p, Int_t npar2p, Double_t* coef2p, Double_t& sdev2p); To fit a parabola to npar2p points*-; *-* ==================================; *-* npar2p no. of points; *-* parx2p(i) x value",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:817,Integrability,depend,depending,817,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:2249,Integrability,depend,depend,2249,"mber functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice line",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:2474,Integrability,depend,depending,2474,"sses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does r",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:5180,Integrability,depend,depends,5180,"ameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zer",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:8685,Integrability,message,messages,8685,"liability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:9274,Integrability,message,message,9274,"are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; tha",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:10454,Integrability,depend,dependence,10454,"s; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the min",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:11406,Integrability,depend,dependence,11406," of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root o",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:32105,Integrability,rout,routine,32105,"cution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the para",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:40738,Integrability,rout,routine,40738,"coordinates,; *-* according to whether fISW[2] is zero or one.; *. void mndxdi(Double_t pint, Int_t ipar, Double_t& dxdi); -*-*Calculates the transformation factor between ext/internal values; *-* =====================================================================; *-* calculates the transformation factor between external and; *-* internal parameter values. this factor is one for; *-* parameters which are not limited. called from MNEMAT.; *. void mneig(Double_t* a, Int_t ndima, Int_t n, Int_t mits, Double_t* work, Double_t precis, Int_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); In",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:44022,Integrability,interface,interface,44022,"es one or more fixed parameter(s) to variable status*-*-; *-* ==========================================================; *-* Restores one or more fixed parameter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* ============================================; -; *-* COMD ='*' or """" prints a global help for all commands; *-* COMD =Command_name: print detailed help for one command.; *-* Note that at least 3 characters must be given for the command; *-* name.; -; *-* Author: Rene Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ================================",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:44080,Integrability,rout,routine,44080,"meter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* ============================================; -; *-* COMD ='*' or """" prints a global help for all commands; *-* COMD =Command_name: print detailed help for one command.; *-* Note that at least 3 characters must be given for the command; *-* name.; -; *-* Author: Rene Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local m",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:45714,Integrability,rout,routines,45714,"s, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMB",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:45773,Integrability,rout,routine,45773,"s, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMB",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:56745,Integrability,message,messages,56745,"* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() co",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:56823,Integrability,message,message,56823,"* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() co",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:56876,Integrability,message,message,56876,"ance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(In",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:56949,Integrability,rout,routine,56949,"achine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fO",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:56981,Integrability,message,message,56981,"achine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fO",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:57061,Integrability,message,message,57061,"d returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}. » Author: Rene Brun, Frederick James 12/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Radema",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:57175,Integrability,message,messages,57175,"Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fObjectFit=obj;}. » Author: Rene Brun, Frederick James 12/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically gener",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:652,Modifiability,variab,variables,652,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:1519,Modifiability,flexible,flexible,1519,"nt implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisq",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:1926,Modifiability,variab,variables,1926,"mber of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. F",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:2272,Modifiability,variab,variable,2272,"mber functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice line",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:2852,Modifiability,variab,variable,2852,"ed object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:4533,Modifiability,variab,variable,4533,"roduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the exis",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:5029,Modifiability,variab,variable-metric,5029,"also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:9102,Modifiability,parameteriz,parameterized,9102," there has been a problem. MINUIT, when it prints out error values,; also gives some indication of how reliable it thinks they are. For; example, those marked CURRENT GUESS ERROR are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:10407,Modifiability,parameteriz,parameterization,10407,"s; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the min",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:10692,Modifiability,parameteriz,parameterization,10692,"of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of expo",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:11782,Modifiability,variab,variables,11782,"cal inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly scaled (not all of the same order of magnitude),; and correlations are also large. In any case, whether the; non-positive-definiteness is real or only numerical is largely irrelevant,; since in both cases the error matrix will be unreliable and the minimum; suspicious. An ill-posed problem:. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical roundoff:. Be especially careful of exponential and factorial functions which get big; very quickly and lose accuracy. Starting too far from the solution:. The function may have unphysical local minima, especially at infinity in; some variables.; Minuit parameter errors in the presence of limits; This concerns the way Minuit reports the symmetric (or parabolic) errors; on parameters. It does not apply to the errors reported from Minos, which; are in general asymmetric. The symmetric errors reported by Minuit are always calculated from; the covariance matrix, assuming that this matrix has been calculated,; usually as the result of a Migrad minimization or a direct; calculation by Hesse which inverts the second derivative matrix. When there are no limits on the parameter in question, the error reported; by Minuit should therefore be exactly equal to the square root of the; corresponding diagonal element of the error matrix reported by Minuit. However, when there are limits on the parameter, there is a transformation; between the internal parameter values seen by Minuit (which are unbounded); and the external parameter values seen by the user in FCN (which remain; inside the desired l",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:26836,Modifiability,variab,variable,26836,"dInput unit; Int_tfIsyssa; Int_tfIsyswrstandard output unit; Int_tfItaur; Int_tfKe1cr; Int_tfKe2cr; Bool_tfLimsettrue if a parameter is up against limits (for MINOS); Bool_tfLnewmntrue if the previous process has unexpectedly improved FCN; Bool_tfLnolimtrue if there are no limits on any parameters (not yet used); Bool_tfLpheadtrue if a heading should be put out for the next parameter definition; Bool_tfLreportrue if exceptional conditions are put out (default=false); Bool_tfLwarntrue if warning messges are to be put out (default=true); Double_t*fMATUvline[fMaxpar] array used in mnmatu; Double_t*fMIGRflnu[fMaxpar] array used in mnmigr; Double_t*fMIGRgs[fMaxpar] array used in mnmigr; Double_t*fMIGRstep[fMaxpar] array used in mnmigr; Double_t*fMIGRvg[fMaxpar] array used in mnmigr; Double_t*fMIGRxxs[fMaxpar] array used in mnmigr; Double_t*fMNOTgcc[fMaxpar] array used in mnmnot; Double_t*fMNOTw[fMaxpar] array used in mnmnot; Double_t*fMNOTxdev[fMaxpar] array used in mnmnot; Int_tfMaxIterationsMaximum number of iterations; Int_tfMaxcpt; Int_tfMaxextMaximum number of external parameters; Int_tfMaxintMaximum number of internal parameters; Int_tfMaxparMaximum number of parameters; Int_tfMaxpar1fMaxpar*(fMaxpar+1); Int_tfMaxpar2fMaxpar*fMaxpar; Int_tfMaxpar5fMaxpar*(fMaxpar+1)/2; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; Int_tfNblockNumber of Minuit data blocks; Int_tfNewpag; Int_t*fNexofi[fMaxpar] External parameters number for currently variable parameters; Int_tfNfcnNumber of calls to FCN; Int_tfNfcnfr; Int_tfNfcnlc; Int_tfNfcnmxMaximum number of calls to FCN; Int_tfNfcwar[20]; Int_t*fNiofex[fMaxpar2] Internal parameters number, or zero if not currently variable; Int_tfNpaglnNumber of lines per page; Int_tfNpagwdPage width; Int_tfNparNumber of free parameters (total number of pars = fNpar + fNfix); Int_tfNpfixNumber of fixed parameters; Int_tfNstkrd; Int_tfNstkwr; Int_tfNu; Int_t*fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant.",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:27058,Modifiability,variab,variable,27058,"dInput unit; Int_tfIsyssa; Int_tfIsyswrstandard output unit; Int_tfItaur; Int_tfKe1cr; Int_tfKe2cr; Bool_tfLimsettrue if a parameter is up against limits (for MINOS); Bool_tfLnewmntrue if the previous process has unexpectedly improved FCN; Bool_tfLnolimtrue if there are no limits on any parameters (not yet used); Bool_tfLpheadtrue if a heading should be put out for the next parameter definition; Bool_tfLreportrue if exceptional conditions are put out (default=false); Bool_tfLwarntrue if warning messges are to be put out (default=true); Double_t*fMATUvline[fMaxpar] array used in mnmatu; Double_t*fMIGRflnu[fMaxpar] array used in mnmigr; Double_t*fMIGRgs[fMaxpar] array used in mnmigr; Double_t*fMIGRstep[fMaxpar] array used in mnmigr; Double_t*fMIGRvg[fMaxpar] array used in mnmigr; Double_t*fMIGRxxs[fMaxpar] array used in mnmigr; Double_t*fMNOTgcc[fMaxpar] array used in mnmnot; Double_t*fMNOTw[fMaxpar] array used in mnmnot; Double_t*fMNOTxdev[fMaxpar] array used in mnmnot; Int_tfMaxIterationsMaximum number of iterations; Int_tfMaxcpt; Int_tfMaxextMaximum number of external parameters; Int_tfMaxintMaximum number of internal parameters; Int_tfMaxparMaximum number of parameters; Int_tfMaxpar1fMaxpar*(fMaxpar+1); Int_tfMaxpar2fMaxpar*fMaxpar; Int_tfMaxpar5fMaxpar*(fMaxpar+1)/2; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; Int_tfNblockNumber of Minuit data blocks; Int_tfNewpag; Int_t*fNexofi[fMaxpar] External parameters number for currently variable parameters; Int_tfNfcnNumber of calls to FCN; Int_tfNfcnfr; Int_tfNfcnlc; Int_tfNfcnmxMaximum number of calls to FCN; Int_tfNfcwar[20]; Int_t*fNiofex[fMaxpar2] Internal parameters number, or zero if not currently variable; Int_tfNpaglnNumber of lines per page; Int_tfNpagwdPage width; Int_tfNparNumber of free parameters (total number of pars = fNpar + fNfix); Int_tfNpfixNumber of fixed parameters; Int_tfNstkrd; Int_tfNstkwr; Int_tfNu; Int_t*fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant.",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:31815,Modifiability,variab,variable,31815," as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:32802,Modifiability,variab,variable,32802," if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:32851,Modifiability,variab,variable,32851," if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (n < npoints); The status can be obtained via TMinuit::GetStatus(). To get the n-sigma contour the ERRDEF parameter in Minuit has to set; to n^2. The fcn function has to be set before the routine is called. The TGraph object is created via the interpreter. The user must cast it; to a TGraph*. Note that the TGraph is created with npoints+1 in order to; close the contour (setting last point equal to first point). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:36513,Modifiability,variab,variables,36513,"ble_t& bl, Double_t& bh, Int_t& nb, Double_t& bwid); -*-*Compute reasonable histogram intervals; *-* ======================================; *-* Function TO DETERMINE REASONABLE HISTOGRAM INTERVALS; *-* GIVEN ABSOLUTE UPPER AND LOWER BOUNDS A1 AND A2; *-* AND DESIRED MAXIMUM NUMBER OF BINS NAA; *-* PROGRAM MAKES REASONABLE BINNING FROM BL TO BH OF WIDTH BWID; *-* F. JAMES, AUGUST, 1974 , stolen for Minuit, 1988; *. void mncalf(Double_t* pvec, Double_t& ycalf); Transform FCN to find further minima; *-* ====================================; *-* Called only from MNIMPR. Transforms the function FCN; *-* by dividing out the quadratic part in order to find further; *-* minima. Calculates ycalf = (f-fmin)/(x-xmin)*v*(x-xmin); *. void mncler(); -*-*-*Resets the parameter list to UNDEFINED; *-* ======================================; *-* Called from MINUIT and by option from MNEXCM; *. void mncntr(Int_t ke1, Int_t ke2, Int_t& ierrf); Print function contours in two variables, on line printer; *-* =========================================================; -; *-* input arguments: parx, pary, devs, ngrid; *. void mncomd(const char* crdbin, Int_t& icondn); -*Reads a command string and executes; *-* ===================================; *-* Called by user. 'Reads' a command string and executes.; *-* Equivalent to MNEXCM except that the command is given as a; *-* character string.; -; *-* ICONDN = 0: command executed normally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* =============",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:37753,Modifiability,variab,variable,37753,"====================; -; *-* input arguments: parx, pary, devs, ngrid; *. void mncomd(const char* crdbin, Int_t& icondn); -*Reads a command string and executes; *-* ===================================; *-* Called by user. 'Reads' a command string and executes.; *-* Equivalent to MNEXCM except that the command is given as a; *-* character string.; -; *-* ICONDN = 0: command executed normally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* ================================================; *-* Find NPTU points along a contour where the function; *-* FMIN (X(KE1),X(KE2)) = AMIN+UP; *-* where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric f",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:37960,Modifiability,variab,variable,37960,"rmally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 5: command is a request to read PARAMETER definitions; *-* 6: 'SET INPUT' command; *-* 7: 'SET TITLE' command; *-* 8: 'SET COVAR' command; *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *. void mncont(Int_t ke1, Int_t ke2, Int_t nptu, Double_t* xptu, Double_t* yptu, Int_t& ierrf); Find points along a contour where FCN is minimum; *-* ================================================; *-* Find NPTU points along a contour where the function; *-* FMIN (X(KE1),X(KE2)) = AMIN+UP; *-* where FMIN is the minimum of FCN with respect to all; *-* the other NPAR-2 variable parameters (if any).; *-* IERRF on return will be equal to the number of points found:; *-* NPTU if normal termination with NPTU points found; *-* -1 if errors in the calling sequence (KE1, KE2 not variable); *-* 0 if less than four points can be found (using MNMNOT); *-* n>3 if only n points can be found (n < NPTU); -; *-* input arguments: parx, pary, devs, ngrid; *; System generated locals. void mncrck(TString crdbuf, Int_t maxcwd, TString& comand, Int_t& lnc, Int_t mxp, Double_t* plist, Int_t& llist, Int_t& ierr, Int_t isyswr); Cracks the free-format input*-; *-* ============================; *-* Cracks the free-format input, expecting zero or more; *-* alphanumeric fields (which it joins into COMAND(1:LNC)); *-* followed by one or more numeric fields separated by; *-* blanks and/or one comma. The numeric fields are put into; *-* the LLIST (but at most MXP) elements of PLIST.; *-* IERR = 0 if no errors,; *-* = 1 if error(s).; -; *; Initialized data. void mncros(Double_t& aopt, Int_t& iercr); Find point where MNEVAL=AMIN+UP*-; *-* ===============================; *-* Find point where MNEVAL=AMIN+UP, along the line through; *-* XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; *-",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:41410,Modifiability,variab,variable,41410,"t_t& ifault); Compute matrix eigen values*-; *-* ===========================; System generated locals. void mnemat(Double_t* emat, Int_t ndim); Calculates the external error matrix from the internal matrix. Note that if the matrix is declared like Double_t matrix[5][5]; in the calling program, one has to call mnemat with, eg; gMinuit->mnemat(&matrix[0][0],5);. void mnerrs(Int_t number, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& gcc); Utility routine to get MINOS errors*-; *-* ===================================; *-* Called by user.; *-* NUMBER is the parameter number; *-* values returned by MNERRS:; *-* EPLUS, EMINUS are MINOS errors of parameter NUMBER,; *-* EPARAB is 'parabolic' error (from error matrix).; *-* (Errors not calculated are set = 0); *-* GCC is global correlation coefficient from error matrix; *. void mneval(Double_t anext, Double_t& fnext, Int_t& ierev); Evaluates the function being analyzed by MNCROS*-; *-* ===============================================; *-* Evaluates the function being analyzed by MNCROS, which is; *-* generally the minimum of FCN with respect to all remaining; *-* variable parameters. The class data members contains the; *-* data necessary to know the values of U(KE1CR) and U(KE2CR); *-* to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; *-* and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; *. void mnexcm(const char* comand, Double_t* plist, Int_t llist, Int_t& ierflg); Interprets a command and takes appropriate action*-*-; *-* =================================================; *-* either directly by skipping to the corresponding code in; *-* MNEXCM, or by setting up a call to a function; -; *-* recognized MINUIT commands:; *-* obsolete commands:; *-* IERFLG is now (94.5) defined the same as ICONDN in MNCOMD; *-* = 0: command executed normally; *-* 1: command is blank, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not conver",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:43051,Modifiability,variab,variable,43051,"k, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *-* see also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for the possible list; *-* of all Minuit commands; -; *. void mnexin(Double_t* pint); -*-*Transforms the external parameter values U to internal values; *-* =============================================================; *-* Transforms the external parameter values U to internal; *-* values in the dense array PINT.; *. void mnfixp(Int_t iint, Int_t& ierr); -*-*-*-*Removes parameter IINT from the internal parameter list; *-* =======================================================; *-* and arranges the rest of the list to fill the hole.; *. void mnfree(Int_t k); Restores one or more fixed parameter(s) to variable status*-*-; *-* ==========================================================; *-* Restores one or more fixed parameter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* =======",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:43183,Modifiability,variab,variable,43183,"k, ignored; *-* 2: command line unreadable, ignored; *-* 3: unknown command, ignored; *-* 4: abnormal termination (e.g., MIGRAD not converged); *-* 9: reserved; *-* 10: END command; *-* 11: EXIT or STOP command; *-* 12: RETURN command; -; *-* see also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for the possible list; *-* of all Minuit commands; -; *. void mnexin(Double_t* pint); -*-*Transforms the external parameter values U to internal values; *-* =============================================================; *-* Transforms the external parameter values U to internal; *-* values in the dense array PINT.; *. void mnfixp(Int_t iint, Int_t& ierr); -*-*-*-*Removes parameter IINT from the internal parameter list; *-* =======================================================; *-* and arranges the rest of the list to fill the hole.; *. void mnfree(Int_t k); Restores one or more fixed parameter(s) to variable status*-*-; *-* ==========================================================; *-* Restores one or more fixed parameter(s) to variable status; *-* by inserting it into the internal parameter list at the; *-* appropriate place.; -; *-* K = 0 means restore all parameters; *-* K = 1 means restore the last parameter fixed; *-* K = -I means restore external parameter I (if possible); *-* IQ = fix-location where internal parameters were stored; *-* IR = external number of parameter being restored; *-* IS = internal number of parameter being restored; *. void mngrad(); Interprets the SET GRAD command*-*-*-; *-* ===============================; *-* Called from MNSET; *-* Interprets the SET GRAD command, which informs MINUIT whether; *-* the first derivatives of FCN will be calculated by the user; *-* inside FCN. It can check the user derivative calculation; *-* by comparing it with a finite difference approximation.; *. void mnhelp(const char* command = """"); interface to Minuit help. void mnhelp(TString comd); HELP routine for MINUIT interactive commands*-; *-* =======",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:51131,Modifiability,variab,variable,51131,"xes*-; *-* ===========================================================; *-* NXYPT is the number of points to be plotted; *-* XPT(I) = x-coord. of ith point; *-* YPT(I) = y-coord. of ith point; *-* CHPT(I) = character to be plotted at this position; *-* the input point arrays XPT, YPT, CHPT are destroyed.; -; -; *-* If fGraphicsmode is true (default), a TGraph object is produced; *-* via the Plug-in handler. To get the plot, you can do:; *-* TGraph *gr = (TGraph*)gMinuit->GetPlot();; *-* gr->Draw(""al"");; -; *. void mnpout(Int_t iuext, TString& chnam, Double_t& val, Double_t& err, Double_t& xlolim, Double_t& xuplim, Int_t& iuint) const; -*Provides the user with information concerning the current status; *-* ================================================================; *-* of parameter number IUEXT. Namely, it returns:; *-* CHNAM: the name of the parameter; *-* VAL: the current (external) value of the parameter; *-* ERR: the current estimate of the parameter uncertainty; *-* XLOLIM: the lower bound (or zero if no limits); *-* XUPLIM: the upper bound (or zero if no limits); *-* IUINT: the internal parameter number (or zero if not variable,; *-* or negative if undefined).; *-* Note also: If IUEXT is negative, then it is -internal parameter; *-* number, and IUINT is returned as the EXTERNAL number.; *-* Except for IUINT, this is exactly the inverse of MNPARM; *-* User-called; *. void mnprin(Int_t inkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:52615,Modifiability,portab,portable,52615,"m, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:55555,Modifiability,variab,variable,55555,"================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inver",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:4772,Performance,perform,perform,4772,"alue gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:4786,Performance,perform,perform,4786,"alue gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:33340,Performance,perform,performs,33340,"t). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the numb",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:56168,Performance,optimiz,optimizer,56168,"ri, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:3335,Safety,avoid,avoided,3335,"or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:10147,Safety,recover,recovers,10147,"s been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly sc",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:56138,Safety,safe,safely,56138,"ri, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:33823,Testability,log,log,33823,"tion function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined; as fixed or free. The constant parameters are not counted. Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:46008,Testability,log,logical,46008,"alculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =========================================; *-* along direction STEP, where the length of vector STEP; *-* gives the expected position of minimum.; *-* FSTART is value of function at START; *-* SLOPE (if non-zero) is df/dx along STEP at START; *-* TOLER is initial tolerance of minimum in direction STEP; -; *-* SLAMBG and ALPHA control the maximum individual steps allowed.; *-* The first step is always =1. The max length of second step is SLAMBG.; *-* The max size of subsequent steps is the maximum previous successful; *-* step multiplied by ALPHA + the size o",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:976,Usability,simpl,simply,976,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:2303,Usability,simpl,simple,2303,"sses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a multiparameter Fortran function to which one; must give the generic name FCN. In the ROOT implementation,; the function FCN is defined via the MINUIT SetFCN member function; when an Histogram.Fit command is invoked.; The value of FCN will in general depend on one; or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does r",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:45417,Usability,simpl,simplex,45417,"ne Brun; *-* comments extracted from the MINUIT documentation file.; -; *. void mnhess(); Calculates the full second-derivative matrix of FCN*-*-; *-* ===================================================; *-* by taking finite differences. When calculating diagonal; *-* elements, it may iterate so that step size is nearly that; *-* which gives function change= UP/10. The first derivatives; *-* of course come as a free side effect, but with a smaller; *-* step size in order to obtain a known accuracy.; *. void mnhes1(); Calculate first derivatives (GRD) and uncertainties (DGRD)*-*-; *-* ==========================================================; *-* and appropriate step sizes GSTEP; *-* Called from MNHESS and MNGRAD; *. void mnimpr(); Attempts to improve on a good local minimum*-*-*-; *-* ===========================================; *-* Attempts to improve on a good local minimum by finding a; *-* better one. The quadratic part of FCN is removed by MNCALF; *-* and this transformed function is minimized using the simplex; *-* method from several random starting points.; *-* ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); *. void mninex(Double_t* pint); -*Transforms from internal coordinates (PINT) to external (U); *-* ===========================================================; *-* The minimizing routines which work in; *-* internal coordinates call this routine before calling FCN.; *. void mninit(Int_t i1, Int_t i2, Int_t i3); Main initialization member function for MINUIT*-*-*-; *-* ==============================================; *-* It initializes some constants; *-* (including the logical I/O unit nos.),; *. void mnlims(); Interprets the SET LIM command, to reset the parameter limits; *-* =============================================================; *-* Called from MNSET; *. void mnline(Double_t* start, Double_t fstart, Double_t* step, Double_t slope, Double_t toler); -*-*Perform a line search from position START; *-* =======================================",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:52495,Usability,simpl,simplex,52495,"nkode, Double_t fval); Prints the values of the parameters at the time of the call*-; *-* ===========================================================; *-* also prints other relevant information such as function value,; *-* estimated distance to minimum, parameter errors, step sizes.; -; *-* According to the value of IKODE, the printout is:; *-* IKODE=INKODE= 0 only info about function value; *-* 1 parameter values, errors, limits; *-* 2 values, errors, step sizes, internal values; *-* 3 values, errors, step sizes, first derivs.; *-* 4 values, parabolic errors, MINOS errors; *-* when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for ",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:54866,Usability,simpl,simplex,54866,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit.html:55001,Usability,simpl,simplex,55001,"===========; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value. Random points are chosen; *-* uniformly over a hypercube determined by current step sizes.; *-* The Metropolis algorithm accepts a worse point with probability; *-* exp(-d/UP), where d is the degradation. Improved points; *-* are of course always accepted. Actual steps are random; *-* multiples of the nominal steps (DIRIN).; *. void mnset(); Interprets the commands that start with SET and SHOW*-*-; *-* ====================================================; *-* Called from MNEXCM; *-* file characteristics for SET INPUT; *-* 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED '; *-* explanation of print level numbers -1:3 and strategies 0:2; *-* identification of debug options; *-* things that can be set or shown; *-* options not intended for normal users; *. void mnsimp(); Minimization using the simplex method of Nelder and Mead; *-* ========================================================; *-* Performs a minimization using the simplex method of Nelder; *-* and Mead (ref. -- Comp. J. 7,308 (1965)).; *. void mnstat(Double_t& fmin, Double_t& fedm, Double_t& errdef, Int_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak",MatchSource.WIKI,root/html604/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit.html
https://root.cern/root/html604/TMinuit2TraceObject.html:1315,Availability,error,error,1315," virtual~TMinuit2TraceObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat",MatchSource.WIKI,root/html604/TMinuit2TraceObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit2TraceObject.html
https://root.cern/root/html604/TMinuit2TraceObject.html:1399,Availability,error,error,1399,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html604/TMinuit2TraceObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuit2TraceObject.html
https://root.cern/root/html604/TMinuitMinimizer.html:5507,Availability,error,errors,5507,"warn = true); TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolCheckMinuitInstance() const; boolCheckVarIndex(unsigned int ivar) const; voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs); TMinuitMinimizer(const TMinuitMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovarvector storing the covariance matrix; unsigned intfDim; vector<double>fErrorsvector of output errors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParamsvector of output values; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IMultiGenFunction*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimiza",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:5698,Availability,error,errors,5698," const double*X() const. protected:. boolCheckMinuitInstance() const; boolCheckVarIndex(unsigned int ivar) const; voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs); TMinuitMinimizer(const TMinuitMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovarvector storing the covariance matrix; unsigned intfDim; vector<double>fErrorsvector of output errors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParamsvector of output values; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IMultiGenFunction*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined M",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10451,Availability,error,errors,10451,"f an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= appro",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10659,Availability,error,errors,10659,"Limits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMino",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10710,Availability,error,error,10710,"return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:12564,Availability,error,error,12564,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Auth",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:12578,Availability,error,errors,12578,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Auth",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:12761,Availability,error,errors,12761,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Auth",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:13203,Availability,error,error,13203,"was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:13213,Availability,error,error,13213,"was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:13283,Availability,error,errors,13283,"was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:13522,Availability,error,errors,13522,"was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10400,Deployability,update,update,10400,"f an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= appro",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:11865,Deployability,release,released,11865,"of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:11898,Deployability,release,release,11898,"of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:11966,Deployability,release,release,11966,"of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:387,Integrability,interface,interface,387,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolFixVariable(unsigned int); virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual boolGetVariableSettings(unsigned int, ROOT::Fit::ParameterSettings&) const; virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; virtual boolIsFixedVariable(unsigned int) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); ROOT::Math::MinimizerROOT::Math::Minimizer::Minimizer(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDi",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:7299,Integrability,interface,interface,7299,"uit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigne",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:7643,Integrability,interface,interface,7643," type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited vari",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:7727,Integrability,interface,interface,7727,"n manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:7918,Integrability,interface,interface,7918," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVa",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:8111,Integrability,interface,interface,8111,"ion(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double )",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:460,Modifiability,plug-in,plug-in,460,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolFixVariable(unsigned int); virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual boolGetVariableSettings(unsigned int, ROOT::Fit::ParameterSettings&) const; virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; virtual boolIsFixedVariable(unsigned int) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); ROOT::Math::MinimizerROOT::Math::Minimizer::Minimizer(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDi",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:478,Modifiability,plug-in,plug-in,478,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolFixVariable(unsigned int); virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual boolGetVariableSettings(unsigned int, ROOT::Fit::ParameterSettings&) const; virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; virtual boolIsFixedVariable(unsigned int) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); ROOT::Math::MinimizerROOT::Math::Minimizer::Minimizer(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDi",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:6706,Modifiability,plug-in,plug-in,6706,"; TMinuit*fMinuit; vector<double>fParamsvector of output values; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IMultiGenFunction*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimization) and kMigradImproved (a Migrad mininimization folloed by an; improved search for global minima). The default type is Migrad (kMigrad). TMinuitMinimizer(const char* type, unsigned int ndim = 0); constructor from a char * for the algorithm type, used by the plug-in manager; The names supported (case unsensitive) are:; Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp. ~TMinuitMinimizer(); Destructor implementation. TMinuitMinimizer(const TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user v",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:8285,Modifiability,variab,variable,8285," function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(u",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:8416,Modifiability,variab,variable,8416,"by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVari",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:8554,Modifiability,variab,variable,8554,"t the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:8763,Modifiability,variab,variable,8763,"ere not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9083,Modifiability,variab,variable,9083,"unction used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable set",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9169,Modifiability,variab,variable,9169," the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the vari",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9300,Modifiability,variab,variable,9300,"ree variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using t",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9430,Modifiability,variab,variable,9430,"ted variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update inter",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9560,Modifiability,variab,variable,9560,"wer limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResul",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9709,Modifiability,variab,variable,9709,", const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveEr",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9806,Modifiability,variab,variable,9806," supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresp",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9869,Modifiability,variab,variable,9869,"value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() con",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:9931,Modifiability,variab,variable,9931," bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const;",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10038,Modifiability,variab,variable,10038,"xedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10077,Modifiability,variab,variable,10077,"xedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10150,Modifiability,variab,variable,10150,"nt , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance ma",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10217,Modifiability,variab,variable,10217,"t or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of c",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:12425,Modifiability,variab,variable,12425,"lobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Auth",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:13102,Modifiability,variab,variables,13102,"was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:13436,Modifiability,variab,variable,13436,"was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:13494,Modifiability,variab,variables,13494,"was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:10250,Performance,perform,perform,10250,"xisting variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the f",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:12784,Performance,perform,perform,12784,"eter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Minuit scan from min and max instead of 2 sigma by default); (force in that case to use errors). bool Hesse(); perform calculation of Hessian. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:11268,Safety,avoid,avoid,11268,"riable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj);",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMinuitMinimizer.html:5524,Security,validat,validated,5524,"warn = true); TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolCheckMinuitInstance() const; boolCheckVarIndex(unsigned int ivar) const; voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs); TMinuitMinimizer(const TMinuitMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovarvector storing the covariance matrix; unsigned intfDim; vector<double>fErrorsvector of output errors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParamsvector of output values; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IMultiGenFunction*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minimization; algorithm type. Supported types are : kMigrad, kSimplex, kCombined (a combined; Migrad + Simplex minimiza",MatchSource.WIKI,root/html604/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMinuitMinimizer.html
https://root.cern/root/html604/TMixture.html:1377,Availability,error,error,1377,"l~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjec",MatchSource.WIKI,root/html604/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMixture.html
https://root.cern/root/html604/TMixture.html:1461,Availability,error,error,1461,"ject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tTMaterial::GetR",MatchSource.WIKI,root/html604/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMixture.html
https://root.cern/root/html604/TMixture.html:298,Safety,detect,detector,298,". TMixture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMixture. class TMixture: public TMaterial. Manages a detector mixture. See class TGeometry. Function Members (Methods); public:. virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTA",MatchSource.WIKI,root/html604/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMixture.html
https://root.cern/root/html604/TMLPAnalyzer.html:1876,Availability,error,error,1876,"e = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Boo",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:1960,Availability,error,error,1960,"TObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inheri",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:8953,Deployability,continuous,continuous,8953,"sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfi",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:9421,Deployability,continuous,continuous,9421," the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerce",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:433,Modifiability,variab,variables,433,". TMLPAnalyzer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMLPAnalyzer. class TMLPAnalyzer: public TObject. TMLPAnalyzer. This utility class contains a set of tests usefull when developing; a neural network.; It allows you to check for unneeded variables, and to control; the network structure. Function Members (Methods); public:. virtual~TMLPAnalyzer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckNetwork(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:6685,Modifiability,layers,layers,6685,idTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TTree*fAnalysisTree; TTree*fIOTree; TMultiLayerPerceptron*fNetwork. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the,MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:8028,Modifiability,variab,variable,8028,"s some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:8324,Performance,optimiz,optimizing,8324," analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each outpu",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:8107,Safety,risk,risk,8107,"s some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:347,Testability,test,tests,347,". TMLPAnalyzer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMLPAnalyzer. class TMLPAnalyzer: public TObject. TMLPAnalyzer. This utility class contains a set of tests usefull when developing; a neural network.; It allows you to check for unneeded variables, and to control; the network structure. Function Members (Methods); public:. virtual~TMLPAnalyzer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckNetwork(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:7388,Testability,test,test,7388,"atic TObject::(anonymous)TObject::kZombie. private:. TTree*fAnalysisTree; TTree*fIOTree; TMultiLayerPerceptron*fNetwork. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:7529,Testability,test,test,7529,"nce; Inherited Members; Includes; Libraries. Function documentation; ~TMLPAnalyzer(); Destructor. Int_t GetLayers(); Returns the number of layers. Int_t GetNeurons(Int_t layer); Returns the number of neurons in given layer. TString GetNeuronFormula(Int_t idx); Returns the formula used as input for neuron (idx) in; the first layer. const char* GetInputNeuronTitle(Int_t in); Returns the name of any neuron from the input layer. const char* GetOutputNeuronTitle(Int_t out); Returns the name of any neuron from the output layer. void CheckNetwork(); Gives some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:8589,Testability,test,test,8589,"ation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProf",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:8830,Testability,test,test,8830,". That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP o",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:9299,Testability,test,test,9299,"you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The ret",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:9810,Testability,test,test,9810,"fference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For co",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:10188,Testability,test,test,10188,"outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus the; true value of outnode vs the input value, stacked for all inputs, for; all test data events.; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TMLPAnalyzer(TMultiLayerPerceptron& net); {}. TMLPAnalyzer(TMultiLayerPerceptron* net); {}. TTree* GetIOTree() const; { return fIOTree;}. » Author: Christophe.Delaere@cern.ch 25/04/04 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TMLPAnalyzer.html:8002,Usability,learn,learn,8002,"s some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html604/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMLPAnalyzer.html
https://root.cern/root/html604/TModuleDocInfo.html:1977,Availability,error,error,1977," virtual~TModuleDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual void",MatchSource.WIKI,root/html604/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TModuleDocInfo.html
https://root.cern/root/html604/TModuleDocInfo.html:2061,Availability,error,error,2061,"char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; vi",MatchSource.WIKI,root/html604/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TModuleDocInfo.html
https://root.cern/root/html604/TMonitor.html:3983,Availability,error,error,3983," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:4067,Availability,error,error,4067,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTi",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11272,Availability,mask,mask,11272,"ll signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to s",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12193,Availability,error,error,12193,"write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12583,Availability,error,error,12583," readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send som",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12814,Availability,error,error,12814,"ivated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check i",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:321,Energy Efficiency,monitor,monitors,321,". TMonitor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TMonitor. class TMonitor: public TObject, public TQObject. TMonitor. This class monitors activity on a number of network sockets.; The actual monitoring is done by TSystem::DispatchOneEvent().; Typical usage: create a TMonitor object. Register a number of; TSocket objects and call TMonitor::Select(). Select() returns the; socket object which has data waiting. TSocket objects can be added,; removed, (temporary) enabled or disabled. Function Members (Methods); public:. virtual~TMonitor(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(TSocket* sock); virtual voidActivateAll(); virtual voidAdd(TSocket* sock, Int_t interest = kRead); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:383,Energy Efficiency,monitor,monitoring,383,". TMonitor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TMonitor. class TMonitor: public TObject, public TQObject. TMonitor. This class monitors activity on a number of network sockets.; The actual monitoring is done by TSystem::DispatchOneEvent().; Typical usage: create a TMonitor object. Register a number of; TSocket objects and call TMonitor::Select(). Select() returns the; socket object which has data waiting. TSocket objects can be added,; removed, (temporary) enabled or disabled. Function Members (Methods); public:. virtual~TMonitor(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(TSocket* sock); virtual voidActivateAll(); virtual voidAdd(TSocket* sock, Int_t interest = kRead); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:10307,Energy Efficiency,monitor,monitor,10307,"c TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMonitor::EInterestkRead; static TObject::(anonymous)TObject::kSingleKey; static TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to mo",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:10438,Energy Efficiency,monitor,monitoring,10438,"c TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMonitor::EInterestkRead; static TObject::(anonymous)TObject::kSingleKey; static TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to mo",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:10679,Energy Efficiency,monitor,monitor,10679,"static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMonitor::EInterestkRead; static TObject::(anonymous)TObject::kSingleKey; static TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. voi",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:10719,Energy Efficiency,monitor,monitoring,10719,"Object::kOverwrite; static TMonitor::EInterestkRead; static TObject::(anonymous)TObject::kSingleKey; static TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:10840,Energy Efficiency,monitor,monitor,10840,"tic TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivat",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:10886,Energy Efficiency,monitor,monitored,10886,"ject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. v",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:10964,Energy Efficiency,monitor,monitor,10964,")TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket *",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11022,Energy Efficiency,monitor,monitor,11022,"rom this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handl",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11089,Energy Efficiency,monitor,monitor,11089,"rom this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handl",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11163,Energy Efficiency,monitor,monitor,11163,"rom this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handl",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11407,Energy Efficiency,monitor,monitor,11407," loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11474,Energy Efficiency,monitor,monitor,11474," loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11548,Energy Efficiency,monitor,monitor,11548," loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11640,Energy Efficiency,monitor,monitor,11640,"on documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TLis",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:11695,Energy Efficiency,monitor,monitor,11695,"e a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:14127,Energy Efficiency,monitor,monitor,14127,"kets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:14353,Energy Efficiency,monitor,monitor,14353,"kets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:13083,Integrability,rout,routine,13083," with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:4367,Safety,timeout,timeout,4367," param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:7320,Safety,timeout,timeout,7320,"idTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonitor&operator=(const TMonitor&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject:",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:7381,Safety,timeout,timeout,7381,"delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMonitor&operator=(const TMonitor&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize ",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12224,Safety,timeout,timeout,12224,"rest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) con",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12309,Safety,timeout,timeout,12309,"the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, r",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12352,Safety,timeout,timeout,12352," add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12652,Safety,timeout,timeout,12652,"l(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:12746,Safety,timeout,timeout,12746,"e-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:13227,Safety,timeout,timeout,13227,"r to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:13296,Safety,timeout,timeout,13296,"e to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used b",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:13383,Safety,timeout,timeout,13383,"e to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used b",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:13406,Safety,timeout,timeout,13406," (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * Ge",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMonitor.html:13600,Safety,timeout,timeout,13600," wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * GetSender(); { return this; }. void Interrupt(); { fInterrupt = kTRUE; }. void ResetInterrupt(); { fInterrupt = kFALSE; }. » Author: Fons Rademakers 09/01/97 » Copyright (C) 1995-2000, Rene Brun and F",MatchSource.WIKI,root/html604/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMonitor.html
https://root.cern/root/html604/TMultiDimFit.html:1099,Availability,reliab,reliably,1099,"earch. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*; >; ; Multidimensional Fits in ROOT. Overview; . A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable.; ; An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:1827,Availability,error,errors,1827,"y consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So wh",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:2548,Availability,error,error,2548,"This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:3128,Availability,error,error,3128," more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polyn",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:9613,Availability,error,errors,9613,"since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12158,Availability,error,error,12158,"Principal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12305,Availability,error,error,12305,"endent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computi",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:14809,Availability,error,error,14809,"e_t E = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """")MENU ; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* = ""d""); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(const Double_t* x, const Double_t* coeff = 0) const; virtual Double_tEvalError(const Double_t* x, const Double_t* coeff = 0) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindParameterization(Option_t* option = """")MENU ; virtual voidFit(Option_t* option = """")MENU ; Double_tGetChi2() const; const TVectorD*GetCoefficients() const; const TVectorD*GetCoefficientsRMS() const; const TMatrixD*GetCorrelationMatrix() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetError() const; Int_t*GetFunctionCodes() const; const TMatrixD*GetFunctions() const; virtual TList*GetHistograms() const; virtual const char*TObject::GetIconName() const; Double_tGetMaxAngle() const; Int_tGetMaxFunctions() const; Int_t*Ge",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:14893,Availability,error,error,14893,"e(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """")MENU ; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* = ""d""); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(const Double_t* x, const Double_t* coeff = 0) const; virtual Double_tEvalError(const Double_t* x, const Double_t* coeff = 0) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindParameterization(Option_t* option = """")MENU ; virtual voidFit(Option_t* option = """")MENU ; Double_tGetChi2() const; const TVectorD*GetCoefficients() const; const TVectorD*GetCoefficientsRMS() const; const TMatrixD*GetCorrelationMatrix() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetError() const; Int_t*GetFunctionCodes() const; const TMatrixD*GetFunctions() const; virtual TList*GetHistograms() const; virtual const char*TObject::GetIconName() const; Double_tGetMaxAngle() const; Int_tGetMaxFunctions() const; Int_t*GetMaxPowers() const; Double_tGetMaxQuantity() const; Int_tGetMaxStudy() const; Int_tG",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:19722,Availability,error,error,19722,"; virtual Double_tMakeChi2(const Double_t* coeff = 0); virtual voidMakeCode(const char* functionName = ""MDF"", Option_t* option = """")MENU ; virtual voidMakeHistograms(Option_t* option = ""A"")MENU ; virtual voidMakeMethod(const Char_t* className = ""MDF"", Option_t* option = """")MENU ; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 0.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23975,Availability,error,error,23975,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25070,Availability,error,error,25070,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26436,Availability,error,error,26436,"VectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrow",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26718,Availability,error,error,26718," Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26779,Availability,error,error,26779," Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27044,Availability,error,error,27044,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27233,Availability,error,error,27233," Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameter",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27294,Availability,error,error,27294," Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameter",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27840,Availability,error,error,27840,"value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); C",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:29735,Availability,error,errors,29735,"on. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <filename> with .C appended if argument doesn't; end in .cxx or .C. The contains the implementation of the; function:. Double_t <funcname>(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the static variables:. Int_t gNVariables; Int_t gNCoefficients; Double_t gDMean; Double_t gXMean[]; Double_t gXMin[]; Double_t gXMax[]; Double_t gCoefficient[]; Int_t gPower[]. are initialized. The only ROOT header file needed is Rtypes.h. See TMultiDimFit::MakeRealCode for a list of options. void MakeCoefficientErrors(); PRIVATE METHOD:; Compute the errors on the coefficients. For this to be done, the; curvature matrix of the non-orthogonal functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:35099,Availability,error,error,35099," See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. Double_t GetMaxAngle() const; { return fMaxAngle; }. Int_t GetMaxFunctions() const; { return fMaxFunctions; }. Int_t* GetMaxPowers() const; { return fMa",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:35135,Availability,error,error,35135," See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. Double_t GetMaxAngle() const; { return fMaxAngle; }. Int_t GetMaxFunctions() const; { return fMaxFunctions; }. Int_t* GetMaxPowers() const; { return fMa",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:550,Energy Efficiency,energy,energy,550,". TMultiDimFit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*; >; ; Multidimensional Fits in ROOT. Overview; . A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable.; ; An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; paramet",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:605,Energy Efficiency,charge,charged,605,". TMultiDimFit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*; >; ; Multidimensional Fits in ROOT. Overview; . A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable.; ; An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; paramet",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:3291,Energy Efficiency,power,powers,3291,"est, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; Ther",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:3904,Energy Efficiency,power,power,3904,"s) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly redu",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4050,Energy Efficiency,power,power,4050,"the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-poin",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4169,Energy Efficiency,power,power,4169,"ionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4191,Energy Efficiency,power,power,4191,"ionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4457,Energy Efficiency,power,power,4457,"dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4571,Energy Efficiency,power,power,4571,"ble to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample a",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4754,Energy Efficiency,reduce,reduce,4754,"owever, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; o",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4851,Energy Efficiency,reduce,reduce,4851,"owever, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; o",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:8827,Energy Efficiency,reduce,reduced,8827,"ction of , if the angle; ; between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle); ; However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction).; ; In case isn't defined, an alternative method of; performing this second test is used: The ; function; ; is accepted if (refer also to equation (13)); . (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user).; ; >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting.; ; The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting; ; as shown below.; . Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as; . (15). where; . (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate; . (17). The model ; can therefore be written as; . The original model ; is therefore identical with; this if; . (18). The reason we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12577,Energy Efficiency,reduce,reduced,12577,"onent; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H. Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981.; . */. Function Members (Methods); public:. virtual~TMultiDimFit",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12696,Energy Efficiency,reduce,reduced,12696,"onent; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H. Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981.; . */. Function Members (Methods); public:. virtual~TMultiDimFit",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:19587,Energy Efficiency,power,powers,19587,"; virtual Double_tMakeChi2(const Double_t* coeff = 0); virtual voidMakeCode(const char* functionName = ""MDF"", Option_t* option = """")MENU ; virtual voidMakeHistograms(Option_t* option = ""A"")MENU ; virtual voidMakeMethod(const Char_t* className = ""MDF"", Option_t* option = """")MENU ; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 0.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:19979,Energy Efficiency,power,powers,19979,"(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 0.001); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiDimFit(); TMultiDimFit(const TMultiDimFit&); TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tEvalControl(const Int_t* powers) const; virtual Double_tEvalFactor(Int_t p, Double_t x) const; virtual voidMakeCandidates(); virtual voidMakeCoefficientErrors(); virtual voidMakeCoefficients(); virtual voidMakeCorrelation(); virtual Double_tMakeGramSchmidt(Int_t function); virtual voidMakeNormalized(); virtual voidMakeParameterization(); virtual voidMakeRealCode(const char* filename, const ch",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:21047,Energy Efficiency,power,powers,21047,"(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMultiDimFit(); TMultiDimFit(const TMultiDimFit&); TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tEvalControl(const Int_t* powers) const; virtual Double_tEvalFactor(Int_t p, Double_t x) const; virtual voidMakeCandidates(); virtual voidMakeCoefficientErrors(); virtual voidMakeCoefficients(); virtual voidMakeCorrelation(); virtual Double_tMakeGramSchmidt(Int_t function); virtual voidMakeNormalized(); virtual voidMakeParameterization(); virtual voidMakeRealCode(const char* filename, const char* classname, Option_t* option = """"); voidTObject::MakeZombie(); virtual Bool_tSelect(const Int_t* iv); virtual Bool_tTestFunction(Double_t squareResidual, Double_t dResidur). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TMultiDimFit::EMDFPolyTypekChebyshev; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TMultiDimFit::EMDFPolyTypekLegendre; static TMultiDimFit::EMDFPolyTypekMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TO",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23370,Energy Efficiency,power,powers,23370,kMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23421,Energy Efficiency,power,powers,23421,kMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:24643,Energy Efficiency,power,powers,24643,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:28002,Energy Efficiency,power,powers,28002,"lly, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:28082,Energy Efficiency,power,powers,28082,"lly, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:28178,Energy Efficiency,power,power,28178," This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:32455,Energy Efficiency,power,powers,32455,"method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <classname>.h and assumed to be provided by the; user. See TMultiDimFit::MakeRealCode for a list of options. The minimal class definition is:. class <classname> {; public:; Int_t <classname>::fgNVariables; // Number of variables; Int_t <classname>::fgNCoefficients; // Number of terms; Double_t <classname>::fgDMean; // Mean from training sample; Double_t <classname>::fgXMean[]; // Mean from training sample; Double_t <classname>::fgXMin[]; // Min from training sample; Double_t <classname>::fgXMax[]; // Max from training sample; Double_t <classname>::fgCoefficient[]; // Coefficients; Int_t <classname>::fgPower[]; // Function powers. Double_t Eval(Double_t *x);; };. Whether the method <classname>::Eval should be static or not, is; up to the user. void MakeNormalized(); PRIVATE METHOD:; Normalize data to the interval [-1;1]. This is needed for the; classes method to work. void MakeParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""p",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:33661,Energy Efficiency,power,powers,33661,"lize data to the interval [-1;1]. This is needed for the; classes method to work. void MakeParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""ps"") const; Print statistics etc.; Options are; P Parameters; S Statistics; C Coefficients; R Result of parameterisation; F Result of fit; K Correlation Matrix; M Pretty print formula. Bool_t Select(const Int_t* iv); Selection method. User can override this method for specialized; selection of acceptable functions in fit. Default is to select; all. This message is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For example, to De select the function; f = x1^2 * x2^4 * x3^5,; this method should return kFALSE if given the argument; { 3, 4, 6 }. void SetMaxAngle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vector to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels t",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:33728,Energy Efficiency,power,powers,33728,"eParameterization(); PRIVATE METHOD:; Find the parameterization over the training sample. A full account; of the algorithm is given in the; class description. void MakeRealCode(const char* filename, const char* classname, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; evaluation the parameterization on some point.; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod. The options are: NONE so far. void Print(Option_t* option = ""ps"") const; Print statistics etc.; Options are; P Parameters; S Statistics; C Coefficients; R Result of parameterisation; F Result of fit; K Correlation Matrix; M Pretty print formula. Bool_t Select(const Int_t* iv); Selection method. User can override this method for specialized; selection of acceptable functions in fit. Default is to select; all. This message is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For example, to De select the function; f = x1^2 * x2^4 * x3^5,; this method should return kFALSE if given the argument; { 3, 4, 6 }. void SetMaxAngle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vector to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. voi",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:34385,Energy Efficiency,power,powers,34385,"mula. Bool_t Select(const Int_t* iv); Selection method. User can override this method for specialized; selection of acceptable functions in fit. Default is to select; all. This message is sent during the build-up of the function; candidates table once for each set of powers in; variables. Notice, that the argument array contains the powers; PLUS ONE. For example, to De select the function; f = x1^2 * x2^4 * x3^5,; this method should return kFALSE if given the argument; { 3, 4, 6 }. void SetMaxAngle(Double_t angle = 0); Set the max angle (in degrees) between the initial data vector to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contribute",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:34957,Energy Efficiency,power,powers,34957," to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:34982,Energy Efficiency,power,power,34982," to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:956,Integrability,depend,dependent,956,". TMultiDimFit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*; >; ; Multidimensional Fits in ROOT. Overview; . A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable.; ; An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; paramet",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:1126,Integrability,depend,dependence,1126,"earch. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*; >; ; Multidimensional Fits in ROOT. Overview; . A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable.; ; An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:1335,Integrability,depend,dependent,1335,"s TMultiDimFit: public TNamed. /*; >; ; Multidimensional Fits in ROOT. Overview; . A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable.; ; An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory.; ; The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations.; ; This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the de",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:2263,Integrability,depend,dependent,2263," data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:2301,Integrability,depend,depends,2301," data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables.; ; This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:2512,Integrability,depend,dependent,2512,"This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit.; ; In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information.; ; And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C.; . The Method; . Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by; ; . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow); . where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization; . (1). such that; . (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; .; ; So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:4106,Integrability,depend,dependent,4106,"the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-poin",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:6030,Integrability,depend,dependent,6030," to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; of which the columns ; are given by; . (4). (5). and ; is the component of ; orthogonal; to ; . Hence we obtain; [3],; .    if. (6). We now take as a new model ; . We thus want to; minimize; . (7). where ; is a vector of the; dependent quantity in the sample. Differentiation with respect to; gives, using (6),; . (8). or; . (9). Let be the sum of squares of residuals when taking functions; into account. Then; . (10). Using (9), we see that; .  ;  .  ;  . (11). So for each new function included in the model, we get a; reduction of the sum of squares of residuals of ; ,; where ; is given by (4) and by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion.; . Function Selection Based on Residual; . Supposing that steps of the procedure have been performed, the; problem now is to consider the ; function.; ; The sum of squares of residuals can be written as; . (12). where the relation (9) have been taken into account. The; contribution of the ; function to the reduction of S, is; given by; . (13). Two test are now applied to decide whether this . function is to be included in the final expression, or not.; . Test 1; ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10490,Integrability,depend,dependence,10490," we use ; rather then; ; is to save storage, since; ; can be stored in the same matrix as; . (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, usin",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:10660,Integrability,depend,dependent,10660," curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors).; . Considerations; . It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:12119,Integrability,depend,dependent,12119,"Principal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:22577,Integrability,depend,dependent,22577,kMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23472,Integrability,depend,dependent,23472,kMonomials; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23751,Integrability,depend,dependent,23751,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:23917,Integrability,depend,dependent,23917,,MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:24842,Integrability,depend,dependent,24842,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25180,Integrability,depend,dependent,25180,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:25426,Integrability,depend,dependent,25426,"x value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; TVectorDfMinVariablesmin value of independent variables; Int_tfNCoefficientsDimension of model coefficients; Int_tfNVariablesNumber of independent variables; TStringTNamed::fNameobject identifier; TVectorDfOrthCoefficientsThe model coefficients; TMatrixDfOrthCurvatureMatrixModel matrix; TVectorDfOrthFunctionNormsNorm of the evaluated functions; TMatrixDfOrthFunctionsAs above, but orthogonalised; Int_tfParameterisationCodeExit code of parameterisation; TMultiDimFit::EMDFPolyTypefPolyTypeType of polynomials to use; Int_t*fPowerIndex[fMaxTerms] Index of accepted powers; Double_tfPowerLimitControl parameter; Int_t*fPowers[fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables; Double_tfPrecisionRelative precision of param; TVectorDfQuantityTraining sample, dependent quantity; Double_tfRMSRoot mean square of fit; TVectorDfResidualsVector of the final residuals; Int_tfSampleSizeSize of training sample; Bool_tfShowCorrelationprint correlation matrix; TVectorDfSqErrorTraining sample, error in quantity; Double_tfSumSqAvgQuantitySum of squares away from mean; Double_tfSumSqQuantitySumSquare of dependent quantity; Double_tfSumSqResidualSum of Square residuals; Double_tfTestCorrelationCoeffMulti Correlation coefficient; Double_tfTestErrorError from test; Double_tfTestPrecisionRelative precision of test; TVectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables.",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26389,Integrability,depend,dependent,26389,"VectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrow",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26450,Integrability,depend,dependent,26450,"VectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrow",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26808,Integrability,depend,dependent,26808," Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:26997,Integrability,depend,dependent,26997,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27058,Integrability,depend,dependent,27058,"ent is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* po",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:27323,Integrability,depend,dependent,27323," Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameter",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30559,Integrability,message,message,30559,"ed is Rtypes.h. See TMultiDimFit::MakeRealCode for a list of options. void MakeCoefficientErrors(); PRIVATE METHOD:; Compute the errors on the coefficients. For this to be done, the; curvature matrix of the non-orthogonal functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30732,Integrability,depend,dependent,30732,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30799,Integrability,depend,dependent,30799,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
https://root.cern/root/html604/TMultiDimFit.html:30894,Integrability,depend,dependent,30894,"l functions, is computed. void MakeCoefficients(); PRIVATE METHOD:; Invert the model matrix B, and compute final coefficients. For a; more thorough discussion of what this means, please refer to the; class description. First we invert the lower triangle matrix fOrthCurvatureMatrix; and store the inverted matrix in the upper triangle. void MakeCorrelation(); PRIVATE METHOD:; Compute the correlation matrix. Double_t MakeGramSchmidt(Int_t function); PRIVATE METHOD:; Make Gram-Schmidt orthogonalisation. The class description gives; a thorough account of this algorithm, as well as; references. Please refer to the; class description. void MakeHistograms(Option_t* option = ""A""); Make histograms of the result of the analysis. This message; should be sent after having read all data points, but before; finding the parameterization. Options:; A All the below; X Original independent variables; D Original dependent variables; N Normalised independent variables; S Shifted dependent variables; R1 Residuals versus normalised independent variables; R2 Residuals versus dependent variable; R3 Residuals computed on training sample; R4 Residuals computed on test sample. For a description of these quantities, refer to; class description. void MakeMethod(const Char_t* className = ""MDF"", Option_t* option = """"); Generate the file <classname>MDF.cxx which contains the; implementation of the method:. Double_t <classname>::MDF(Double_t *x). which does the same as TMultiDimFit::Eval. Please refer to this; method. Further, the public static members:. Int_t <classname>::fgNVariables; Int_t <classname>::fgNCoefficients; Double_t <classname>::fgDMean; Double_t <classname>::fgXMean[] //[fgNVariables]; Double_t <classname>::fgXMin[] //[fgNVariables]; Double_t <classname>::fgXMax[] //[fgNVariables]; Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]. are initialized, and assumed to exist. The class declaration is; assumed to be in <",MatchSource.WIKI,root/html604/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMultiDimFit.html
