id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha-1.html:183,Testability,log,logarithmic,183,"﻿. DFT_PRUNING_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha.html:432,Deployability,update,updated,432,"﻿. DFT_PRUNING_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha.html:183,Testability,log,logarithmic,183,"﻿. DFT_PRUNING_ALPHA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. DFT_PRUNING_ALPHA¶. Spread alpha for logarithmic pruning. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_ALPHA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_alpha.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_scheme-1.html:662,Deployability,update,updated,662,"﻿. DFT_PRUNING_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_SCHEME. DFT_PRUNING_SCHEME¶. Select approach for pruning. Options ROBUST and TREUTLER prune based on regions (proximity to nucleus) while FLAT P_GAUSSIAN D_GAUSSIAN P_SLATER D_SLATER LOG_GAUSSIAN LOG_SLATER prune based on decaying functions (experts only!). The recommended scheme is ROBUST. Type: string; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_SCHEME. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_scheme-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_scheme-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_scheme.html:662,Deployability,update,updated,662,"﻿. DFT_PRUNING_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_SCHEME. DFT_PRUNING_SCHEME¶. Select approach for pruning. Options ROBUST and TREUTLER prune based on regions (proximity to nucleus) while FLAT P_GAUSSIAN D_GAUSSIAN P_SLATER D_SLATER LOG_GAUSSIAN LOG_SLATER prune based on decaying functions (experts only!). The recommended scheme is ROBUST. Type: string; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_PRUNING_SCHEME. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_pruning_scheme.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_points-1.html:419,Deployability,update,updated,419,"﻿. DFT_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_POINTS. DFT_RADIAL_POINTS¶. Number of radial points. Type: integer; Default: 75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_radial_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_points.html:419,Deployability,update,updated,419,"﻿. DFT_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_POINTS. DFT_RADIAL_POINTS¶. Number of radial points. Type: integer; Default: 75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_scheme-1.html:468,Deployability,update,updated,468,"﻿. DFT_RADIAL_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_SCHEME. DFT_RADIAL_SCHEME¶. Radial Scheme. Type: string; Possible Values: TREUTLER, BECKE, MULTIEXP, EM, MURA; Default: TREUTLER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_SCHEME. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_radial_scheme-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_scheme-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_scheme.html:468,Deployability,update,updated,468,"﻿. DFT_RADIAL_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_SCHEME. DFT_RADIAL_SCHEME¶. Radial Scheme. Type: string; Possible Values: TREUTLER, BECKE, MULTIEXP, EM, MURA; Default: TREUTLER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_RADIAL_SCHEME. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_radial_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_radial_scheme.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_points-1.html:461,Deployability,update,updated,461,"﻿. DFT_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_POINTS. DFT_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number). Type: integer; Default: 302. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_points.html:461,Deployability,update,updated,461,"﻿. DFT_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_POINTS. DFT_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number). Type: integer; Default: 302. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_scheme-1.html:454,Deployability,update,updated,454,"﻿. DFT_SPHERICAL_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_SCHEME. DFT_SPHERICAL_SCHEME¶. Spherical Scheme. Type: string; Possible Values: LEBEDEV; Default: LEBEDEV. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_SCHEME. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_scheme-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_scheme-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_scheme.html:454,Deployability,update,updated,454,"﻿. DFT_SPHERICAL_SCHEME. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_SCHEME. DFT_SPHERICAL_SCHEME¶. Spherical Scheme. Type: string; Possible Values: LEBEDEV; Default: LEBEDEV. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_SPHERICAL_SCHEME. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_scheme.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_spherical_scheme.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_v2_rho_cutoff-1.html:441,Deployability,update,updated,441,"﻿. DFT_V2_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. DFT_V2_RHO_CUTOFF¶. Minima rho cutoff for the second derivative. Type: double; Default: 1.e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_v2_rho_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_v2_rho_cutoff-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_v2_rho_cutoff.html:441,Deployability,update,updated,441,"﻿. DFT_V2_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. DFT_V2_RHO_CUTOFF¶. Minima rho cutoff for the second derivative. Type: double; Default: 1.e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_V2_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_v2_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_v2_rho_cutoff.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_b-1.html:391,Deployability,update,updated,391,"﻿. DFT_VV10_B. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_B. DFT_VV10_B¶. Define VV10 parameter b. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_B. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_b-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_b-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_b.html:391,Deployability,update,updated,391,"﻿. DFT_VV10_B. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_B. DFT_VV10_B¶. Define VV10 parameter b. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_B. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_b.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_b.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_c-1.html:391,Deployability,update,updated,391,"﻿. DFT_VV10_C. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_C. DFT_VV10_C¶. Define VV10 parameter C. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_C. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_c-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_c.html:391,Deployability,update,updated,391,"﻿. DFT_VV10_C. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_C. DFT_VV10_C¶. Define VV10 parameter C. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_C. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_c.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_postscf-1.html:419,Deployability,update,updated,419,"﻿. DFT_VV10_POSTSCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_POSTSCF. DFT_VV10_POSTSCF¶. post-scf VV10 correction. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_POSTSCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_postscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_postscf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_postscf.html:419,Deployability,update,updated,419,"﻿. DFT_VV10_POSTSCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_POSTSCF. DFT_VV10_POSTSCF¶. post-scf VV10 correction. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_POSTSCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_postscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_postscf.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html:217,Deployability,integrat,integration,217,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html:463,Deployability,update,updated,463,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html:217,Integrability,integrat,integration,217,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html:217,Deployability,integrat,integration,217,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html:463,Deployability,update,updated,463,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html:217,Integrability,integrat,integration,217,"﻿. DFT_VV10_RADIAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. DFT_VV10_RADIAL_POINTS¶. Number of radial points for VV10 NL integration. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RADIAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_radial_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html:195,Deployability,integrat,integration,195,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html:440,Deployability,update,updated,440,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html:195,Integrability,integrat,integration,195,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html:195,Deployability,integrat,integration,195,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html:440,Deployability,update,updated,440,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html:195,Integrability,integrat,integration,195,"﻿. DFT_VV10_RHO_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. DFT_VV10_RHO_CUTOFF¶. Rho cutoff for VV10 NL integration. Type: double; Default: 1.e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_RHO_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_rho_cutoff.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html:255,Deployability,integrat,integration,255,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html:505,Deployability,update,updated,505,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html:255,Integrability,integrat,integration,255,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html:255,Deployability,integrat,integration,255,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html:505,Deployability,update,updated,505,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html:255,Integrability,integrat,integration,255,"﻿. DFT_VV10_SPHERICAL_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. DFT_VV10_SPHERICAL_POINTS¶. Number of spherical points (A Lebedev Points number) for VV10 NL integration. Type: integer; Default: 146. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_VV10_SPHERICAL_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_vv10_spherical_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_weights_tolerance-1.html:458,Deployability,update,updated,458,"﻿. DFT_WEIGHTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_WEIGHTS_TOLERANCE. DFT_WEIGHTS_TOLERANCE¶. grid weight cutoff. Disable with -1.0. Type: conv double; Default: 1.0e-15. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_WEIGHTS_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_weights_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_weights_tolerance-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_weights_tolerance.html:458,Deployability,update,updated,458,"﻿. DFT_WEIGHTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_WEIGHTS_TOLERANCE. DFT_WEIGHTS_TOLERANCE¶. grid weight cutoff. Disable with -1.0. Type: conv double; Default: 1.0e-15. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DFT_WEIGHTS_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__dft_weights_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__dft_weights_tolerance.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_guess-1.html:646,Deployability,update,updated,646,"﻿. DF_BASIS_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_GUESS. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_basis_guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_guess-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_guess.html:646,Deployability,update,updated,646,"﻿. DF_BASIS_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_GUESS. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_basis_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_guess.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_sad-1.html:444,Deployability,update,updated,444,"﻿. DF_BASIS_SAD. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SAD. DF_BASIS_SAD¶. Density fitting basis used in SAD. Type: string; Possible Values: basis string; Default: SAD-FIT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SAD. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_basis_sad-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_sad-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_sad.html:444,Deployability,update,updated,444,"﻿. DF_BASIS_SAD. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SAD. DF_BASIS_SAD¶. Density fitting basis used in SAD. Type: string; Possible Values: basis string; Default: SAD-FIT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SAD. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_basis_sad.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_sad.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_scf-1.html:497,Deployability,update,updated,497,"﻿. DF_BASIS_SCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SCF. DF_BASIS_SCF¶. Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_basis_scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_scf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_scf.html:497,Deployability,update,updated,497,"﻿. DF_BASIS_SCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SCF. DF_BASIS_SCF¶. Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BASIS_SCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_basis_scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_basis_scf.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r0-1.html:392,Deployability,update,updated,392,"﻿. DF_BUMP_R0. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R0. DF_BUMP_R0¶. Bump function min radius. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R0. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_bump_r0-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r0-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r0.html:392,Deployability,update,updated,392,"﻿. DF_BUMP_R0. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R0. DF_BUMP_R0¶. Bump function min radius. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R0. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_bump_r0.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r0.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r1-1.html:392,Deployability,update,updated,392,"﻿. DF_BUMP_R1. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R1. DF_BUMP_R1¶. Bump function max radius. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R1. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_bump_r1-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r1-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r1.html:392,Deployability,update,updated,392,"﻿. DF_BUMP_R1. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R1. DF_BUMP_R1¶. Bump function max radius. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_BUMP_R1. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_bump_r1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_bump_r1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_domains-1.html:460,Deployability,update,updated,460,"﻿. DF_DOMAINS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_DOMAINS. DF_DOMAINS¶. FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_DOMAINS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_domains-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_domains-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_domains.html:460,Deployability,update,updated,460,"﻿. DF_DOMAINS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_DOMAINS. DF_DOMAINS¶. FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_DOMAINS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_domains.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_domains.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_fitting_condition-1.html:495,Deployability,update,updated,495,"﻿. DF_FITTING_CONDITION. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_FITTING_CONDITION. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_FITTING_CONDITION. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_fitting_condition-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_fitting_condition-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_fitting_condition.html:495,Deployability,update,updated,495,"﻿. DF_FITTING_CONDITION. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_FITTING_CONDITION. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_FITTING_CONDITION. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_fitting_condition.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_fitting_condition.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_io-1.html:438,Deployability,update,updated,438,"﻿. DF_INTS_IO. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_IO. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_IO. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_ints_io-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_io-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_io.html:438,Deployability,update,updated,438,"﻿. DF_INTS_IO. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_IO. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_IO. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_ints_io.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_io.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads-1.html:219,Availability,down,down,219,"﻿. DF_INTS_NUM_THREADS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads-1.html:489,Deployability,update,updated,489,"﻿. DF_INTS_NUM_THREADS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads.html:219,Availability,down,down,219,"﻿. DF_INTS_NUM_THREADS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads.html:489,Deployability,update,updated,489,"﻿. DF_INTS_NUM_THREADS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. DF_INTS_NUM_THREADS¶. Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_INTS_NUM_THREADS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_ints_num_threads.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_metric-1.html:431,Deployability,update,updated,431,"﻿. DF_METRIC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_METRIC. DF_METRIC¶. FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_METRIC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_metric-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_metric-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_metric.html:431,Deployability,update,updated,431,"﻿. DF_METRIC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_METRIC. DF_METRIC¶. FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_METRIC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_metric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_metric.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_scf_guess-1.html:519,Deployability,update,updated,519,"﻿. DF_SCF_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_SCF_GUESS. DF_SCF_GUESS¶. Do a density fitting SCF calculation to converge the orbitals before switching to the use of exact integrals in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_SCF_GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_scf_guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_scf_guess-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_scf_guess.html:519,Deployability,update,updated,519,"﻿. DF_SCF_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_SCF_GUESS. DF_SCF_GUESS¶. Do a density fitting SCF calculation to converge the orbitals before switching to the use of exact integrals in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_SCF_GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_scf_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_scf_guess.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_theta-1.html:409,Deployability,update,updated,409,"﻿. DF_THETA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_THETA. DF_THETA¶. FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_THETA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_theta-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_theta-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_theta.html:409,Deployability,update,updated,409,"﻿. DF_THETA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_THETA. DF_THETA¶. FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DF_THETA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__df_theta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__df_theta.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis-1.html:398,Deployability,update,updated,398,"﻿. DIIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis.html:398,Deployability,update,updated,398,"﻿. DIIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs-1.html:172,Availability,error,error,172,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs-1.html:441,Deployability,update,updated,441,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs.html:172,Availability,error,error,172,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs.html:441,Deployability,update,updated,441,"﻿. DIIS_MAX_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MAX_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_max_vecs.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs-1.html:172,Availability,error,error,172,"﻿. DIIS_MIN_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs-1.html:440,Deployability,update,updated,440,"﻿. DIIS_MIN_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs.html:172,Availability,error,error,172,"﻿. DIIS_MIN_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs.html:440,Deployability,update,updated,440,"﻿. DIIS_MIN_VECS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_MIN_VECS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_min_vecs.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html:165,Availability,error,error,165,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html:191,Availability,robust,robust,191,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html:207,Availability,error,error,207,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html:442,Deployability,update,updated,442,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html:165,Availability,error,error,165,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html:191,Availability,robust,robust,191,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html:207,Availability,error,error,207,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html:442,Deployability,update,updated,442,"﻿. DIIS_RMS_ERROR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_RMS_ERROR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_rms_error.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_start-1.html:418,Deployability,update,updated,418,"﻿. DIIS_START. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. DIIS_START¶. The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_start-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_start-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_start.html:418,Deployability,update,updated,418,"﻿. DIIS_START. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. DIIS_START¶. The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DIIS_START. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__diis_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__diis_start.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__distributed_matrix-1.html:451,Deployability,update,updated,451,"﻿. DISTRIBUTED_MATRIX. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DISTRIBUTED_MATRIX. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DISTRIBUTED_MATRIX. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__distributed_matrix-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__distributed_matrix-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__distributed_matrix.html:451,Deployability,update,updated,451,"﻿. DISTRIBUTED_MATRIX. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DISTRIBUTED_MATRIX. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; DISTRIBUTED_MATRIX. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__distributed_matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__distributed_matrix.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__d_convergence-1.html:654,Deployability,update,updated,654,"﻿. D_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; D_CONVERGENCE. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; D_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__d_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__d_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__d_convergence.html:654,Deployability,update,updated,654,"﻿. D_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; D_CONVERGENCE. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; D_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__d_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__d_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__extern-1.html:409,Deployability,update,updated,409,"﻿. EXTERN. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; EXTERN. EXTERN¶. An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; EXTERN. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__extern-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__extern-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__extern.html:409,Deployability,update,updated,409,"﻿. EXTERN. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; EXTERN. EXTERN¶. An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; EXTERN. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__extern.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__extern.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence-1.html:526,Deployability,update,updated,526,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence-1.html:184,Energy Efficiency,energy,energy,184,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence.html:526,Deployability,update,updated,526,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence.html:184,Energy Efficiency,energy,energy,184,"﻿. E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__e_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__fail_on_maxiter-1.html:434,Deployability,update,updated,434,"﻿. FAIL_ON_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FAIL_ON_MAXITER. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FAIL_ON_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__fail_on_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__fail_on_maxiter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__fail_on_maxiter.html:434,Deployability,update,updated,434,"﻿. FAIL_ON_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FAIL_ON_MAXITER. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FAIL_ON_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__fail_on_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__fail_on_maxiter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_increment-1.html:537,Deployability,update,updated,537,"﻿. FOLLOW_STEP_INCREMENT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_INCREMENT. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_INCREMENT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__follow_step_increment-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_increment-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_increment.html:537,Deployability,update,updated,537,"﻿. FOLLOW_STEP_INCREMENT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_INCREMENT. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_INCREMENT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__follow_step_increment.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_increment.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_scale-1.html:540,Deployability,update,updated,540,"﻿. FOLLOW_STEP_SCALE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_SCALE. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_SCALE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__follow_step_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_scale-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_scale.html:540,Deployability,update,updated,540,"﻿. FOLLOW_STEP_SCALE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_SCALE. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FOLLOW_STEP_SCALE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__follow_step_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__follow_step_scale.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_diis-1.html:426,Deployability,update,updated,426,"﻿. FRAC_DIIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_DIIS. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_DIIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_diis-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_diis.html:426,Deployability,update,updated,426,"﻿. FRAC_DIIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_DIIS. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_DIIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_diis.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_load-1.html:407,Deployability,update,updated,407,"﻿. FRAC_LOAD. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_LOAD. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_LOAD. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_load-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_load-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_load.html:407,Deployability,update,updated,407,"﻿. FRAC_LOAD. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_LOAD. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_LOAD. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_load.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_occ-1.html:451,Deployability,update,updated,451,"﻿. FRAC_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_OCC. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_occ-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_occ.html:451,Deployability,update,updated,451,"﻿. FRAC_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_OCC. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_occ.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize-1.html:209,Availability,checkpoint,checkpoint,209,"﻿. FRAC_RENORMALIZE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize-1.html:451,Deployability,update,updated,451,"﻿. FRAC_RENORMALIZE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize.html:209,Availability,checkpoint,checkpoint,209,"﻿. FRAC_RENORMALIZE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize.html:451,Deployability,update,updated,451,"﻿. FRAC_RENORMALIZE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_RENORMALIZE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_renormalize.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_start-1.html:457,Deployability,update,updated,457,"﻿. FRAC_START. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_START. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_START. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_start-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_start-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_start.html:457,Deployability,update,updated,457,"﻿. FRAC_START. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_START. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_START. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_start.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_val-1.html:451,Deployability,update,updated,451,"﻿. FRAC_VAL. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_VAL. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\le {\rm occ} \le 1.0\)). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_VAL. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_val-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_val-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_val.html:451,Deployability,update,updated,451,"﻿. FRAC_VAL. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_VAL. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\le {\rm occ} \le 1.0\)). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; FRAC_VAL. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__frac_val.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__frac_val.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess-1.html:694,Deployability,update,updated,694,"﻿. GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. GUESS¶. The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089 which also describes the SAP guess. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, HUCKEL, READ; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess-1.html:188,Performance,optimiz,optimizations,188,"﻿. GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. GUESS¶. The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089 which also describes the SAP guess. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, HUCKEL, READ; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess.html:694,Deployability,update,updated,694,"﻿. GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. GUESS¶. The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089 which also describes the SAP guess. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, HUCKEL, READ; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess.html:188,Performance,optimiz,optimizations,188,"﻿. GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. GUESS¶. The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089 which also describes the SAP guess. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, HUCKEL, READ; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_mix-1.html:569,Deployability,update,updated,569,"﻿. GUESS_MIX. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_MIX. GUESS_MIX¶. Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_MIX. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess_mix-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_mix-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_mix.html:569,Deployability,update,updated,569,"﻿. GUESS_MIX. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_MIX. GUESS_MIX¶. Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_MIX. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess_mix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_mix.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist-1.html:499,Deployability,update,updated,499,"﻿. GUESS_PERSIST. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess_persist-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist-1.html:258,Performance,optimiz,optimization,258,"﻿. GUESS_PERSIST. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess_persist-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist.html:499,Deployability,update,updated,499,"﻿. GUESS_PERSIST. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess_persist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist.html:258,Performance,optimiz,optimization,258,"﻿. GUESS_PERSIST. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; GUESS_PERSIST. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__guess_persist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__guess_persist.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__ints_tolerance-1.html:472,Deployability,update,updated,472,"﻿. INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; INTS_TOLERANCE. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; INTS_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__ints_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__ints_tolerance-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__ints_tolerance.html:472,Deployability,update,updated,472,"﻿. INTS_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; INTS_TOLERANCE. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; INTS_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__ints_tolerance.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift-1.html:393,Deployability,update,updated,393,"﻿. LEVEL_SHIFT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__level_shift-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift.html:393,Deployability,update,updated,393,"﻿. LEVEL_SHIFT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__level_shift.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff-1.html:174,Availability,error,error,174,"﻿. LEVEL_SHIFT_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff-1.html:453,Deployability,update,updated,453,"﻿. LEVEL_SHIFT_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff.html:174,Availability,error,error,174,"﻿. LEVEL_SHIFT_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff.html:453,Deployability,update,updated,453,"﻿. LEVEL_SHIFT_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LEVEL_SHIFT_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__level_shift_cutoff.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_convergence-1.html:456,Deployability,update,updated,456,"﻿. LOCAL_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_CONVERGENCE. LOCAL_CONVERGENCE¶. The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__local_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_convergence.html:456,Deployability,update,updated,456,"﻿. LOCAL_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_CONVERGENCE. LOCAL_CONVERGENCE¶. The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__local_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_maxiter-1.html:430,Deployability,update,updated,430,"﻿. LOCAL_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_MAXITER. LOCAL_MAXITER¶. The maxiter on the orbital localization procedure. Type: integer; Default: 200. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__local_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_maxiter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_maxiter.html:430,Deployability,update,updated,430,"﻿. LOCAL_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_MAXITER. LOCAL_MAXITER¶. The maxiter on the orbital localization procedure. Type: integer; Default: 200. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; LOCAL_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__local_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__local_maxiter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__maxiter-1.html:444,Deployability,update,updated,444,"﻿. MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAXITER. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__maxiter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__maxiter.html:444,Deployability,update,updated,444,"﻿. MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAXITER. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__maxiter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts-1.html:492,Deployability,update,updated,492,"﻿. MAX_ATTEMPTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__max_attempts-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts-1.html:215,Performance,optimiz,optimization,215,"﻿. MAX_ATTEMPTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__max_attempts-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts.html:492,Deployability,update,updated,492,"﻿. MAX_ATTEMPTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__max_attempts.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts.html:215,Performance,optimiz,optimization,215,"﻿. MAX_ATTEMPTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_ATTEMPTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__max_attempts.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_attempts.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_mem_buf-1.html:431,Deployability,update,updated,431,"﻿. MAX_MEM_BUF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_MEM_BUF. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_MEM_BUF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__max_mem_buf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_mem_buf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_mem_buf.html:431,Deployability,update,updated,431,"﻿. MAX_MEM_BUF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_MEM_BUF. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MAX_MEM_BUF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__max_mem_buf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__max_mem_buf.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__molden_write-1.html:587,Deployability,update,updated,587,"﻿. MOLDEN_WRITE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOLDEN_WRITE. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOLDEN_WRITE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__molden_write-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__molden_write-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__molden_write.html:587,Deployability,update,updated,587,"﻿. MOLDEN_WRITE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOLDEN_WRITE. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOLDEN_WRITE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__molden_write.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__molden_write.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_occ-1.html:437,Deployability,update,updated,437,"﻿. MOM_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_OCC. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__mom_occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_occ-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_occ.html:437,Deployability,update,updated,437,"﻿. MOM_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_OCC. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__mom_occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_occ.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_start-1.html:410,Deployability,update,updated,410,"﻿. MOM_START. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_START. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_START. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__mom_start-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_start-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_start.html:410,Deployability,update,updated,410,"﻿. MOM_START. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_START. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_START. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__mom_start.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_start.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_vir-1.html:435,Deployability,update,updated,435,"﻿. MOM_VIR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_VIR. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_VIR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__mom_vir-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_vir-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_vir.html:435,Deployability,update,updated,435,"﻿. MOM_VIR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_VIR. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; MOM_VIR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__mom_vir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__mom_vir.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__nl_dispersion_parameters-1.html:499,Deployability,update,updated,499,"﻿. NL_DISPERSION_PARAMETERS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; NL_DISPERSION_PARAMETERS. NL_DISPERSION_PARAMETERS¶. Parameters defining the -NL/-V dispersion correction. First b, then C. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; NL_DISPERSION_PARAMETERS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__nl_dispersion_parameters-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__nl_dispersion_parameters-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__nl_dispersion_parameters.html:499,Deployability,update,updated,499,"﻿. NL_DISPERSION_PARAMETERS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; NL_DISPERSION_PARAMETERS. NL_DISPERSION_PARAMETERS¶. Parameters defining the -NL/-V dispersion correction. First b, then C. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; NL_DISPERSION_PARAMETERS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__nl_dispersion_parameters.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__nl_dispersion_parameters.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__onepot_grid_read-1.html:440,Deployability,update,updated,440,"﻿. ONEPOT_GRID_READ. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ONEPOT_GRID_READ. ONEPOT_GRID_READ¶. Read an external potential from the .dx file?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ONEPOT_GRID_READ. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__onepot_grid_read-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__onepot_grid_read-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__onepot_grid_read.html:440,Deployability,update,updated,440,"﻿. ONEPOT_GRID_READ. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ONEPOT_GRID_READ. ONEPOT_GRID_READ¶. Read an external potential from the .dx file?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ONEPOT_GRID_READ. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__onepot_grid_read.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__onepot_grid_read.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__orbitals_write-1.html:465,Deployability,update,updated,465,"﻿. ORBITALS_WRITE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ORBITALS_WRITE. ORBITALS_WRITE¶. File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ORBITALS_WRITE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__orbitals_write-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__orbitals_write-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__orbitals_write.html:465,Deployability,update,updated,465,"﻿. ORBITALS_WRITE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ORBITALS_WRITE. ORBITALS_WRITE¶. File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; ORBITALS_WRITE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__orbitals_write.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__orbitals_write.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__parallel-1.html:382,Deployability,update,updated,382,"﻿. PARALLEL. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PARALLEL. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PARALLEL. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__parallel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__parallel-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__parallel.html:382,Deployability,update,updated,382,"﻿. PARALLEL. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PARALLEL. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PARALLEL. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__parallel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__parallel.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_dipole-1.html:500,Deployability,update,updated,500,"﻿. PERTURB_DIPOLE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_DIPOLE. PERTURB_DIPOLE¶. An array of length three describing the magnitude (atomic units) of the dipole field in the {x,y,z} directions. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_DIPOLE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_dipole-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_dipole-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_dipole.html:500,Deployability,update,updated,500,"﻿. PERTURB_DIPOLE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_DIPOLE. PERTURB_DIPOLE¶. An array of length three describing the magnitude (atomic units) of the dipole field in the {x,y,z} directions. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_DIPOLE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_dipole.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_dipole.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_h-1.html:394,Deployability,update,updated,394,"﻿. PERTURB_H. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_H. PERTURB_H¶. Do perturb the Hamiltonian?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_H. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_h-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_h-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_h.html:394,Deployability,update,updated,394,"﻿. PERTURB_H. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_H. PERTURB_H¶. Do perturb the Hamiltonian?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_H. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_h.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_h.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_magnitude-1.html:500,Deployability,update,updated,500,"﻿. PERTURB_MAGNITUDE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_MAGNITUDE. PERTURB_MAGNITUDE¶. Size of the perturbation (applies only to dipole perturbations). Deprecated - use PERTURB_DIPOLE instead. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_MAGNITUDE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_magnitude-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_magnitude-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_magnitude.html:500,Deployability,update,updated,500,"﻿. PERTURB_MAGNITUDE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_MAGNITUDE. PERTURB_MAGNITUDE¶. Size of the perturbation (applies only to dipole perturbations). Deprecated - use PERTURB_DIPOLE instead. Type: double; Default: 0.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_MAGNITUDE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_magnitude.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_magnitude.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_with-1.html:605,Deployability,update,updated,605,"﻿. PERTURB_WITH. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_WITH. PERTURB_WITH¶. The operator used to perturb the Hamiltonian, if requested. DIPOLE_X, DIPOLE_Y and DIPOLE_Z will be removed in favor of the DIPOLE option in the future. Type: string; Possible Values: DIPOLE, DIPOLE_X, DIPOLE_Y, DIPOLE_Z, EMBPOT, SPHERE, DX; Default: DIPOLE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_WITH. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_with-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_with-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_with.html:605,Deployability,update,updated,605,"﻿. PERTURB_WITH. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_WITH. PERTURB_WITH¶. The operator used to perturb the Hamiltonian, if requested. DIPOLE_X, DIPOLE_Y and DIPOLE_Z will be removed in favor of the DIPOLE option in the future. Type: string; Possible Values: DIPOLE, DIPOLE_X, DIPOLE_Y, DIPOLE_Z, EMBPOT, SPHERE, DX; Default: DIPOLE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PERTURB_WITH. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__perturb_with.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__perturb_with.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html:201,Deployability,integrat,integration,201,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html:436,Deployability,update,updated,436,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html:201,Integrability,integrat,integration,201,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points.html:201,Deployability,integrat,integration,201,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__phi_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points.html:436,Deployability,update,updated,436,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__phi_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points.html:201,Integrability,integrat,integration,201,"﻿. PHI_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. PHI_POINTS¶. Number of azimuthal grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PHI_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__phi_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__phi_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_algo-1.html:482,Deployability,update,updated,482,"﻿. PK_ALGO. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALGO. PK_ALGO¶. Select the PK algorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALGO. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_algo-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_algo-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_algo.html:482,Deployability,update,updated,482,"﻿. PK_ALGO. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALGO. PK_ALGO¶. Select the PK algorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALGO. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_algo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_algo.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_all_nonsym-1.html:437,Deployability,update,updated,437,"﻿. PK_ALL_NONSYM. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALL_NONSYM. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALL_NONSYM. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_all_nonsym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_all_nonsym-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_all_nonsym.html:437,Deployability,update,updated,437,"﻿. PK_ALL_NONSYM. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALL_NONSYM. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_ALL_NONSYM. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_all_nonsym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_all_nonsym.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_max_buckets-1.html:434,Deployability,update,updated,434,"﻿. PK_MAX_BUCKETS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_MAX_BUCKETS. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_MAX_BUCKETS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_max_buckets-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_max_buckets-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_max_buckets.html:434,Deployability,update,updated,434,"﻿. PK_MAX_BUCKETS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_MAX_BUCKETS. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_MAX_BUCKETS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_max_buckets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_max_buckets.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_no_incore-1.html:427,Deployability,update,updated,427,"﻿. PK_NO_INCORE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_NO_INCORE. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_NO_INCORE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_no_incore-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_no_incore-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_no_incore.html:427,Deployability,update,updated,427,"﻿. PK_NO_INCORE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_NO_INCORE. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PK_NO_INCORE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__pk_no_incore.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__pk_no_incore.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_basis-1.html:398,Deployability,update,updated,398,"﻿. PRINT_BASIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_BASIS. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_BASIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__print_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_basis-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_basis.html:398,Deployability,update,updated,398,"﻿. PRINT_BASIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_BASIS. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_BASIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__print_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_basis.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_mos-1.html:399,Deployability,update,updated,399,"﻿. PRINT_MOS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_MOS. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_MOS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__print_mos-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_mos-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_mos.html:399,Deployability,update,updated,399,"﻿. PRINT_MOS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_MOS. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PRINT_MOS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__print_mos.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__print_mos.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__process_grid-1.html:423,Deployability,update,updated,423,"﻿. PROCESS_GRID. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PROCESS_GRID. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PROCESS_GRID. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__process_grid-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__process_grid-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__process_grid.html:423,Deployability,update,updated,423,"﻿. PROCESS_GRID. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PROCESS_GRID. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; PROCESS_GRID. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__process_grid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__process_grid.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf-1.html:377,Deployability,update,updated,377,"﻿. QCHF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__qchf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf-1.html:130,Performance,perform,perform,130,"﻿. QCHF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__qchf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf.html:377,Deployability,update,updated,377,"﻿. QCHF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__qchf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf.html:130,Performance,perform,perform,130,"﻿. QCHF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; QCHF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__qchf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__qchf.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__radius-1.html:402,Deployability,update,updated,402,"﻿. RADIUS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; RADIUS. RADIUS¶. Radius (bohr) of a hard-sphere external potential. Type: double; Default: 10.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; RADIUS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__radius-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__radius-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__radius.html:402,Deployability,update,updated,402,"﻿. RADIUS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; RADIUS. RADIUS¶. Radius (bohr) of a hard-sphere external potential. Type: double; Default: 10.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; RADIUS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__radius.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__radius.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__reference-1.html:498,Deployability,update,updated,498,"﻿. REFERENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; REFERENCE. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; REFERENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__reference-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__reference.html:498,Deployability,update,updated,498,"﻿. REFERENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; REFERENCE. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; REFERENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__reference.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html:192,Deployability,integrat,integration,192,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html:425,Deployability,update,updated,425,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html:192,Integrability,integrat,integration,192,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points.html:192,Deployability,integrat,integration,192,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__r_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points.html:425,Deployability,update,updated,425,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__r_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points.html:192,Integrability,integrat,integration,192,"﻿. R_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. R_POINTS¶. Number of radial grid points for spherical potential integration. Type: integer; Default: 100. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; R_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__r_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__r_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_chol_tolerance-1.html:447,Deployability,update,updated,447,"﻿. SAD_CHOL_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_CHOL_TOLERANCE. SAD_CHOL_TOLERANCE¶. SAD guess density decomposition threshold. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_CHOL_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_chol_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_chol_tolerance-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_chol_tolerance.html:447,Deployability,update,updated,447,"﻿. SAD_CHOL_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_CHOL_TOLERANCE. SAD_CHOL_TOLERANCE¶. SAD guess density decomposition threshold. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_CHOL_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_chol_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_chol_tolerance.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_d_convergence-1.html:484,Deployability,update,updated,484,"﻿. SAD_D_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_D_CONVERGENCE. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in the SAD guess, analogous to D_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_D_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_d_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_d_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_d_convergence.html:484,Deployability,update,updated,484,"﻿. SAD_D_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_D_CONVERGENCE. SAD_D_CONVERGENCE¶. Convergence criterion for SCF density in the SAD guess, analogous to D_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_D_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_d_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_d_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence-1.html:483,Deployability,update,updated,483,"﻿. SAD_E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence-1.html:196,Energy Efficiency,energy,energy,196,"﻿. SAD_E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence.html:483,Deployability,update,updated,483,"﻿. SAD_E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence.html:196,Energy Efficiency,energy,energy,196,"﻿. SAD_E_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. SAD_E_CONVERGENCE¶. Convergence criterion for SCF energy in the SAD guess, analogous to E_CONVERGENCE. Type: conv double; Default: 1e-5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_E_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_e_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_frac_occ-1.html:472,Deployability,update,updated,472,"﻿. SAD_FRAC_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_FRAC_OCC. SAD_FRAC_OCC¶. Do force an even distribution of occupations across the last partially occupied orbital shell?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_FRAC_OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_frac_occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_frac_occ-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_frac_occ.html:472,Deployability,update,updated,472,"﻿. SAD_FRAC_OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_FRAC_OCC. SAD_FRAC_OCC¶. Do force an even distribution of occupations across the last partially occupied orbital shell?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_FRAC_OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_frac_occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_frac_occ.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_maxiter-1.html:422,Deployability,update,updated,422,"﻿. SAD_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_MAXITER. SAD_MAXITER¶. Maximum number of atomic SCF iterations within SAD. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_maxiter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_maxiter.html:422,Deployability,update,updated,422,"﻿. SAD_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_MAXITER. SAD_MAXITER¶. Maximum number of atomic SCF iterations within SAD. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_maxiter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_print-1.html:415,Deployability,update,updated,415,"﻿. SAD_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_PRINT. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_print-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_print.html:415,Deployability,update,updated,415,"﻿. SAD_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_PRINT. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_print.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_scf_type-1.html:500,Deployability,update,updated,500,"﻿. SAD_SCF_TYPE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SCF_TYPE. SAD_SCF_TYPE¶. SCF type used for atomic calculations in SAD guess. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: DF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SCF_TYPE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_scf_type-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_scf_type-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_scf_type.html:500,Deployability,update,updated,500,"﻿. SAD_SCF_TYPE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SCF_TYPE. SAD_SCF_TYPE¶. SCF type used for atomic calculations in SAD guess. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: DF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SCF_TYPE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_scf_type.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_scf_type.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_spin_average-1.html:481,Deployability,update,updated,481,"﻿. SAD_SPIN_AVERAGE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SPIN_AVERAGE. SAD_SPIN_AVERAGE¶. Do use spin-averaged occupations instead of atomic ground spin state in fractional SAD?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SPIN_AVERAGE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_spin_average-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_spin_average-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_spin_average.html:481,Deployability,update,updated,481,"﻿. SAD_SPIN_AVERAGE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SPIN_AVERAGE. SAD_SPIN_AVERAGE¶. Do use spin-averaged occupations instead of atomic ground spin state in fractional SAD?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAD_SPIN_AVERAGE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sad_spin_average.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sad_spin_average.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sapt-1.html:385,Deployability,update,updated,385,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAPT. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAPT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sapt-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sapt.html:385,Deployability,update,updated,385,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAPT. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAPT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__sapt.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_jk-1.html:388,Deployability,update,updated,388,"﻿. SAVE_JK. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_JK. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_JK. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__save_jk-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_jk-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_jk.html:388,Deployability,update,updated,388,"﻿. SAVE_JK. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_JK. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_JK. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__save_jk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_jk.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_uhf_nos-1.html:395,Deployability,update,updated,395,"﻿. SAVE_UHF_NOS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_UHF_NOS. SAVE_UHF_NOS¶. Save the UHF NOs. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_UHF_NOS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__save_uhf_nos-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_uhf_nos-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_uhf_nos.html:395,Deployability,update,updated,395,"﻿. SAVE_UHF_NOS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_UHF_NOS. SAVE_UHF_NOS¶. Save the UHF NOs. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SAVE_UHF_NOS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__save_uhf_nos.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__save_uhf_nos.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor-1.html:451,Deployability,update,updated,451,"﻿. SCF_MEM_SAFETY_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor-1.html:185,Safety,safe,safety,185,"﻿. SCF_MEM_SAFETY_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor.html:451,Deployability,update,updated,451,"﻿. SCF_MEM_SAFETY_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor.html:185,Safety,safe,safety,185,"﻿. SCF_MEM_SAFETY_FACTOR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_MEM_SAFETY_FACTOR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_mem_safety_factor.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties-1.html:501,Deployability,update,updated,501,"﻿. SCF_PROPERTIES. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_properties-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties-1.html:194,Energy Efficiency,energy,energy,194,"﻿. SCF_PROPERTIES. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_properties-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties.html:501,Deployability,update,updated,501,"﻿. SCF_PROPERTIES. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_properties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties.html:194,Energy Efficiency,energy,energy,194,"﻿. SCF_PROPERTIES. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SCF_PROPERTIES. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__scf_properties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__scf_properties.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf-1.html:395,Deployability,update,updated,395,"﻿. SOSCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf.html:395,Deployability,update,updated,395,"﻿. SOSCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_conv-1.html:446,Deployability,update,updated,446,"﻿. SOSCF_CONV. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_CONV. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_CONV. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_conv-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_conv-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_conv.html:446,Deployability,update,updated,446,"﻿. SOSCF_CONV. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_CONV. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_CONV. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_conv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_conv.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter-1.html:440,Deployability,update,updated,440,"﻿. SOSCF_MAX_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter-1.html:207,Performance,perform,perform,207,"﻿. SOSCF_MAX_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter.html:440,Deployability,update,updated,440,"﻿. SOSCF_MAX_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter.html:207,Performance,perform,perform,207,"﻿. SOSCF_MAX_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MAX_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_max_iter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter-1.html:440,Deployability,update,updated,440,"﻿. SOSCF_MIN_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter-1.html:207,Performance,perform,perform,207,"﻿. SOSCF_MIN_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter.html:440,Deployability,update,updated,440,"﻿. SOSCF_MIN_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter.html:207,Performance,perform,perform,207,"﻿. SOSCF_MIN_ITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_MIN_ITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_min_iter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_print-1.html:413,Deployability,update,updated,413,"﻿. SOSCF_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_PRINT. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_print-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_print.html:413,Deployability,update,updated,413,"﻿. SOSCF_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_PRINT. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_print.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_start_convergence-1.html:491,Deployability,update,updated,491,"﻿. SOSCF_START_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_START_CONVERGENCE. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_START_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_start_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_start_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_start_convergence.html:491,Deployability,update,updated,491,"﻿. SOSCF_START_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_START_CONVERGENCE. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; SOSCF_START_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__soscf_start_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__soscf_start_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html:806,Deployability,update,updated,806,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html:180,Performance,perform,perform,180,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html:255,Performance,perform,performed,255,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html:373,Performance,perform,perform,373,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html:806,Deployability,update,updated,806,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html:180,Performance,perform,perform,180,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html:255,Performance,perform,performed,255,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html:373,Performance,perform,perform,373,"﻿. STABILITY_ANALYSIS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; STABILITY_ANALYSIS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__stability_analysis.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_cholesky_tolerance-1.html:476,Deployability,update,updated,476,"﻿. S_CHOLESKY_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_CHOLESKY_TOLERANCE. S_CHOLESKY_TOLERANCE¶. Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_CHOLESKY_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_cholesky_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_cholesky_tolerance-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_cholesky_tolerance.html:476,Deployability,update,updated,476,"﻿. S_CHOLESKY_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_CHOLESKY_TOLERANCE. S_CHOLESKY_TOLERANCE¶. Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_CHOLESKY_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_cholesky_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_cholesky_tolerance.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_orthogonalization-1.html:524,Deployability,update,updated,524,"﻿. S_ORTHOGONALIZATION. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_ORTHOGONALIZATION. S_ORTHOGONALIZATION¶. SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_ORTHOGONALIZATION. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_orthogonalization-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_orthogonalization-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_orthogonalization.html:524,Deployability,update,updated,524,"﻿. S_ORTHOGONALIZATION. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_ORTHOGONALIZATION. S_ORTHOGONALIZATION¶. SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_ORTHOGONALIZATION. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_orthogonalization.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_orthogonalization.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance-1.html:453,Deployability,update,updated,453,"﻿. S_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance-1.html:199,Integrability,depend,dependencies,199,"﻿. S_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance.html:453,Deployability,update,updated,453,"﻿. S_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance.html:199,Integrability,depend,dependencies,199,"﻿. S_TOLERANCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; S_TOLERANCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__s_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__s_tolerance.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_coeff_cutoff-1.html:486,Deployability,update,updated,486,"﻿. TDSCF_COEFF_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_COEFF_CUTOFF. TDSCF_COEFF_CUTOFF¶. Cutoff for printing excitations and de-excitations icontributing to each excited state. Type: double; Default: 0.1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_COEFF_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_coeff_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_coeff_cutoff-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_coeff_cutoff.html:486,Deployability,update,updated,486,"﻿. TDSCF_COEFF_CUTOFF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_COEFF_CUTOFF. TDSCF_COEFF_CUTOFF¶. Cutoff for printing excitations and de-excitations icontributing to each excited state. Type: double; Default: 0.1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_COEFF_CUTOFF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_coeff_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_coeff_cutoff.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_guess-1.html:432,Deployability,update,updated,432,"﻿. TDSCF_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_GUESS. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_guess-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_guess.html:432,Deployability,update,updated,432,"﻿. TDSCF_GUESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_GUESS. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_GUESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_guess.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_maxiter-1.html:421,Deployability,update,updated,421,"﻿. TDSCF_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_MAXITER. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_maxiter-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_maxiter.html:421,Deployability,update,updated,421,"﻿. TDSCF_MAXITER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_MAXITER. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_MAXITER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_maxiter.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_print-1.html:395,Deployability,update,updated,395,"﻿. TDSCF_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_PRINT. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_print-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_print.html:395,Deployability,update,updated,395,"﻿. TDSCF_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_PRINT. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_print.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_r_convergence-1.html:509,Deployability,update,updated,509,"﻿. TDSCF_R_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_R_CONVERGENCE. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_R_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_r_convergence-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_r_convergence.html:509,Deployability,update,updated,509,"﻿. TDSCF_R_CONVERGENCE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_R_CONVERGENCE. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_R_CONVERGENCE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_r_convergence.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_states-1.html:695,Deployability,update,updated,695,"﻿. TDSCF_STATES. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_STATES. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_STATES. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_states-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_states.html:695,Deployability,update,updated,695,"﻿. TDSCF_STATES. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_STATES. TDSCF_STATES¶. Number of roots (excited states) we should seek to converge. This can be either an integer (total number of states to seek) or a list (number of states per irrep). The latter is only valid if the system has symmetry. Furthermore, the total number of states will be redistributed among irreps when symmetry is used. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_STATES. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_states.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_states.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tda-1.html:458,Deployability,update,updated,458,"﻿. TDSCF_TDA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDA. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_tda-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tda-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tda.html:458,Deployability,update,updated,458,"﻿. TDSCF_TDA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDA. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_tda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tda.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tdm_print-1.html:630,Deployability,update,updated,630,"﻿. TDSCF_TDM_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDM_PRINT. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDM_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_tdm_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tdm_print-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tdm_print.html:630,Deployability,update,updated,630,"﻿. TDSCF_TDM_PRINT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDM_PRINT. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TDM_PRINT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_tdm_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_tdm_print.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets-1.html:793,Deployability,update,updated,793,"﻿. TDSCF_TRIPLETS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets-1.html:313,Energy Efficiency,energy,energy,313,"﻿. TDSCF_TRIPLETS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets.html:793,Deployability,update,updated,793,"﻿. TDSCF_TRIPLETS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets.html:313,Energy Efficiency,energy,energy,313,"﻿. TDSCF_TRIPLETS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. TDSCF_TRIPLETS¶. Controls inclusion of triplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TDSCF_TRIPLETS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tdscf_triplets.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html:208,Deployability,integrat,integration,208,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html:445,Deployability,update,updated,445,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html:208,Integrability,integrat,integration,208,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points.html:208,Deployability,integrat,integration,208,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__theta_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points.html:445,Deployability,update,updated,445,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__theta_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points.html:208,Integrability,integrat,integration,208,"﻿. THETA_POINTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. THETA_POINTS¶. Number of colatitude grid points for spherical potential integration. Type: integer; Default: 360. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THETA_POINTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__theta_points.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__theta_points.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__thickness-1.html:417,Deployability,update,updated,417,"﻿. THICKNESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THICKNESS. THICKNESS¶. Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THICKNESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__thickness-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__thickness-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__thickness.html:417,Deployability,update,updated,417,"﻿. THICKNESS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THICKNESS. THICKNESS¶. Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; THICKNESS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__thickness.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__thickness.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tile_sz-1.html:399,Deployability,update,updated,399,"﻿. TILE_SZ. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TILE_SZ. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TILE_SZ. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tile_sz-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tile_sz-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tile_sz.html:399,Deployability,update,updated,399,"﻿. TILE_SZ. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TILE_SZ. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; TILE_SZ. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__tile_sz.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__tile_sz.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__uhf_noons-1.html:404,Deployability,update,updated,404,"﻿. UHF_NOONS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; UHF_NOONS. UHF_NOONS¶. The number of NOONs to print in a UHF calc. Type: string; Default: 3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; UHF_NOONS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__uhf_noons-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__uhf_noons-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__uhf_noons.html:404,Deployability,update,updated,404,"﻿. UHF_NOONS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; UHF_NOONS. UHF_NOONS¶. The number of NOONs to print in a UHF calc. Type: string; Default: 3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; UHF_NOONS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__uhf_noons.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__uhf_noons.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wcombine-1.html:548,Deployability,update,updated,548,"﻿. WCOMBINE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WCOMBINE. WCOMBINE¶. combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Default is True for MemDFJK (itself the default for SCF_TYPE DF), False otherwise as not yet implemented. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WCOMBINE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__wcombine-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wcombine-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wcombine.html:548,Deployability,update,updated,548,"﻿. WCOMBINE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WCOMBINE. WCOMBINE¶. combine omega exchange and Hartree–Fock exchange into one matrix for efficiency? Default is True for MemDFJK (itself the default for SCF_TYPE DF), False otherwise as not yet implemented. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WCOMBINE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__wcombine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wcombine.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wfn-1.html:379,Deployability,update,updated,379,"﻿. WFN. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WFN. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WFN. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wfn-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wfn.html:379,Deployability,update,updated,379,"﻿. WFN. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WFN. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; SCF; WFN. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/scf__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/scf__wfn.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__p-1.html:432,Deployability,update,updated,432,"﻿. P. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; P. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; P. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__p-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__p-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__p.html:432,Deployability,update,updated,432,"﻿. P. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; P. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; P. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__p.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__p.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number-1.html:947,Deployability,update,updated,947,"﻿. ROTATIONAL_SYMMETRY_NUMBER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number-1.html:580,Integrability,depend,dependent,580,"﻿. ROTATIONAL_SYMMETRY_NUMBER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number.html:947,Deployability,update,updated,947,"﻿. ROTATIONAL_SYMMETRY_NUMBER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number.html:580,Integrability,depend,dependent,580,"﻿. ROTATIONAL_SYMMETRY_NUMBER. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Note that this factor is handled differently among quantum chemistry software. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; ROTATIONAL_SYMMETRY_NUMBER. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__rotational_symmetry_number.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__t-1.html:434,Deployability,update,updated,434,"﻿. T. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; T. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; T. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__t-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__t-1.html
https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__t.html:434,Deployability,update,updated,434,"﻿. T. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; T. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; THERMO; T. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_options_c/thermo__t.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/thermo__t.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__adc-1.html:652,Deployability,update,updated,652,"﻿. ADC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; ADC. ADC¶; Performs Algebraic-Diagrammatic Construction (ADC) propagator computations for excited states. ADC ITERATIONS; ADC ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY; ADC ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY; ADC ROOT n TOTAL ENERGY - h SYMMETRY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; ADC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__adc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__adc-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__adc.html:652,Deployability,update,updated,652,"﻿. ADC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; ADC. ADC¶; Performs Algebraic-Diagrammatic Construction (ADC) propagator computations for excited states. ADC ITERATIONS; ADC ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY; ADC ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY; ADC ROOT n TOTAL ENERGY - h SYMMETRY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; ADC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__adc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__adc.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__ccenergy-1.html:2087,Deployability,update,updated,2087,"energies. Called as part of any coupled cluster computation. (T) CORRECTION ENERGY; A-(T) CORRECTION ENERGY; A-CCSD(T) CORRELATION ENERGY; A-CCSD(T) TOTAL ENERGY; AAA (T) CORRECTION ENERGY; AAB (T) CORRECTION ENERGY; ABB (T) CORRECTION ENERGY; BBB (T) CORRECTION ENERGY; BRUECKNER CONVERGED; CC CORRELATION ENERGY; CC D1 DIAGNOSTIC; CC D2 DIAGNOSTIC; CC NEW D1 DIAGNOSTIC; CC ROOT n CORRELATION ENERGY; CC ROOT n DIPOLE; CC ROOT n DIPOLE X; CC ROOT n DIPOLE Y; CC ROOT n DIPOLE Z; CC ROOT n QUADRUPOLE; CC ROOT n QUADRUPOLE XX; CC ROOT n QUADRUPOLE XY; CC ROOT n QUADRUPOLE XZ; CC ROOT n QUADRUPOLE YY; CC ROOT n QUADRUPOLE YZ; CC ROOT n QUADRUPOLE ZZ; CC ROOT n TOTAL ENERGY; CC T1 DIAGNOSTIC; CC TOTAL ENERGY; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC3 CORRELATION ENERGY; CC3 TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCC2 (+LMP2) TOTAL ENERGY; LCCSD (+LMP2) TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-CCSD CORRELATION ENERGY; SCS-CCSD TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; CCENERGY. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__ccenergy-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__ccenergy-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__ccenergy.html:2087,Deployability,update,updated,2087,"energies. Called as part of any coupled cluster computation. (T) CORRECTION ENERGY; A-(T) CORRECTION ENERGY; A-CCSD(T) CORRELATION ENERGY; A-CCSD(T) TOTAL ENERGY; AAA (T) CORRECTION ENERGY; AAB (T) CORRECTION ENERGY; ABB (T) CORRECTION ENERGY; BBB (T) CORRECTION ENERGY; BRUECKNER CONVERGED; CC CORRELATION ENERGY; CC D1 DIAGNOSTIC; CC D2 DIAGNOSTIC; CC NEW D1 DIAGNOSTIC; CC ROOT n CORRELATION ENERGY; CC ROOT n DIPOLE; CC ROOT n DIPOLE X; CC ROOT n DIPOLE Y; CC ROOT n DIPOLE Z; CC ROOT n QUADRUPOLE; CC ROOT n QUADRUPOLE XX; CC ROOT n QUADRUPOLE XY; CC ROOT n QUADRUPOLE XZ; CC ROOT n QUADRUPOLE YY; CC ROOT n QUADRUPOLE YZ; CC ROOT n QUADRUPOLE ZZ; CC ROOT n TOTAL ENERGY; CC T1 DIAGNOSTIC; CC TOTAL ENERGY; CC2 CORRELATION ENERGY; CC2 DIPOLE POLARIZABILITY @ xNM; CC2 SPECIFIC ROTATION (LEN) @ xNM; CC2 SPECIFIC ROTATION (MVG) @ xNM; CC2 SPECIFIC ROTATION (VEL) @ xNM; CC2 TOTAL ENERGY; CC3 CORRELATION ENERGY; CC3 TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DIPOLE POLARIZABILITY @ xNM; CCSD DOUBLES ENERGY; CCSD ITERATIONS; CCSD OPPOSITE-SPIN CORRELATION ENERGY; CCSD SAME-SPIN CORRELATION ENERGY; CCSD SINGLES ENERGY; CCSD SPECIFIC ROTATION (LEN) @ xNM; CCSD SPECIFIC ROTATION (MVG) @ xNM; CCSD SPECIFIC ROTATION (VEL) @ xNM; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCC2 (+LMP2) TOTAL ENERGY; LCCSD (+LMP2) TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-CCSD CORRELATION ENERGY; SCS-CCSD TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; CCENERGY. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__ccenergy.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__cfour-1.html:978,Deployability,update,updated,978,"﻿. CFOUR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; CFOUR. CFOUR¶. (T) CORRECTION ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CFOUR ERROR CODE; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; HF TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; NUCLEAR REPULSION ENERGY; SCF TOTAL ENERGY; [T] CORRECTION ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; CFOUR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__cfour-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__cfour-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__cfour.html:978,Deployability,update,updated,978,"﻿. CFOUR. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; CFOUR. CFOUR¶. (T) CORRECTION ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CFOUR ERROR CODE; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; HF TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; NUCLEAR REPULSION ENERGY; SCF TOTAL ENERGY; [T] CORRECTION ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; CFOUR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__cfour.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dct-1.html:508,Deployability,update,updated,508,"﻿. DCT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DCT. DCT¶; Performs density cumulant (functional) theory computations. CURRENT ENERGY; DCT LAMBDA ENERGY; DCT SCF ENERGY; DCT THREE-PARTICLE ENERGY; DCT TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DCT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dct-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dct-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dct.html:508,Deployability,update,updated,508,"﻿. DCT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DCT. DCT¶; Performs density cumulant (functional) theory computations. CURRENT ENERGY; DCT LAMBDA ENERGY; DCT SCF ENERGY; DCT THREE-PARTICLE ENERGY; DCT TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DCT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dct.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html:139,Deployability,configurat,configuration,139,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html:280,Deployability,configurat,configuration,280,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html:1828,Deployability,update,updated,1828,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html:139,Modifiability,config,configuration,139,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html:280,Modifiability,config,configuration,280,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html:139,Deployability,configurat,configuration,139,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html:280,Deployability,configurat,configuration,280,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html:1828,Deployability,update,updated,1828,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html:139,Modifiability,config,configuration,139,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html:280,Modifiability,config,configuration,280,"﻿. DETCI. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. DETCI¶; Performs configuration interaction (CI) computations of various types, including restricted-active-space (RAS) CI, full CI, the CI component of multi-configuration self-consistent-field (MCSCF) and complete-active-space self-consistent-field (CASSCF) computations, and arbitrary-order perturbation theory and arbitrary-order coupled-cluster computations for small molecules. CI CORRELATION ENERGY; CI ROOT n -> ROOT m DIPOLE X; CI ROOT n -> ROOT m DIPOLE Y; CI ROOT n -> ROOT m DIPOLE Z; CI ROOT n -> ROOT m QUADRUPOLE XX; CI ROOT n -> ROOT m QUADRUPOLE XY; CI ROOT n -> ROOT m QUADRUPOLE XZ; CI ROOT n -> ROOT m QUADRUPOLE YY; CI ROOT n -> ROOT m QUADRUPOLE YZ; CI ROOT n -> ROOT m QUADRUPOLE ZZ; CI ROOT n CORRELATION ENERGY; CI ROOT n DIPOLE; CI ROOT n DIPOLE X; CI ROOT n DIPOLE Y; CI ROOT n DIPOLE Z; CI ROOT n QUADRUPOLE; CI ROOT n QUADRUPOLE XX; CI ROOT n QUADRUPOLE XY; CI ROOT n QUADRUPOLE XZ; CI ROOT n QUADRUPOLE YY; CI ROOT n QUADRUPOLE YZ; CI ROOT n QUADRUPOLE ZZ; CI ROOT n TOTAL ENERGY; CI STATE-AVERAGED CORRELATION ENERGY; CI STATE-AVERAGED TOTAL ENERGY; CI TOTAL ENERGY; CISD CORRELATION ENERGY; CISD TOTAL ENERGY; CISDT CORRELATION ENERGY; CISDT TOTAL ENERGY; CISDTQ CORRELATION ENERGY; CISDTQ TOTAL ENERGY; CIn CORRELATION ENERGY; CIn TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; DETCI AVG DVEC NORM; FCI CORRELATION ENERGY; FCI TOTAL ENERGY; MCSCF TOTAL ENERGY; MPn CORRELATION ENERGY; MPn TOTAL ENERGY; ZAPTn CORRELATION ENERGY; ZAPTn TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DETCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__detci.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfmp2-1.html:707,Deployability,update,updated,707,"﻿. DFMP2. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFMP2. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2 TOTAL GRADIENT; SCF TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFMP2. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dfmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfmp2-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfmp2.html:707,Deployability,update,updated,707,"﻿. DFMP2. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFMP2. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2 TOTAL GRADIENT; SCF TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFMP2. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfmp2.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html:1937,Deployability,update,updated,1937,"gation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html:162,Performance,optimiz,optimized,162,"﻿. DFOCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphi",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc.html:1937,Deployability,update,updated,1937,"gation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc.html:162,Performance,optimiz,optimized,162,"﻿. DFOCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphi",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dmrg-1.html:451,Deployability,update,updated,451,"﻿. DMRG. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DMRG. DMRG¶; Performs a DMRG computation through calls to Wouters’s CheMPS2 library. CURRENT ENERGY; DMRG-CASPT2 TOTAL ENERGY; DMRG-SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DMRG. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dmrg-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dmrg-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dmrg.html:451,Deployability,update,updated,451,"﻿. DMRG. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DMRG. DMRG¶; Performs a DMRG computation through calls to Wouters’s CheMPS2 library. CURRENT ENERGY; DMRG-CASPT2 TOTAL ENERGY; DMRG-SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DMRG. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dmrg.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__efp-1.html:517,Deployability,update,updated,517,"﻿. EFP. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; EFP. EFP¶; Performs effective fragment potential computations through calls to Kaliman’s libefp library. CURRENT ENERGY; EFP DISP ENERGY; EFP ELST ENERGY; EFP EXCH ENERGY; EFP IND ENERGY; EFP TORQUE; EFP TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; EFP. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__efp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__efp-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__efp.html:517,Deployability,update,updated,517,"﻿. EFP. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; EFP. EFP¶; Performs effective fragment potential computations through calls to Kaliman’s libefp library. CURRENT ENERGY; EFP DISP ENERGY; EFP ELST ENERGY; EFP EXCH ENERGY; EFP IND ENERGY; EFP TORQUE; EFP TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; EFP. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__efp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__efp.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fisapt-1.html:1014,Deployability,update,updated,1014,"﻿. FISAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; FISAPT. FISAPT¶. CURRENT ENERGY; SAPT DISP ENERGY; SAPT DISP20 ENERGY; SAPT ELST ENERGY; SAPT ELST EXTERN-EXTERN ENERGY; SAPT ELST10,R ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP20(S^INF) ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT HF(2) ENERGY A(0); SAPT HF(2) ENERGY A(HF); SAPT HF(2) ENERGY AB(HF); SAPT HF(2) ENERGY ABC(HF); SAPT HF(2) ENERGY AC(0); SAPT HF(2) ENERGY AC(HF); SAPT HF(2) ENERGY B(0); SAPT HF(2) ENERGY B(HF); SAPT HF(2) ENERGY BC(0); SAPT HF(2) ENERGY BC(HF); SAPT HF(2) ENERGY C; SAPT HF(2) ENERGY HF; SAPT IND ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT TOTAL ENERGY; SAPT0 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; FISAPT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__fisapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fisapt-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fisapt.html:1014,Deployability,update,updated,1014,"﻿. FISAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; FISAPT. FISAPT¶. CURRENT ENERGY; SAPT DISP ENERGY; SAPT DISP20 ENERGY; SAPT ELST ENERGY; SAPT ELST EXTERN-EXTERN ENERGY; SAPT ELST10,R ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP20(S^INF) ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT HF(2) ENERGY A(0); SAPT HF(2) ENERGY A(HF); SAPT HF(2) ENERGY AB(HF); SAPT HF(2) ENERGY ABC(HF); SAPT HF(2) ENERGY AC(0); SAPT HF(2) ENERGY AC(HF); SAPT HF(2) ENERGY B(0); SAPT HF(2) ENERGY B(HF); SAPT HF(2) ENERGY BC(0); SAPT HF(2) ENERGY BC(HF); SAPT HF(2) ENERGY C; SAPT HF(2) ENERGY HF; SAPT IND ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT TOTAL ENERGY; SAPT0 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; FISAPT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__fisapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fisapt.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fnocc-1.html:2787,Deployability,update,updated,2787,") CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; NAUX (CC); NAUX (SCF); QCISD CORRELATION ENERGY; QCISD OPPOSITE-SPIN CORRELATION ENERGY; QCISD SAME-SPIN CORRELATION ENERGY; QCISD TOTAL ENERGY; QCISD(T) CORRELATION ENERGY; QCISD(T) TOTAL ENERGY; SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; FNOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__fnocc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fnocc-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fnocc.html:2787,Deployability,update,updated,2787,") CORRELATION ENERGY; CEPA(1) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(1) SAME-SPIN CORRELATION ENERGY; CEPA(1) TOTAL ENERGY; CEPA(2) CORRELATION ENERGY; CEPA(2) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(2) SAME-SPIN CORRELATION ENERGY; CEPA(2) TOTAL ENERGY; CEPA(3) CORRELATION ENERGY; CEPA(3) OPPOSITE-SPIN CORRELATION ENERGY; CEPA(3) SAME-SPIN CORRELATION ENERGY; CEPA(3) TOTAL ENERGY; CISD CORRELATION ENERGY; CISD OPPOSITE-SPIN CORRELATION ENERGY; CISD SAME-SPIN CORRELATION ENERGY; CISD TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; LCCSD CORRELATION ENERGY; LCCSD DOUBLES ENERGY; LCCSD OPPOSITE-SPIN CORRELATION ENERGY; LCCSD SAME-SPIN CORRELATION ENERGY; LCCSD SINGLES ENERGY; LCCSD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; MP4 CORRELATION ENERGY; MP4 TOTAL ENERGY; MP4(SDQ) CORRELATION ENERGY; MP4(SDQ) TOTAL ENERGY; MP4(SDTQ) CORRELATION ENERGY; MP4(SDTQ) TOTAL ENERGY; MP4(T) CORRECTION ENERGY; NAUX (CC); NAUX (SCF); QCISD CORRELATION ENERGY; QCISD OPPOSITE-SPIN CORRELATION ENERGY; QCISD SAME-SPIN CORRELATION ENERGY; QCISD TOTAL ENERGY; QCISD(T) CORRELATION ENERGY; QCISD(T) TOTAL ENERGY; SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; FNOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__fnocc.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__gdma-1.html:490,Deployability,update,updated,490,"﻿. GDMA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; GDMA. GDMA¶; Performs distributed multipole analysis (DMA), using Anthony Stone’s GDMA program. See GDMA for more details. DMA DISTRIBUTED MULTIPOLES (array); DMA TOTAL MULTIPOLES (array). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; GDMA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__gdma-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__gdma-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__gdma.html:490,Deployability,update,updated,490,"﻿. GDMA. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; GDMA. GDMA¶; Performs distributed multipole analysis (DMA), using Anthony Stone’s GDMA program. See GDMA for more details. DMA DISTRIBUTED MULTIPOLES (array); DMA TOTAL MULTIPOLES (array). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; GDMA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__gdma.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__gdma.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mcscf-1.html:557,Deployability,update,updated,557,"﻿. MCSCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MCSCF. MCSCF¶; Performs RHF/UHF/ROHF/TCSCF and more general MCSCF computations. Called as the starting point for multireference coupled cluster computations. CURRENT ENERGY; CURRENT REFERENCE ENERGY; MCSCF TOTAL ENERGY; SCF ITERATIONS; SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MCSCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__mcscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mcscf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mcscf.html:557,Deployability,update,updated,557,"﻿. MCSCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MCSCF. MCSCF¶; Performs RHF/UHF/ROHF/TCSCF and more general MCSCF computations. Called as the starting point for multireference coupled cluster computations. CURRENT ENERGY; CURRENT REFERENCE ENERGY; MCSCF TOTAL ENERGY; SCF ITERATIONS; SCF TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MCSCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mcscf.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mrcc-1.html:1654,Deployability,update,updated,1654,"﻿. MRCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MRCC. MRCC¶; Interface to MRCC program written by Mihály Kállay. CC(n-1)(n) CORRELATION ENERGY; CC(n-1)(n) TOTAL ENERGY; CC(n-1)(n)_L CORRELATION ENERGY; CC(n-1)(n)_L TOTAL ENERGY; CC2 CORRELATION ENERGY; CC2 TOTAL ENERGY; CC3 CORRELATION ENERGY; CC3 TOTAL ENERGY; CC4 CORRELATION ENERGY; CC4 TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CCSD(T)_L CORRELATION ENERGY; CCSD(T)_L TOTAL ENERGY; CCSDT CORRELATION ENERGY; CCSDT TOTAL ENERGY; CCSDT(Q) CORRELATION ENERGY; CCSDT(Q) TOTAL ENERGY; CCSDT(Q)/A CORRELATION ENERGY; CCSDT(Q)/A TOTAL ENERGY; CCSDT(Q)/B CORRELATION ENERGY; CCSDT(Q)/B TOTAL ENERGY; CCSDT(Q)_L CORRELATION ENERGY; CCSDT(Q)_L TOTAL ENERGY; CCSDT-1a CORRELATION ENERGY; CCSDT-1a TOTAL ENERGY; CCSDT-1b CORRELATION ENERGY; CCSDT-1b TOTAL ENERGY; CCSDT-3 CORRELATION ENERGY; CCSDT-3 TOTAL ENERGY; CCSDTQ CORRELATION ENERGY; CCSDTQ TOTAL ENERGY; CCSDTQ-1a CORRELATION ENERGY; CCSDTQ-1a TOTAL ENERGY; CCSDTQ-1b CORRELATION ENERGY; CCSDTQ-1b TOTAL ENERGY; CCSDTQ-3 CORRELATION ENERGY; CCSDTQ-3 TOTAL ENERGY; CCn CORRELATION ENERGY; CCn TOTAL ENERGY; CCn-1a CORRELATION ENERGY; CCn-1a TOTAL ENERGY; CCn-1b CORRELATION ENERGY; CCn-1b TOTAL ENERGY; CCn-3 CORRELATION ENERGY; CCn-3 TOTAL ENERGY; CCnn CORRELATION ENERGY; CCnn TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MRCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mrcc-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mrcc.html:1654,Deployability,update,updated,1654,"﻿. MRCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MRCC. MRCC¶; Interface to MRCC program written by Mihály Kállay. CC(n-1)(n) CORRELATION ENERGY; CC(n-1)(n) TOTAL ENERGY; CC(n-1)(n)_L CORRELATION ENERGY; CC(n-1)(n)_L TOTAL ENERGY; CC2 CORRELATION ENERGY; CC2 TOTAL ENERGY; CC3 CORRELATION ENERGY; CC3 TOTAL ENERGY; CC4 CORRELATION ENERGY; CC4 TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CCSD(T)_L CORRELATION ENERGY; CCSD(T)_L TOTAL ENERGY; CCSDT CORRELATION ENERGY; CCSDT TOTAL ENERGY; CCSDT(Q) CORRELATION ENERGY; CCSDT(Q) TOTAL ENERGY; CCSDT(Q)/A CORRELATION ENERGY; CCSDT(Q)/A TOTAL ENERGY; CCSDT(Q)/B CORRELATION ENERGY; CCSDT(Q)/B TOTAL ENERGY; CCSDT(Q)_L CORRELATION ENERGY; CCSDT(Q)_L TOTAL ENERGY; CCSDT-1a CORRELATION ENERGY; CCSDT-1a TOTAL ENERGY; CCSDT-1b CORRELATION ENERGY; CCSDT-1b TOTAL ENERGY; CCSDT-3 CORRELATION ENERGY; CCSDT-3 TOTAL ENERGY; CCSDTQ CORRELATION ENERGY; CCSDTQ TOTAL ENERGY; CCSDTQ-1a CORRELATION ENERGY; CCSDTQ-1a TOTAL ENERGY; CCSDTQ-1b CORRELATION ENERGY; CCSDTQ-1b TOTAL ENERGY; CCSDTQ-3 CORRELATION ENERGY; CCSDTQ-3 TOTAL ENERGY; CCn CORRELATION ENERGY; CCn TOTAL ENERGY; CCn-1a CORRELATION ENERGY; CCn-1a TOTAL ENERGY; CCn-1b CORRELATION ENERGY; CCn-1b TOTAL ENERGY; CCn-3 CORRELATION ENERGY; CCn-3 TOTAL ENERGY; CCnn CORRELATION ENERGY; CCnn TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; MRCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__mrcc.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ-1.html:2383,Deployability,update,updated,2383,"2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY; SOS-OMP3 CORRELATION ENERGY; SOS-OMP3 TOTAL ENERGY; SOS-PI-MP2 CORRELATION ENERGY; SOS-PI-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ-1.html:141,Performance,optimiz,optimized,141,﻿. OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OCC. OCC¶; Performs orbital-optimized MPn and CC computations and conventional MPn computations. CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CUSTOM SCS-LCCD CORRELATION ENERGY; CUSTOM SCS-LCCD TOTAL ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; CUSTOM SCS-MP2.5 CORRELATION ENERGY; CUSTOM SCS-MP2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORREL,MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__occ-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ.html:2383,Deployability,update,updated,2383,"2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY; SOS-OMP3 CORRELATION ENERGY; SOS-OMP3 TOTAL ENERGY; SOS-PI-MP2 CORRELATION ENERGY; SOS-PI-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ.html:141,Performance,optimiz,optimized,141,﻿. OCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OCC. OCC¶; Performs orbital-optimized MPn and CC computations and conventional MPn computations. CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CUSTOM SCS-LCCD CORRELATION ENERGY; CUSTOM SCS-LCCD TOTAL ENERGY; CUSTOM SCS-MP2 CORRELATION ENERGY; CUSTOM SCS-MP2 TOTAL ENERGY; CUSTOM SCS-MP2.5 CORRELATION ENERGY; CUSTOM SCS-MP2.5 TOTAL ENERGY; CUSTOM SCS-MP3 CORRELATION ENERGY; CUSTOM SCS-MP3 TOTAL ENERGY; CUSTOM SCS-OLCCD CORRELATION ENERGY; CUSTOM SCS-OLCCD TOTAL ENERGY; CUSTOM SCS-OMP2 CORRELATION ENERGY; CUSTOM SCS-OMP2 TOTAL ENERGY; CUSTOM SCS-OMP3 CORRELATION ENERGY; CUSTOM SCS-OMP3 TOTAL ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; OLCCD CORRELATION ENERGY; OLCCD OPPOSITE-SPIN CORRELATION ENERGY; OLCCD REFERENCE CORRECTION ENERGY; OLCCD SAME-SPIN CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-MP2-VDW CORRELATION ENERGY; SCS-MP2-VDW TOTAL ENERGY; SCS-MP3 CORRELATION ENERGY; SCS-MP3 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCS-OMP3 CORRELATION ENERGY; SCS-OMP3 TOTAL ENERGY; SOS-MP2 CORREL,MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__occ.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__oeprop-1.html:968,Deployability,update,updated,968,"﻿. OEPROP. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OEPROP. OEPROP¶. CURRENT ENERGY; CURRENT GRADIENT (array); CURRENT HESSIAN (array); ESP AT CENTER n; LOWDIN CHARGES (array); MAYER INDICES (array); MBIS CHARGES (array); MBIS DIPOLES (array); MBIS FREE ATOM n VOLUME; MBIS OCTUPOLES (array); MBIS QUADRUPOLES (array); MBIS VALENCE WIDTHS (array); MBIS VOLUME RATIOS (array); MULLIKEN CHARGES (array); WIBERG LOWDIN INDICES (array); mtd 128-POLE; mtd 128-POLE XXXXXXX; mtd 32-POLE; mtd 32-POLE XXXXX; mtd 32-POLE XXXXY; mtd 64-POLE; mtd 64-POLE XXXXXX; mtd DIPOLE; mtd DIPOLE X; mtd DIPOLE Y; mtd DIPOLE Z; mtd HEXADECAPOLE; mtd HEXADECAPOLE XXXX; mtd OCTUPOLE; mtd OCTUPOLE XXX; mtd QUADRUPOLE; mtd QUADRUPOLE XX. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OEPROP. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__oeprop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__oeprop-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__oeprop.html:968,Deployability,update,updated,968,"﻿. OEPROP. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OEPROP. OEPROP¶. CURRENT ENERGY; CURRENT GRADIENT (array); CURRENT HESSIAN (array); ESP AT CENTER n; LOWDIN CHARGES (array); MAYER INDICES (array); MBIS CHARGES (array); MBIS DIPOLES (array); MBIS FREE ATOM n VOLUME; MBIS OCTUPOLES (array); MBIS QUADRUPOLES (array); MBIS VALENCE WIDTHS (array); MBIS VOLUME RATIOS (array); MULLIKEN CHARGES (array); WIBERG LOWDIN INDICES (array); mtd 128-POLE; mtd 128-POLE XXXXXXX; mtd 32-POLE; mtd 32-POLE XXXXX; mtd 32-POLE XXXXY; mtd 64-POLE; mtd 64-POLE XXXXXX; mtd DIPOLE; mtd DIPOLE X; mtd DIPOLE Y; mtd DIPOLE Z; mtd HEXADECAPOLE; mtd HEXADECAPOLE XXXX; mtd OCTUPOLE; mtd OCTUPOLE XXX; mtd QUADRUPOLE; mtd QUADRUPOLE XX. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OEPROP. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__oeprop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__oeprop.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking-1.html:435,Deployability,update,updated,435,"﻿. OPTKING. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. OPTKING¶; Performs geometry optimizations and vibrational frequency analyses. CURRENT ENERGY; OPTIMIZATION ITERATIONS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking-1.html:154,Performance,optimiz,optimizations,154,"﻿. OPTKING. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. OPTKING¶; Performs geometry optimizations and vibrational frequency analyses. CURRENT ENERGY; OPTIMIZATION ITERATIONS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking.html:435,Deployability,update,updated,435,"﻿. OPTKING. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. OPTKING¶; Performs geometry optimizations and vibrational frequency analyses. CURRENT ENERGY; OPTIMIZATION ITERATIONS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking.html:154,Performance,optimiz,optimizations,154,"﻿. OPTKING. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. OPTKING¶; Performs geometry optimizations and vibrational frequency analyses. CURRENT ENERGY; OPTIMIZATION ITERATIONS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; OPTKING. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__optking.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pcm-1.html:392,Deployability,update,updated,392,"﻿. PCM. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PCM. PCM¶; Performs polarizable continuum model (PCM) computations. PCM POLARIZATION ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PCM. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__pcm-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pcm-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pcm.html:392,Deployability,update,updated,392,"﻿. PCM. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PCM. PCM¶; Performs polarizable continuum model (PCM) computations. PCM POLARIZATION ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PCM. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__pcm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pcm.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pe-1.html:373,Deployability,update,updated,373,"﻿. PE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PE. PE¶; Performs polarizable embedding model (PE) computations. PE ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__pe-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pe-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pe.html:373,Deployability,update,updated,373,"﻿. PE. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PE. PE¶; Performs polarizable embedding model (PE) computations. PE ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__pe.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__pe.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__psimrcc-1.html:567,Deployability,update,updated,567,"﻿. PSIMRCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PSIMRCC. PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. CURRENT ENERGY; MP2-CCSD TOTAL ENERGY; MRCC TOTAL ENERGY; MRPT TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PSIMRCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__psimrcc-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__psimrcc.html:567,Deployability,update,updated,567,"﻿. PSIMRCC. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PSIMRCC. PSIMRCC¶; Performs multireference coupled cluster computations. This theory should be used only by advanced users with a good working knowledge of multireference techniques. CURRENT ENERGY; MP2-CCSD TOTAL ENERGY; MRCC TOTAL ENERGY; MRPT TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; PSIMRCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__psimrcc.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:3227,Deployability,update,updated,3227,"P ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENERGY; SAPT2+3DMP2 EXCH ENERGY; SAPT2+3DMP2 IND ENERGY; SAPT2+3DMP2 TOTAL ENERGY; SAPT2+DMP2 DISP ENERGY; SAPT2+DMP2 ELST ENERGY; SAPT2+DMP2 EXCH ENERGY; SAPT2+DMP2 IND ENERGY; SAPT2+DMP2 TOTAL ENERGY; SSAPT0 DISP ENERGY; SSAPT0 ELST ENERGY; SSAPT0 EXCH ENERGY; SSAPT0 IND ENERGY; SSAPT0 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SAPT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:145,Energy Efficiency,adapt,adapted,145,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SAPT. SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze non-covalent interactions. CURRENT ENERGY; SAPT ALPHA; SAPT CT ENERGY; SAPT DISP ENERGY; SAPT DISP2(CCD) ENERGY; SAPT DISP20 ENERGY; SAPT DISP21 ENERGY; SAPT DISP22(S)(CCD) ENERGY; SAPT DISP22(SDQ) ENERGY; SAPT DISP22(T) ENERGY; SAPT DISP22(T)(CCD) ENERGY; SAPT DISP30 ENERGY; SAPT ELST ENERGY; SAPT ELST10,R ENERGY; SAPT ELST12,R ENERGY; SAPT ELST13,R ENERGY; SAPT ENERGY; SAPT EST.DISP22(T) ENERGY; SAPT EST.DISP22(T)(CCD) ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP30 ENERGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 I",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html:145,Modifiability,adapt,adapted,145,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SAPT. SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze non-covalent interactions. CURRENT ENERGY; SAPT ALPHA; SAPT CT ENERGY; SAPT DISP ENERGY; SAPT DISP2(CCD) ENERGY; SAPT DISP20 ENERGY; SAPT DISP21 ENERGY; SAPT DISP22(S)(CCD) ENERGY; SAPT DISP22(SDQ) ENERGY; SAPT DISP22(T) ENERGY; SAPT DISP22(T)(CCD) ENERGY; SAPT DISP30 ENERGY; SAPT ELST ENERGY; SAPT ELST10,R ENERGY; SAPT ELST12,R ENERGY; SAPT ELST13,R ENERGY; SAPT ENERGY; SAPT EST.DISP22(T) ENERGY; SAPT EST.DISP22(T)(CCD) ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP30 ENERGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 I",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt.html:3227,Deployability,update,updated,3227,"P ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 IND ENERGY; SAPT2+(3)DMP2 TOTAL ENERGY; SAPT2+(CCD) DISP ENERGY; SAPT2+(CCD) ELST ENERGY; SAPT2+(CCD) EXCH ENERGY; SAPT2+(CCD) IND ENERGY; SAPT2+(CCD) TOTAL ENERGY; SAPT2+(CCD)DMP2 DISP ENERGY; SAPT2+(CCD)DMP2 ELST ENERGY; SAPT2+(CCD)DMP2 EXCH ENERGY; SAPT2+(CCD)DMP2 IND ENERGY; SAPT2+(CCD)DMP2 TOTAL ENERGY; SAPT2+3 DISP ENERGY; SAPT2+3 ELST ENERGY; SAPT2+3 EXCH ENERGY; SAPT2+3 IND ENERGY; SAPT2+3 TOTAL ENERGY; SAPT2+3(CCD) DISP ENERGY; SAPT2+3(CCD) ELST ENERGY; SAPT2+3(CCD) EXCH ENERGY; SAPT2+3(CCD) IND ENERGY; SAPT2+3(CCD) TOTAL ENERGY; SAPT2+3(CCD)DMP2 DISP ENERGY; SAPT2+3(CCD)DMP2 ELST ENERGY; SAPT2+3(CCD)DMP2 EXCH ENERGY; SAPT2+3(CCD)DMP2 IND ENERGY; SAPT2+3(CCD)DMP2 TOTAL ENERGY; SAPT2+3DMP2 DISP ENERGY; SAPT2+3DMP2 ELST ENERGY; SAPT2+3DMP2 EXCH ENERGY; SAPT2+3DMP2 IND ENERGY; SAPT2+3DMP2 TOTAL ENERGY; SAPT2+DMP2 DISP ENERGY; SAPT2+DMP2 ELST ENERGY; SAPT2+DMP2 EXCH ENERGY; SAPT2+DMP2 IND ENERGY; SAPT2+DMP2 TOTAL ENERGY; SSAPT0 DISP ENERGY; SSAPT0 ELST ENERGY; SSAPT0 EXCH ENERGY; SSAPT0 IND ENERGY; SSAPT0 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SAPT. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt.html:145,Energy Efficiency,adapt,adapted,145,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SAPT. SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze non-covalent interactions. CURRENT ENERGY; SAPT ALPHA; SAPT CT ENERGY; SAPT DISP ENERGY; SAPT DISP2(CCD) ENERGY; SAPT DISP20 ENERGY; SAPT DISP21 ENERGY; SAPT DISP22(S)(CCD) ENERGY; SAPT DISP22(SDQ) ENERGY; SAPT DISP22(T) ENERGY; SAPT DISP22(T)(CCD) ENERGY; SAPT DISP30 ENERGY; SAPT ELST ENERGY; SAPT ELST10,R ENERGY; SAPT ELST12,R ENERGY; SAPT ELST13,R ENERGY; SAPT ENERGY; SAPT EST.DISP22(T) ENERGY; SAPT EST.DISP22(T)(CCD) ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP30 ENERGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 I",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt.html:145,Modifiability,adapt,adapted,145,"﻿. SAPT. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SAPT. SAPT¶; Performs symmetry adapted perturbation theory (SAPT) analysis to quantitatively analyze non-covalent interactions. CURRENT ENERGY; SAPT ALPHA; SAPT CT ENERGY; SAPT DISP ENERGY; SAPT DISP2(CCD) ENERGY; SAPT DISP20 ENERGY; SAPT DISP21 ENERGY; SAPT DISP22(S)(CCD) ENERGY; SAPT DISP22(SDQ) ENERGY; SAPT DISP22(T) ENERGY; SAPT DISP22(T)(CCD) ENERGY; SAPT DISP30 ENERGY; SAPT ELST ENERGY; SAPT ELST10,R ENERGY; SAPT ELST12,R ENERGY; SAPT ELST13,R ENERGY; SAPT ENERGY; SAPT EST.DISP22(T) ENERGY; SAPT EST.DISP22(T)(CCD) ENERGY; SAPT EXCH ENERGY; SAPT EXCH-DISP20 ENERGY; SAPT EXCH-DISP30 ENERGY; SAPT EXCH-IND-DISP30 ENERGY; SAPT EXCH-IND20,R ENERGY; SAPT EXCH-IND20,U ENERGY; SAPT EXCH-IND22 ENERGY; SAPT EXCH-IND30,R ENERGY; SAPT EXCH10 ENERGY; SAPT EXCH10(S^2) ENERGY; SAPT EXCH11(S^2) ENERGY; SAPT EXCH12(S^2) ENERGY; SAPT HF TOTAL ENERGY; SAPT IND ENERGY; SAPT IND-DISP30 ENERGY; SAPT IND20,R ENERGY; SAPT IND20,U ENERGY; SAPT IND22 ENERGY; SAPT IND30,R ENERGY; SAPT MP2 CORRELATION ENERGY; SAPT SAME-SPIN DISP20 ENERGY; SAPT SAME-SPIN EXCH-DISP20 ENERGY; SAPT TOTAL ENERGY; SAPT0 DISP ENERGY; SAPT0 ELST ENERGY; SAPT0 EXCH ENERGY; SAPT0 IND ENERGY; SAPT0 TOTAL ENERGY; SAPT2 DISP ENERGY; SAPT2 ELST ENERGY; SAPT2 EXCH ENERGY; SAPT2 IND ENERGY; SAPT2 TOTAL ENERGY; SAPT2+ DISP ENERGY; SAPT2+ ELST ENERGY; SAPT2+ EXCH ENERGY; SAPT2+ IND ENERGY; SAPT2+ TOTAL ENERGY; SAPT2+(3) DISP ENERGY; SAPT2+(3) ELST ENERGY; SAPT2+(3) EXCH ENERGY; SAPT2+(3) IND ENERGY; SAPT2+(3) TOTAL ENERGY; SAPT2+(3)(CCD) DISP ENERGY; SAPT2+(3)(CCD) ELST ENERGY; SAPT2+(3)(CCD) EXCH ENERGY; SAPT2+(3)(CCD) IND ENERGY; SAPT2+(3)(CCD) TOTAL ENERGY; SAPT2+(3)(CCD)DMP2 DISP ENERGY; SAPT2+(3)(CCD)DMP2 ELST ENERGY; SAPT2+(3)(CCD)DMP2 EXCH ENERGY; SAPT2+(3)(CCD)DMP2 IND ENERGY; SAPT2+(3)(CCD)DMP2 TOTAL ENERGY; SAPT2+(3)DMP2 DISP ENERGY; SAPT2+(3)DMP2 ELST ENERGY; SAPT2+(3)DMP2 EXCH ENERGY; SAPT2+(3)DMP2 I",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__sapt.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__scf-1.html:1284,Deployability,update,updated,1284,"﻿. SCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SCF. SCF¶; Performs self consistent field (Hartree-Fock and Density Functional Theory) computations. These are the starting points for most computations, so this code is called in most cases. DFT FUNCTIONAL TOTAL ENERGY; DFT TOTAL ENERGY; DFT TOTAL GRADIENT; DFT VV10 ENERGY; DFT XC ENERGY; DISPERSION CORRECTION ENERGY; DOUBLE-HYBRID CORRECTION ENERGY; GRID ELECTRONS ALPHA; GRID ELECTRONS BETA; GRID ELECTRONS TOTAL; HF TOTAL ENERGY; HF TOTAL GRADIENT; HF TOTAL HESSIAN; NUCLEAR REPULSION ENERGY; ONE-ELECTRON ENERGY; SCF ITERATIONS; SCF STABILITY EIGENVALUES (array); SCF TOTAL ENERGY; SCF TOTAL GRADIENT; TD-fctl ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY; TD-fctl ROOT n TOTAL ENERGY - h SYMMETRY; TWO-ELECTRON ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__scf-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__scf.html:1284,Deployability,update,updated,1284,"﻿. SCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SCF. SCF¶; Performs self consistent field (Hartree-Fock and Density Functional Theory) computations. These are the starting points for most computations, so this code is called in most cases. DFT FUNCTIONAL TOTAL ENERGY; DFT TOTAL ENERGY; DFT TOTAL GRADIENT; DFT VV10 ENERGY; DFT XC ENERGY; DISPERSION CORRECTION ENERGY; DOUBLE-HYBRID CORRECTION ENERGY; GRID ELECTRONS ALPHA; GRID ELECTRONS BETA; GRID ELECTRONS TOTAL; HF TOTAL ENERGY; HF TOTAL GRADIENT; HF TOTAL HESSIAN; NUCLEAR REPULSION ENERGY; ONE-ELECTRON ENERGY; SCF ITERATIONS; SCF STABILITY EIGENVALUES (array); SCF TOTAL ENERGY; SCF TOTAL GRADIENT; TD-fctl ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY; TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY; TD-fctl ROOT n TOTAL ENERGY - h SYMMETRY; TWO-ELECTRON ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; SCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__scf.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__thermo-1.html:468,Deployability,update,updated,468,"﻿. THERMO. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; THERMO. THERMO¶. ENTHALPY; ENTHALPY CORRECTION; GIBBS FREE ENERGY; GIBBS FREE ENERGY CORRECTION; THERMAL ENERGY; THERMAL ENERGY CORRECTION; ZERO K ENTHALPY; ZPVE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; THERMO. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__thermo-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__thermo-1.html
https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__thermo.html:468,Deployability,update,updated,468,"﻿. THERMO. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; THERMO. THERMO¶. ENTHALPY; ENTHALPY CORRECTION; GIBBS FREE ENERGY; GIBBS FREE ENERGY CORRECTION; THERMAL ENERGY; THERMAL ENERGY CORRECTION; ZERO K ENTHALPY; ZPVE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; THERMO. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/autodir_psivariables/module__thermo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__thermo.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html:4768,Deployability,update,updated,4768,"> str:; r""""""Form a printable representation of qcvariables. Parameters; ----------; qcvars; Group of Datum objects to print. Returns; -------; str; Printable string representation of label, data, and unit in Datum-s. """"""; text = [""\n Variable Map:"", "" ----------------------------------------------------------------------------""]. if len(qcvars) == 0:; text.append("" (none)""); return ""\n"".join(text). largest_key = max(len(k) for k in qcvars) + 2 # for quotation marks; largest_characteristic = 8; for k, v in qcvars.items():; try:; exp = int(str(v.data).split(""E"")[1]); except IndexError:; pass; else:; largest_characteristic = max(exp, largest_characteristic). for k, qca in sorted(qcvars.items()):; # if k != qca.lbl:; # raise ValidationError('Huh? {} != {}'.format(k, qca.label)). if isinstance(qca.data, np.ndarray):; data = np.array_str(qca.data, max_line_width=120, precision=8, suppress_small=True); data = ""\n"".join("" "" + ln for ln in data.splitlines()); text.append(; """""" {:{keywidth}} => {:{width}} [{}]"""""".format(; '""' + k + '""', """", qca.units, keywidth=largest_key, width=largest_characteristic + 14; ); ); text.append(data); elif isinstance(qca.data, Decimal):; text.append(; """""" {:{keywidth}} => {:{width}} [{}]"""""".format(; '""' + k + '""', qca.data, qca.units, keywidth=largest_key, width=largest_characteristic + 14; ); ); elif not qca.numeric:; text.append(; """""" {:{keywidth}} => {:>{width}} [{}]"""""".format(; '""' + k + '""', str(qca.data), qca.units, keywidth=largest_key, width=largest_characteristic + 14; ); ); else:; text.append(; """""" {:{keywidth}} => {:{width}.{prec}f} [{}]"""""".format(; '""' + k + '""', qca.data, qca.units, keywidth=largest_key, width=largest_characteristic + 14, prec=12; ); ). text.append(""""); return ""\n"".join(text). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.datum. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/datum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html:298,Security,validat,validator,298,"﻿. qcelemental.datum. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.datum. Source code for qcelemental.datum; """"""; Datum Object Model; """""". from decimal import Decimal; from typing import Any, Dict, Optional. import numpy as np; from pydantic import BaseModel, validator. [docs]class Datum(BaseModel):; r""""""Facilitates the storage of quantum chemical results by labeling them with basic metadata. Attributes; ----------; label : str; Official label for `data`, often qcvar. May contain spaces.; units : str; ASCII, LaTeX-like representation of units, without square brackets.; data : float or decimal.Decimal or numpy.ndarray; Value for `label`.; comment : str; Additional notes.; doi : str; Literature citation or definition DOI link.; glossary : str; Extended description or definition.; numeric : bool; Whether `data` is numeric. Pass `True` to disable validating `data` as float/Decimal/np.ndarray. """""". numeric: bool; label: str; units: str; data: Any; comment: str = """"; doi: Optional[str] = None; glossary: str = """". class Config:; extra = ""forbid""; allow_mutation = False; json_encoders = {np.ndarray: lambda v: v.flatten().tolist(), complex: lambda v: (v.real, v.imag)}. def __init__(self, label, units, data, *, comment=None, doi=None, glossary=None, numeric=True):; kwargs = {""label"": label, ""units"": units, ""data"": data, ""numeric"": numeric}; if comment is not None:; kwargs[""comment""] = comment; if doi is not None:; kwargs[""doi""] = doi; if glossary is not None:; kwargs[""glossary""] = glossary. super().__init__(**kwargs). @validator(""data""); def must_be_numerical(cls, v, values, **kwargs):; try:; 1.0 * v; except TypeError:; try:; Decimal(""1.0"") * v; except TypeError:; if values[""numeric""]:; raise ValueError(f""Datum data should be float, Decimal, or np.ndarray, not {type(v)}.""); else:; values[""numeric""] = True; else:; values[""numeric""] = True. return v. def __str__(self, label=""""):; width = 40; text = [""-"" * width, ""{:^{width}}"".format(""Datum """,MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/datum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html:893,Security,validat,validating,893,"﻿. qcelemental.datum. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.datum. Source code for qcelemental.datum; """"""; Datum Object Model; """""". from decimal import Decimal; from typing import Any, Dict, Optional. import numpy as np; from pydantic import BaseModel, validator. [docs]class Datum(BaseModel):; r""""""Facilitates the storage of quantum chemical results by labeling them with basic metadata. Attributes; ----------; label : str; Official label for `data`, often qcvar. May contain spaces.; units : str; ASCII, LaTeX-like representation of units, without square brackets.; data : float or decimal.Decimal or numpy.ndarray; Value for `label`.; comment : str; Additional notes.; doi : str; Literature citation or definition DOI link.; glossary : str; Extended description or definition.; numeric : bool; Whether `data` is numeric. Pass `True` to disable validating `data` as float/Decimal/np.ndarray. """""". numeric: bool; label: str; units: str; data: Any; comment: str = """"; doi: Optional[str] = None; glossary: str = """". class Config:; extra = ""forbid""; allow_mutation = False; json_encoders = {np.ndarray: lambda v: v.flatten().tolist(), complex: lambda v: (v.real, v.imag)}. def __init__(self, label, units, data, *, comment=None, doi=None, glossary=None, numeric=True):; kwargs = {""label"": label, ""units"": units, ""data"": data, ""numeric"": numeric}; if comment is not None:; kwargs[""comment""] = comment; if doi is not None:; kwargs[""doi""] = doi; if glossary is not None:; kwargs[""glossary""] = glossary. super().__init__(**kwargs). @validator(""data""); def must_be_numerical(cls, v, values, **kwargs):; try:; 1.0 * v; except TypeError:; try:; Decimal(""1.0"") * v; except TypeError:; if values[""numeric""]:; raise ValueError(f""Datum data should be float, Decimal, or np.ndarray, not {type(v)}.""); else:; values[""numeric""] = True; else:; values[""numeric""] = True. return v. def __str__(self, label=""""):; width = 40; text = [""-"" * width, ""{:^{width}}"".format(""Datum """,MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/datum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html:1573,Security,validat,validator,1573,"s.; data : float or decimal.Decimal or numpy.ndarray; Value for `label`.; comment : str; Additional notes.; doi : str; Literature citation or definition DOI link.; glossary : str; Extended description or definition.; numeric : bool; Whether `data` is numeric. Pass `True` to disable validating `data` as float/Decimal/np.ndarray. """""". numeric: bool; label: str; units: str; data: Any; comment: str = """"; doi: Optional[str] = None; glossary: str = """". class Config:; extra = ""forbid""; allow_mutation = False; json_encoders = {np.ndarray: lambda v: v.flatten().tolist(), complex: lambda v: (v.real, v.imag)}. def __init__(self, label, units, data, *, comment=None, doi=None, glossary=None, numeric=True):; kwargs = {""label"": label, ""units"": units, ""data"": data, ""numeric"": numeric}; if comment is not None:; kwargs[""comment""] = comment; if doi is not None:; kwargs[""doi""] = doi; if glossary is not None:; kwargs[""glossary""] = glossary. super().__init__(**kwargs). @validator(""data""); def must_be_numerical(cls, v, values, **kwargs):; try:; 1.0 * v; except TypeError:; try:; Decimal(""1.0"") * v; except TypeError:; if values[""numeric""]:; raise ValueError(f""Datum data should be float, Decimal, or np.ndarray, not {type(v)}.""); else:; values[""numeric""] = True; else:; values[""numeric""] = True. return v. def __str__(self, label=""""):; width = 40; text = [""-"" * width, ""{:^{width}}"".format(""Datum "" + self.label, width=width)]; if label:; text.append(""{:^{width}}"".format(label, width=width)); text.append(""-"" * width); text.append(""Data: {}"".format(self.data)); text.append(""Units: [{}]"".format(self.units)); text.append(""doi: {}"".format(self.doi)); text.append(""Comment: {}"".format(self.comment)); text.append(""Glossary: {}"".format(self.glossary)); text.append(""-"" * width); return ""\n"".join(text). def dict(self, *args, **kwargs):; return super().dict(*args, **{**kwargs, **{""exclude_unset"": True}}). def to_units(self, units=None):; from .physical_constants import constants. to_unit = self.units if unit",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/datum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:1061,Availability,error,error,1061,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:1278,Availability,error,error,1278,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:1699,Deployability,update,updated,1699,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:452,Integrability,message,message,452,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:680,Integrability,message,message,680,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:900,Integrability,message,message,900,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:1067,Integrability,message,message,1067,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:1144,Integrability,message,message,1144,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:1284,Integrability,message,message,1284,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html:1436,Integrability,message,message,1436,"﻿. qcelemental.exceptions. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. Source code for qcelemental.exceptions; """"""; Exceptions for QCElemental; """""". class NotAnElementError(Exception):; """"""Error when element or nuclide can't be identified."""""". def __init__(self, atom, strict=False):; if strict:; msg = ""atomic number or element""; else:; msg = ""atomic number, element symbol, or nuclide symbol""; self.message = f""Atom identifier ({atom}) uninterpretable as {msg}"". class DataUnavailableError(Exception):; """"""Error when dataset incomplete and otherwise valid query can't be fulfilled."""""". def __init__(self, dataset, atom):; self.message = ""Dataset ({}) missing value for key ({})"".format(dataset, atom). class MoleculeFormatError(Exception):; """"""Error called when a molparse.from_string contains unparsable lines."""""". def __init__(self, msg):; self.message = ""Molecule line uninterpretable: {}"".format(msg). [docs]class ValidationError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """""". def __init__(self, msg):; self.message = ""Input Error: {}"".format(msg). class ChoicesError(Exception):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. Also attaches; `choices` dictionary with options to proceed. """""". def __init__(self, msg, choices=None):; self.message = ""Input Error: {}"".format(msg); self.choices = {} if choices is None else choices. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/qcelemental/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:1492,Deployability,integrat,integrated,1492,"/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:7374,Deployability,update,updated,7374,"; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs['delta2_basis'] = kwargs.get('delta2_basis', 'cc-pV[56]Z'); kwargs['delta2_scheme'] = kwargs.get('delta2_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSDT - CCSD(T); kwargs['delta3_wfn'] = kwargs.get('delta3_wfn', 'mrccsdt'); kwargs['delta3_wfn_lesser'] = kwargs.get('delta3_wfn_lesser', 'mrccsd(t)'); kwargs['delta3_basis'] = kwargs.get('delta3_basis', 'cc-pVTZ'); kwargs['delta3_scheme'] = kwargs.get('delta3_scheme', driver_cbs.xtpl_highest_1). # delta CCSDT(Q) - CCSDT; kwargs['delta4_wfn'] = kwargs.get('delta4_wfn', 'mrccsdt(q)'); kwargs['delta4_wfn_lesser'] = kwargs.get('delta4_wfn_lesser', 'mrccsdt'); kwargs['delta4_basis'] = kwargs.get('delta4_basis', 'cc-pVDZ'); kwargs['delta4_scheme'] = kwargs.get('delta4_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Allen Focal Point'; return driver_cbs.cbs(func, label, **kwargs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.aliases. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:1515,Energy Efficiency,energy,energy,1515,"/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:2918,Energy Efficiency,energy,energy,2918,"le. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:3238,Energy Efficiency,energy,energy,3238,"with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sher",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:3275,Energy Efficiency,energy,energy,3275,"with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sher",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:5313,Energy Efficiency,energy,energy,5313," [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:5350,Energy Efficiency,energy,energy,5350," [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:1197,Integrability,wrap,wrappers,1197,"es; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:1492,Integrability,integrat,integrated,1492,"/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:1530,Integrability,rout,routines,1530,"; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:4825,Integrability,wrap,wrapper,4825,"pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:2926,Performance,perform,performed,2926,"le. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:3346,Performance,optimiz,optimization,3346,"nge(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_foca",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:3364,Performance,optimiz,optimize,3364,"nge(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_foca",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:3437,Performance,optimiz,optimization,3437," at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:3516,Performance,optimiz,optimize,3516," at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:4701,Performance,perform,performed,4701,"s.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:5416,Performance,optimiz,optimization,5416,"nalysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs['delta2_basis'] = kwargs.get('delta2_basis', 'cc-pV[56]Z'); kwargs['delta2_scheme'] = kwargs.get('delta2",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:5457,Performance,optimiz,optimize,5457,"nalysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs['delta2_basis'] = kwargs.get('delta2_basis', 'cc-pV[56]Z'); kwargs['delta2_scheme'] = kwargs.get('delta2",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:1296,Usability,simpl,simple,1296,"4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:3242,Availability,avail,available,3242,"nerates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rval",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:7135,Deployability,install,installed,7135,"MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:10131,Deployability,update,updated,10131,"([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np.linspace(minR, maxR, 1000); xrel = xpts - re; xpows = xrel[:, None] ** range(5); fit2 = np.einsum('xd,d', xpows[:,0:3], dvals[0:3]); fit4 = np.einsum('xd,d', xpows, dvals). # Make / display the plot; plt.plot(xpts, fit2, 'b', linewidth=2.5, label='Harmonic (quadratic) fit'); plt.plot(xpts, fit4, 'g', linewidth=2.5, label='Anharmonic (quartic) fit'); plt.plot([re, re], [minE, maxE], 'b--', linewidth=0.5); plt.plot([r0, r0], [minE, maxE], 'g--', linewidth=0.5); plt.scatter(rvals, energies, c='Black', linewidth=3, label='Input Data'); plt.legend(). plt.xlabel('Bond length (Angstroms)'); plt.ylabel('Energy (Eh)'); plt.xlim(minR, maxR); plt.ylim(minE, maxE); if plot_fit == 'screen':; plt.show(); else:; plt.savefig(plot_fit); core.print_out(""\n\tPES fit saved to %s.\n\n"" % plot_fit). core.print_out(""\nre = %10.6f A check: %10.6f\n"" % (re, recheck)); core.print_out(""r0 = %10.6f A\n"" % r0); core.print_out(""E at re = %17.10f Eh\n"" % e); core.print_out(""we = %10.4f cm-1\n"" % we); core.print_out(""wexe = %10.4f cm-1\n"" % wexe); core.print_out(""nu = %10.4f cm-1\n"" % nu); core.print_out(""ZPVE(we) = %10.4f cm-1\n"" % zpve_we); core.print_out(""ZPVE(nu) = %10.4f cm-1\n"" % zpve_nu); core.print_out(""Be = %10.4f cm-1\n"" % B); core.print_out(""B0 = %10.4f cm-1\n"" % B0); core.print_out(""ae = %10.4f cm-1\n"" % ae); core.print_out(""De = %10.7f cm-1\n"" % de); results = {; ""re"" : re,; ""r0"" : r0,; ""we"" : we,; ""wexe"" : wexe,; ""nu"" : nu,; ""E(re)"" : e,; ""ZPVE(harmonic)"" : zpve_we,; ""ZPVE(anharmonic)"" : zpve_nu,; ""Be"" : B,; ""B0"" : B0,; ""ae"" : ae,; ""De"" : de; }; return results. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.diatomic. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:2241,Energy Efficiency,energy,energy,2241,"ast_squares_fit_polynomial(xvals, fvals, localization_point, no_factorials=True, weighted=True, polynomial_order=4):; """"""Performs and unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals: List, energies: List, plot_fit: str = '', mol = None) -> Dict:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:2379,Energy Efficiency,energy,energy,2379,"a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals: List, energies: List, plot_fit: str = '', mol = None) -> Dict:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supp",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:3209,Energy Efficiency,energy,energy,3209,"nerates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rval",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:5494,Energy Efficiency,energy,energy,5494,"le.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifu",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:5624,Energy Efficiency,energy,energy,5624,"rgies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (pl",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:7399,Energy Efficiency,energy,energy,7399,"meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:7527,Energy Efficiency,energy,energy,7527,"((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (plus re check using Be); B0 = B - ae / 2.0; r0 = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B0)); recheck = np.sqrt(constants.h / (8.0 * np.pi**2 * mu * constants.c * B)); r0 /= angstrom_to_meter; recheck /= angstrom_to_meter. # Fundamental frequency nu; nu = we - 2.0 * wexe; zpve_nu = 0.5 * we - 0.25 * wexe; zpve_we = 0.5 * we. # Generate pretty pictures, if requested; if(plot_fit):; try:; import matplotlib.pyplot as plt; except ImportError:; msg = ""\n\tPlot not generated; matplotlib is not installed on this machine.\n\n""; print(msg); core.print_out(msg). # Correct the derivatives for the missing factorial prefactors; dvals = np.zeros(5); dvals[0:5] = derivs[0:5]; dvals[2] /= 2; dvals[3] /= 6; dvals[4] /= 24. # Default plot range, before considering energy levels; minE = np.min(energies); maxE = np.max(energies); minR = np.min(rvals); maxR = np.max(rvals). # Plot vibrational energy levels; we_au = we / constants.hartree2wavenumbers; wexe_au = wexe / constants.hartree2wavenumbers; coefs2 = [ dvals[2], dvals[1], dvals[0] ]; coefs4 = [ dvals[4], dvals[3], dvals[2], dvals[1], dvals[0] ]; for n in range(3):; Eharm = we_au*(n+0.5); Evpt2 = Eharm - wexe_au*(n+0.5)**2; coefs2[-1] = -Eharm; coefs4[-1] = -Evpt2; roots2 = np.roots(coefs2); roots4 = np.roots(coefs4); xvals2 = roots2 + re; xvals4 = np.choose(np.where(np.isreal(roots4)), roots4)[0].real + re; Eharm += dvals[0]; Evpt2 += dvals[0]; plt.plot(xvals2, [Eharm, Eharm], 'b', linewidth=1); plt.plot(xvals4, [Evpt2, Evpt2], 'g', linewidth=1); maxE = Eharm; maxR = np.max([xvals2,xvals4]); minR = np.min([xvals2,xvals4]). # Find ranges for the plot; dE = maxE - minE; minE -= 0.2*dE; maxE += 0.4*dE; dR = maxR - minR; minR -= 0.2*dR; maxR += 0.2*dR. # Generate the fitted PES; xpts = np.linspace(minR, maxR, 1000); xrel = xpts - re; xpows = xrel[:, None] ** range(5); fit2 = np.einsum('xd,d', xpows[:,0:3], dvals[0:3]); fit4 = np.e",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:5344,Performance,optimiz,optimization,5344,"t_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:1141,Availability,avail,available,1141,"hemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import json; import os; import re; import shutil; import sys; from typing import Union. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:2073,Availability,avail,available,2073,"# @END LICENSE; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import json; import os; import re; import shutil; import sys; from typing import Union. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = use",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:4184,Availability,avail,available,4184,"d (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _process_displacement(derivfunc, method, molecule, displacement, n, ndisp, **kwargs):; """"""A helper function to perform all processing for an individual f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:35719,Availability,avail,available,35719,"ures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:; core.set_local_option('SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:36687,Availability,checkpoint,checkpoint,36687," if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:; core.set_local_option('SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:40501,Availability,avail,avail,40501,"op('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary o",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41162,Availability,avail,avail,41162,"pe='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereaft",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:54798,Availability,avail,available,54798," 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an op",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61474,Availability,avail,available,61474,"optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61935,Availability,avail,available,61935,"p_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` |; +-------------------------+--------------------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83416,Availability,avail,available,83416,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83477,Availability,avail,available,83477,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83945,Availability,avail,available,83945,"ates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:84061,Availability,avail,availability,84061,"gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:84701,Availability,avail,available,84701,"irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs); ; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hes",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:92273,Availability,checkpoint,checkpoint,92273,"le_prefix(wfn.molecule().name()) + "".hess""; with open(filename, 'wb') as handle:; qcdb.hessparse.to_string(np.asarray(wfn.hessian()), handle, dtype='psi4'). [docs]def gdma(wfn, datafile=""""):; """"""Function to use wavefunction information in *wfn* and, if specified,; additional commands in *filename* to run GDMA analysis. .. versionadded:: 0.6. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate DMA analysis. :type datafile: str; :param datafile: optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, the File keyword must be set to read; a filename.fchk, where filename is provided by :term:`WRITER_FILE_LABEL <WRITER_FILE_LABEL (GLOBALS)>` . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:22711,Deployability,configurat,configuration,22711,"------------------+---------------------------------------------------------------------------------------------------------------+; | fno-ccsd(t) | CCSD(T) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cc3 | approximate CC singles, doubles, and triples (CC3) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccenergy | **expert** full control over ccenergy module |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dfocc | **expert** full control over dfocc module |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) :ref:`[manual] <sec:ci>` :ref:`[details] <tlcisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` |; +-----------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:23848,Deployability,configurat,configuration,23848,"----------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | casscf | complete active space self consistent field (CASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | rasscf | restricted active space self consistent field (RASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mcscf | multiconfigurational self consistent field (SCF) :ref:`[manual] <sec:psimrcc>` |; +-------------------------+-----------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:32162,Deployability,release,released,32162,"-+---------------------------------------------------------------------------------------------------------------+; | adc | 2nd-order algebraic diagrammatic construction (ADC) :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-cc2 | EOM-CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment a certain isapt --- marginally released; .. comment mrcc --- this is handled in its own table; .. comment psimrcc_scf --- convenience fn. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:49423,Deployability,configurat,configurational,49423,"-----------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | adc(0), adc(1), | Algebraic-diagrammatic construction methods | RHF/UHF | dipole, transition_dipole, oscillator_strength, |; | ..., adc(3), | :ref:`[manual] <sec:adc>` | | rotational_strength |; | cvs-adc(0), ... | | | |; | cvs-adc(3) | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+. :type name: str; :param name: ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type properties: List[str]; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. Defaults to dipole and quadrupole. :type molecule: :ref:`molecule <op_py_molecule>`; :param mole",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:51949,Deployability,install,installing,51949," = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.varia",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:51971,Deployability,install,install,51971," = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.varia",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:52013,Deployability,install,install,52013," = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.varia",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:89160,Deployability,update,update,89160,"trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:89901,Deployability,update,update,89901,"ol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, ind",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:102573,Deployability,update,updated,102573," = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:2811,Energy Efficiency,energy,energy,2811,"si4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in pr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:3837,Energy Efficiency,energy,energy,3837,":; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTER",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:3968,Energy Efficiency,energy,energy,3968,"ce(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projec",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:6970,Energy Efficiency,energy,energy,6970,"creen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n, ndisp)); print("""""" %d"""""" % (n), end=('\n' if (n == ndisp) else '')); sys.stdout.flush(). parent_group = molecule.point_group(); clone = molecule.clone(); clone.reinterpret_coordentry(False); clone.fix_orientation(True). # Load in displacement (flat list) into the active molecule; geom_array = np.reshape(displacement[""geometry""], (-1, 3)); clone.set_geometry(core.Matrix.from_array(geom_array)). # If the user insists on symmetry, weaken it if some is lost when displacing.; if molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CUR",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:7524,Energy Efficiency,energy,energy,7524,"= parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:7601,Energy Efficiency,energy,energy,7601,"= parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:7651,Energy Efficiency,energy,energy,7651,"ts_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |d",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:7701,Energy Efficiency,energy,energy,7701,"(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn con",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:7773,Energy Efficiency,energy,energy,7773,"ifferent from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour|",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:8519,Energy Efficiency,energy,energy,8519,"laced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Turns writing the orbitals after the converged SCF on/off.; Orbital file will be deleted unless |PSIfour| is called with `-m` flag. :type restart_file: str; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Existing files to be renamed and copied for calculation restart, e.g. a serialized wfn or module-specific binary data. .. _`table:energy_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+====================================================================================================",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:25900,Energy Efficiency,adapt,adapted,25900,"---------------------------------------+; | psimrcc | Mukherjee multireference coupled cluster (Mk-MRCC) :ref:`[manual] <sec:psimrcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dmrg-scf | density matrix renormalization group SCF :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dmrg-caspt2 | density matrix renormalization group CASPT2 :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dmrg-ci | density matrix renormalization group CI :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt0 | 0th-order symmetry adapted perturbation theory (SAPT) :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ssapt0 | 0th-order SAPT with special exchange scaling :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fisapt0 | 0th-order functional and/or intramolecular SAPT :ref:`[manual] <sec:fisapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2 | 2nd-order SAPT, traditional definition :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+ | SAPT including all 2nd-order terms :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:29599,Energy Efficiency,charge,charge,29599,p2 | SAPT including all 3rd-order terms and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+(ccd)dmp2 | SAPT2+ with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+(3)(ccd)dmp2 | SAPT2+(3) with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+3(ccd)dmp2 | SAPT2+3 with CC-based dispersion and MP2 correction :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt0-ct | 0th-order SAPT plus charge transfer (CT) calculation :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2-ct | SAPT2 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+-ct | SAPT2+ plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+(3)-ct | SAPT2+(3) plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+3-ct | SAPT2+3 plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+--------------------------------------------------------------------------------------------------,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:32471,Energy Efficiency,energy,energy,32471,"---------------------------------------------------+; | eom-cc2 | EOM-CC2 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment a certain isapt --- marginally released; .. comment mrcc --- this is handled in its own table; .. comment psimrcc_scf --- convenience fn. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:32703,Energy Efficiency,energy,energy,32703,"------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment a certain isapt --- marginally released; .. comment mrcc --- this is handled in its own table; .. comment psimrcc_scf --- convenience fn. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:32770,Energy Efficiency,energy,energy,32770,">` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. comment missing and why; .. comment a certain isapt --- marginally released; .. comment mrcc --- this is handled in its own table; .. comment psimrcc_scf --- convenience fn. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for mo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33087,Energy Efficiency,energy,energy,33087,"--------------------+. .. comment missing and why; .. comment a certain isapt --- marginally released; .. comment mrcc --- this is handled in its own table; .. comment psimrcc_scf --- convenience fn. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33205,Energy Efficiency,energy,energy,33205,"s own table; .. comment psimrcc_scf --- convenience fn. .. include:: /autodoc_dft_energy.rst. .. include:: /mrcc_table_energy.rst. .. include:: /cfour_table_energy.rst. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nb",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33397,Energy Efficiency,energy,energy,33397,">>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), pty",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33434,Energy Efficiency,energy,energy,33434,">>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), pty",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33542,Energy Efficiency,energy,energy,33542," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33790,Energy Efficiency,energy,energy,33790,">> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34230,Energy Efficiency,energy,energy,34230,"# [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.Options",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34251,Energy Efficiency,energy,energy,34251,"# [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.Options",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34344,Energy Efficiency,energy,energy,34344,"irst one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34399,Energy Efficiency,energy,energy,34399,"sd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34691,Energy Efficiency,energy,energy,34691," See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] #",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34712,Energy Efficiency,energy,energy,34712," See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] #",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34757,Energy Efficiency,energy,energy,34757,"e examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific ac",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34802,Energy Efficiency,energy,energy,34802,"[d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; rest",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:35077,Energy Efficiency,energy,energy,35077,"_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:35182,Energy Efficiency,energy,energy,35182,"; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; # DGAS Note: This is hacked together at this point and should be revamped.; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if not isinstance(restartfile, (list, tuple)):; restartfile = (restartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; is_numpy_file = (os.path.isfile(item) and item.endswith("".npy"")) or os.path.isfile(item + "".npy""); name_split = re.split(r'\.', item); if is_numpy_file:; core.set_local_option('SCF', 'GUESS' ,'READ'); core.print_out("" Found user provided orbital data. Setting",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37128,Energy Efficiency,energy,energy,37128,"_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37216,Energy Efficiency,energy,energy,37216,"path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~p",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37350,Energy Efficiency,energy,energy,37350,"shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37372,Energy Efficiency,energy,energy,37372,"plit('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradie",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:39401,Energy Efficiency,energy,energy,39401,"tion`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:39698,Energy Efficiency,energy,energy,39698,"_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:40021,Energy Efficiency,energy,energy,40021,"function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:40658,Energy Efficiency,energy,energy,40658,"ssuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41321,Energy Efficiency,energy,energy,41321,"; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41407,Energy Efficiency,energy,energy,41407," CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42004,Energy Efficiency,energy,energy,42004,"method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42090,Energy Efficiency,energy,energy,42090,"dient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:43379,Energy Efficiency,energy,energy,43379,"D.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:43706,Energy Efficiency,energy,energy,43706,"computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). opt",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44219,Energy Efficiency,energy,energy,44219,"energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not ye",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44288,Energy Efficiency,energy,energy,44288,".."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44635,Energy Efficiency,energy,energy,44635,"nt in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +==========",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44712,Energy Efficiency,energy,energy,44712,"cess_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+===============",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44955,Energy Efficiency,energy,energy,44955,"DIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44966,Energy Efficiency,energy,energy,44966,"if.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+--------------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:52126,Energy Efficiency,energy,energy,52126,"erties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if ret",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:53028,Energy Efficiency,energy,energy,53028,"eometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.get('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58746,Energy Efficiency,energy,energy,58746,"nvergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the co",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59265,Energy Efficiency,energy,energy,59265," step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tupl",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59372,Energy Efficiency,energy,energy,59372,"timizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59870,Energy Efficiency,energy,energy,59870,"if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60248,Energy Efficiency,energy,energy,60248," :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; I",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61000,Energy Efficiency,energy,energy,61000,"target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in th",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61139,Energy Efficiency,energy,energy,61139,"e :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61432,Energy Efficiency,energy,energy,61432,"tionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:62022,Energy Efficiency,energy,energy,62022,"dicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dct | dens",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66793,Energy Efficiency,energy,energy,66793,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66855,Energy Efficiency,energy,energy,66855,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70259,Energy Efficiency,energy,energy,70259,"art """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70277,Energy Efficiency,energy,energy,70277,"art """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70361,Energy Efficiency,energy,energy,70361,"ully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70650,Energy Efficiency,energy,energy,70650,"get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optkin",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:71925,Energy Efficiency,energy,energy,71925,"ss_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object()",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:73023,Energy Efficiency,energy,energy,73023,"rgy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == Fal",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:76868,Energy Efficiency,energy,energy,76868,"l"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(; """"""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_proj",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:76959,Energy Efficiency,energy,energy,76959,"ame.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(; """"""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:78444,Energy Efficiency,energy,energy,78444,"f_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacemen",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:78556,Energy Efficiency,energy,energy,78556,"(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # R",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:78606,Energy Efficiency,energy,energy,78606,"ations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:79917,Energy Efficiency,energy,energy,79917,"rojection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _pr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:79994,Energy Efficiency,energy,energy,79994,"NT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80071,Energy Efficiency,energy,energy,80071,"""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, di",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80363,Energy Efficiency,energy,energy,80363,"e', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80499,Energy Efficiency,energy,energy,80499,"isplacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80925,Energy Efficiency,energy,energy,80925,"Y', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational freq",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81148,Energy Efficiency,energy,energy,81148,"re(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wf",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81521,Energy Efficiency,energy,energy,81521,"owername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wf",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81598,Energy Efficiency,energy,energy,81598,"ndif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` ||",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81675,Energy Efficiency,energy,energy,81675,"rrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82044,Energy Efficiency,energy,energy,82044,"(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82128,Energy Efficiency,energy,energy,82128,"t(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nest",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82726,Energy Efficiency,energy,energy,82726,"l_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrd",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82914,Energy Efficiency,energy,energy,82914,"ef frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83053,Energy Efficiency,energy,energy,83053,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83374,Energy Efficiency,energy,energy,83374,"hod; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:89884,Energy Efficiency,energy,energy,89884," = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sor",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:94841,Energy Efficiency,energy,energy,94841,"hk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFM",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:96606,Energy Efficiency,energy,energy,96606,"ry module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; varlist = core.scalar_variables(); current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:96825,Energy Efficiency,energy,energy,96825,"rgies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; varlist = core.scalar_variables(); current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:97019,Energy Efficiency,reduce,reduced,97019,"t_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; varlist = core.scalar_variables(); current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:97960,Energy Efficiency,energy,energy,97960,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:98426,Energy Efficiency,energy,energy,98426,"ls:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbital",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:99413,Energy Efficiency,energy,energy,99413,"n addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:99988,Energy Efficiency,energy,energy,99988,"nsity_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. 1. Molden file with the Kohn-Sham orbitals of a DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 4. Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO). >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_V",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:100361,Energy Efficiency,energy,energy,100361,"DFT calculation. >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 2. Molden file for CI/MCSCF computation using NO roots.; Any method returning a ``CIWavefunction`` object will work: ``detci``,; ``fci``, ``casscf``, etc. The first two arguments of ``get_opdm`` can be; set to ``n, n`` where n => 0 selects the root to write out, provided; these roots were computed, see :term:`NUM_ROOTS <NUM_ROOTS (DETCI)>`. The; third argument controls the spin (``""A""``, ``""B""`` or ``""SUM""``) and the final; boolean option determines whether inactive orbitals are included. >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). 3. The following produces **an INCORRECT Molden file**, because the; ``molden`` function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point. >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 4. Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO). >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:1852,Integrability,wrap,wrappers,1852,"should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import json; import os; import re; import shutil; import sys; from typing import Union. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:3384,Integrability,rout,routing,3384,"ive; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:3573,Integrability,rout,routing,3573,"_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:39346,Integrability,wrap,wrappers,39346,"tion`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41265,Integrability,depend,dependent,41265,"; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41948,Integrability,depend,dependent,41948,"method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:54835,Integrability,interface,interface,54835," 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an op",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:67816,Integrability,wrap,wrappers,67816," energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:69395,Integrability,depend,dependent,69395,"essian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); #",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:75437,Integrability,wrap,wrappers,75437,"an in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'. elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Call appropriate wrappers; if gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(hessian, name.lower(), ptype='hessian', **kwargs); # Check if this is a CBS extrapolation; elif gradient_type == ""cbs_gufunc"":; return driver_cbs._cbs_gufunc(hessian, name.lower(), **kwargs, ptype=""hessian""); elif gradient_type == ""cbs_wrapper"":; return driver_cbs.cbs(hessian, ""cbs"", **kwargs, ptype=""hessian""); elif gradient_type != ""conventional"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_ut",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:76812,Integrability,depend,dependent,76812,"l"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(; """"""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_proj",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80307,Integrability,depend,dependent,80307,"e', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:6986,Modifiability,variab,variable,6986,"; print("""""" %d"""""" % (n), end=('\n' if (n == ndisp) else '')); sys.stdout.flush(). parent_group = molecule.point_group(); clone = molecule.clone(); clone.reinterpret_coordentry(False); clone.fix_orientation(True). # Load in displacement (flat list) into the active molecule; geom_array = np.reshape(displacement[""geometry""], (-1, 3)); clone.set_geometry(core.Matrix.from_array(geom_array)). # If the user insists on symmetry, weaken it if some is lost when displacing.; if molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:7833,Modifiability,variab,variables,7833,"). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour| finishes. (:ref:`boolean <op_py_boolean>`) Tur",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:22711,Modifiability,config,configuration,22711,"------------------+---------------------------------------------------------------------------------------------------------------+; | fno-ccsd(t) | CCSD(T) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cc3 | approximate CC singles, doubles, and triples (CC3) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccenergy | **expert** full control over ccenergy module |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dfocc | **expert** full control over dfocc module |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) :ref:`[manual] <sec:ci>` :ref:`[details] <tlcisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` |; +-----------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:23848,Modifiability,config,configuration,23848,"----------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ci\ *n* | *n*\ th-order CI :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | casscf | complete active space self consistent field (CASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | rasscf | restricted active space self consistent field (RASSCF) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mcscf | multiconfigurational self consistent field (SCF) :ref:`[manual] <sec:psimrcc>` |; +-------------------------+-----------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:25900,Modifiability,adapt,adapted,25900,"---------------------------------------+; | psimrcc | Mukherjee multireference coupled cluster (Mk-MRCC) :ref:`[manual] <sec:psimrcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dmrg-scf | density matrix renormalization group SCF :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dmrg-caspt2 | density matrix renormalization group CASPT2 :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dmrg-ci | density matrix renormalization group CI :ref:`[manual] <sec:chemps2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt0 | 0th-order symmetry adapted perturbation theory (SAPT) :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ssapt0 | 0th-order SAPT with special exchange scaling :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fisapt0 | 0th-order functional and/or intramolecular SAPT :ref:`[manual] <sec:fisapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2 | 2nd-order SAPT, traditional definition :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sapt2+ | SAPT including all 2nd-order terms :ref:`[manual] <sec:sapt>` |; +-------------------------+---------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37961,Modifiability,variab,variable,37961,"rint_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper';",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:38014,Modifiability,variab,variable,38014,"em}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:43477,Modifiability,variab,variables,43477,"core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowe",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:43800,Modifiability,variab,variables,43800,"wername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_wr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:49423,Modifiability,config,configurational,49423,"-----------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | adc(0), adc(1), | Algebraic-diagrammatic construction methods | RHF/UHF | dipole, transition_dipole, oscillator_strength, |; | ..., adc(3), | :ref:`[manual] <sec:adc>` | | rotational_strength |; | cvs-adc(0), ... | | | |; | cvs-adc(3) | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+. :type name: str; :param name: ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type properties: List[str]; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. Defaults to dipole and quadrupole. :type molecule: :ref:`molecule <op_py_molecule>`; :param mole",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:51626,Modifiability,variab,variable,51626,"tion; >>> properties('cc2', properties=['rotation']). """"""; kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); kwargs['molecule'] = molecule. # Allow specification of methods to arbitrary order; lowername = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:51679,Modifiability,variab,variable,51679,"'rotation']). """"""; kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); kwargs['molecule'] = molecule. # Allow specification of methods to arbitrary order; lowername = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.fro",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:52991,Modifiability,variab,variable,52991,"eometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.get('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59584,Modifiability,variab,variables,59584,"int_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indic",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:69931,Modifiability,variab,variable,69931,"fting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70203,Modifiability,variab,variable,70203,"sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, mole",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72164,Modifiability,variab,variables,72164,"pecific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:79244,Modifiability,variab,variables,79244,"es['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:79569,Modifiability,variab,variables,79569,"e('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81023,Modifiability,variab,variables,81023,"T ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| To",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81242,Modifiability,variab,variables,81242,"ifference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:86309,Modifiability,variab,variable,86309,"e('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs); ; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geome",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:86362,Modifiability,variab,variable,86362,"s('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs); ; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_tra",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:86732,Modifiability,variab,variables,86732,"rue, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:87737,Modifiability,variab,variables,87737," and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impost",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:89841,Modifiability,variab,variable,89841,"ometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:96567,Modifiability,variab,variable,96567,"ry module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; varlist = core.scalar_variables(); current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:1280,Performance,optimiz,optimizations,1280,"hemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import json; import os; import re; import shutil; import sys; from typing import Union. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:5099,Performance,perform,perform,5099,"hod_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _process_displacement(derivfunc, method, molecule, displacement, n, ndisp, **kwargs):; """"""A helper function to perform all processing for an individual finite; difference computation. Parameters; ----------; derivfunc : func; The function computing the target derivative.; method : str; A string specifying the method to be used for the computation.; molecule: psi4.core.molecule or qcdb.molecule; The molecule for the computation. All processing is handled internally.; molecule must not be modified!; displacement : dict; A dictionary containing the necessary information for the displacement.; See driver_findif/_geom_generator.py docstring for details.; n : int; The number of the displacement being computed, for print purposes.; ndisp : int; The total number of geometries, for print purposes. Returns; -------; wfn: :py:class:`~psi4.core.Wavefunction`; The wavefunction computed.; """""". # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n, ndisp)); print("""""" %d"""""" % (n), end=('\n' if (n == ndisp) else '')); sys.stdout.flush",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:13220,Performance,optimiz,optimized,13220,-------------------------------------------------------------+; | mp4 | full MP4 :ref:`[manual] <sec:fnompn>` :ref:`[details] <tlmp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-mp4 | full MP4 with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order |MollerPlesset| (MP) perturbation theory :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs(n)-omp2 | a special version of SCS-OMP2 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2-vdw | a special version of SCS-OMP2 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:14603,Performance,optimiz,optimized,14603,-----------------------------------------+; | scs(n)-omp2 | a special version of SCS-OMP2 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2-vdw | a special version of SCS-OMP2 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-pi-omp2 | A special version of SOS-OMP2 for pi systems :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs(n)-omp3 | a special version of SCS-OMP3 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp3-vdw | a special version of SCS-OMP3 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +--------------,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:15987,Performance,optimiz,optimized,15987,"-------------------------------------------+; | scs(n)-omp3 | a special version of SCS-OMP3 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp3-vdw | a special version of SCS-OMP3 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-pi-omp3 | A special version of SOS-OMP3 for pi systems :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccsd, cepa(0) | coupled electron pair approximation variant 0 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <tllccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-lccsd, fno-cepa(0) | CEPA(0) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cepa(1) | coupled electron pair approximation variant 1 :ref:`[manual] <sec:fnocepa>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-cepa(1) | CEPA(1) with frozen natural orbitals :ref:`[manual] <sec:fnocc",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:19363,Performance,optimiz,optimized,19363,---------------------------------------------------------------------------------------------+; | qcisd | quadratic CI singles doubles (QCISD) :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-qcisd | QCISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-lccd | LCCD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cc2 | approximate coupled cluster singles and doubles (CC2) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | bccd | Brueckner coupled cluster doubles (BCCD) :ref:`[manual] <sec:cc>` |; +-------------------------+--------------------,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33495,Performance,perform,perform,33495," calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33597,Performance,perform,perform,33597,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:38125,Performance,optimiz,optimize,38125,"rgy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42700,Performance,perform,perform,42700,"hat do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42904,Performance,perform,perform,42904,"dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FIN",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:47322,Performance,optimiz,optimized,47322,"------------------+; | hf | HF Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | mp2 | MP2 with density fitting only (mp2_type df) | RHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | ccsd | Coupled cluster singles and doubles (CCSD) | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:47656,Performance,optimiz,optimized,47656,"------------------+; | hf | HF Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | mp2 | MP2 with density fitting only (mp2_type df) | RHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | ccsd | Coupled cluster singles and doubles (CCSD) | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:47991,Performance,optimiz,optimized,47991,"----------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+--------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:48285,Performance,optimiz,optimized,48285,"--------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+---",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:54872,Performance,optimiz,optimize,54872,"4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M,",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:55747,Performance,optimiz,optimizer,55747,"lueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_ener",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:55784,Performance,optimiz,optimize,55784,"e not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Conver",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:55826,Performance,optimiz,optimizer,55826,"Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Conver",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:55848,Performance,optimiz,optimize,55848,", CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.C",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:55974,Performance,optimiz,optimizer,55974,"em; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n -----------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:56003,Performance,optimiz,optimizer,56003,"('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n ------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:56046,Performance,optimiz,optimizer,56046," {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). cor",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57054,Performance,optimiz,optimizer,57054,"mizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{o",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57079,Performance,optimiz,optimizer,57079,"_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57202,Performance,optimiz,optimizer,57202,"ms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57231,Performance,optimiz,optimize,57231,"in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_e",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57326,Performance,optimiz,optimizer,57326,"rked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57355,Performance,optimiz,optimize,57355," ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.appe",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57451,Performance,optimiz,optimizer,57451,"---------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57469,Performance,optimiz,optimizer,57469,"------------ ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Ma",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57498,Performance,optimiz,optimizer,57498,"print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimize",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57537,Performance,optimiz,optimizer,57537,"lta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_g",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57586,Performance,optimiz,optimize,57586,"(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_o",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57610,Performance,optimiz,optimizer,57610,"--------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Ene",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57623,Performance,optimiz,optimizer,57623,"-------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57669,Performance,optimiz,optimizer,57669,"---------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57683,Performance,optimiz,optimizer,57683,"-- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58000,Performance,optimiz,optimizer,58000,"------------------------------ ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (r",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58025,Performance,optimiz,optimizer,58025,"---- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif r",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58050,Performance,optimiz,optimizer,58050,"\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not retur",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58062,Performance,optimiz,optimizer,58062,"eration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58251,Performance,optimiz,optimizer,58251,"NVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58312,Performance,optimiz,optimizer,58312,"); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :ret",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58386,Performance,optimiz,optimizer,58386,"re.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wav",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58435,Performance,optimiz,optimizer,58435,"erge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :rais",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58486,Performance,optimiz,optimizer,58486,"ergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59130,Performance,optimiz,optimize,59130,".2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:cla",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59173,Performance,perform,perform,59173,".2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:cla",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59192,Performance,optimiz,optimization,59192,".2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:cla",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59275,Performance,optimiz,optimized,59275," step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tupl",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60490,Performance,optimiz,optimization,60490,"class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'`",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60596,Performance,optimiz,optimization,60596,"NERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computation",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60667,Performance,optimiz,optimizer,60667,"NERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computation",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60794,Performance,optimiz,optimizer,60794,"led. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizati",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60864,Performance,optimiz,optimizer,60864,":func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry bein",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60892,Performance,optimiz,optimization,60892,":func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry bein",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61061,Performance,perform,performed,61061,"py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61167,Performance,perform,performs,61167,"e :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61507,Performance,optimiz,optimization,61507,"optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61529,Performance,perform,performed,61529,"optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61666,Performance,perform,perform,61666,"izer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61716,Performance,optimiz,optimization,61716,"izer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:62414,Performance,optimiz,optimizations,62414,gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dct | density cumulant (functional) theory :ref:`[manual] <sec:dct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <tlmp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+------------------------------------------------------,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:63997,Performance,optimiz,optimized,63997,--------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <tlmp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cl,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:64233,Performance,optimiz,optimized,64233,--------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <tlmp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cl,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:64470,Performance,optimiz,optimized,64470,----------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+-------------------------------------,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:64899,Performance,optimiz,optimized,64899,d-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed ,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66140,Performance,optimiz,optimization,66140,"occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66158,Performance,optimiz,optimize,66158,"occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66206,Performance,optimiz,optimization,66206,"------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.po",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66367,Performance,perform,perform,66367,"] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Opt",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66414,Performance,optimiz,optimize,66414,"] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Opt",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66475,Performance,perform,perform,66475,"-------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowern",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66668,Performance,optimiz,optimize,66668,"-----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if ret",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66821,Performance,optimiz,optimization,66821,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66905,Performance,optimiz,optimization,66905,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66992,Performance,optimiz,optimization,66992,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:67026,Performance,optimiz,optimize,67026,"include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:68357,Performance,optimiz,optimize,68357,"ptking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:69609,Performance,optimiz,optimize,69609,"bs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:69828,Performance,optimiz,optimization,69828,"ore.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70380,Performance,optimiz,optimization,70380,"put, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_g",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:71969,Performance,optimiz,optimized,71969,"ss_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object()",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72141,Performance,optimiz,optimized,72141,"pecific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72230,Performance,optimiz,optimization,72230,"ient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72275,Performance,optimiz,optimization,72275,"ient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72596,Performance,optimiz,optimized,72596,"an += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_opti",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72712,Performance,optimiz,optimize,72712,"king_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); opts",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:73451,Performance,optimiz,optimization,73451,"PTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electroni",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:73496,Performance,optimiz,optimization,73496,"PTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electroni",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:73790,Performance,optimiz,optimization,73790,"an(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hes",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:74141,Performance,optimiz,optimization,74141,"n and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:78185,Performance,perform,perform,78185," # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(; """"""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:78672,Performance,perform,perform,78672,"re.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80214,Performance,perform,perform,80214," = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82975,Performance,perform,performed,82975,". :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and U",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83081,Performance,perform,performs,83081,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83531,Performance,perform,performed,83531,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:85328,Performance,optimiz,optimize,85328,"=============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs); ; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:86578,Performance,perform,perform,86578,"ided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:94677,Performance,optimiz,optimized,94677,"on in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:96369,Performance,optimiz,optimized,96369," This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; varlist = core.scalar_variables(); current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:102334,Performance,optimiz,optimize,102334," = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:2850,Safety,sanity check,sanity check,2850,"si4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in pr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37357,Safety,safe,safer,37357,"shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:97951,Safety,detect,detected,97951,"ls for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for the pytest. The SCF density below follows PSI4 ordering not FCHK ordering.; if debug:; ret = {; ""filename"": filename,; ""detected energy"": method,; ""selected label"": fchk_label,; ""Total SCF Density"": fw.SCF_Dtot().np,; }; return ret; return None. [docs]def molden(wfn, filename=None, density_a=None, density_b=None, dovirtual=None):; """"""Function to write wavefunction information in *wfn* to *filename* in; molden format. Will write natural orbitals from *density* (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: str; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:3632,Security,validat,validation,3632,":; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTER",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61109,Security,access,accesses,61109,"e :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82792,Security,access,accessed,82792,"n_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83023,Security,access,accesses,83023,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:2500,Testability,log,logic,2500,"ort core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"")",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41301,Testability,test,test,41301,"; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41984,Testability,test,test,41984,"method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70346,Testability,test,testing,70346,"art """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:76848,Testability,test,test,76848,"l"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(; """"""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_proj",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80343,Testability,test,test,80343,"e', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61697,Usability,guid,guide,61697,"izer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:5409,Availability,avail,available,5409,"pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" %; (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(f""""""Basis set '{basis}' not available for molecule.""""""). return (BSET, ZSET). def _contract_bracketed_basis(basisarray: List):; """"""Function to reform a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Returns; -------; string; A nicely formatted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post; return basisstring. [docs]def xtpl_highest_1(functionname: str, zHI: int, valueHI: float, verbose: bool = True, **kwar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:39234,Availability,avail,available,39234,"s``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: Callable; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:39277,Availability,avail,available,39277,"orl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: Callable; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation schem",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:44766,Availability,avail,available,44766,"lied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; * ```options_lo```: special options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_sche",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:28324,Deployability,update,update,28324,"}; VARH['fci'] = {; 'hf': 'HF TOTAL ENERGY',; 'fci': 'FCI TOTAL ENERGY'}; VARH['mrccsd'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsd': 'CCSD TOTAL ENERGY'}; VARH['mrccsd(t)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsd': 'CCSD TOTAL ENERGY',; 'mrccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['mrccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:56401,Deployability,update,update,56401,"nstructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_wfn'][3:] == job['f_wfn']) and lvl[1]['f_wfn'].startswith('c4-')) or; ((lvl[1]['f_wfn'] == job['f_wfn'][3:]) and job['f_wfn'].startswith('c4-')) or; (('c4-' + lvl[1]['f_wfn']) == job['f_wfn']) or (lvl[1]['f_wfn'] == ('c4-' + job['f_wfn']))); and (lvl[1]['f_basis'] == job['f_basis']) and (lvl[1]['f_options'] == job['f_options'])):; lvl[1]['f_energy'] = job['f_energy']; lvl[1]['f_gradient'] = job['f_gradient']; lvl[1]['f_hessian'] = job['f_hessian']. # Make xtpl() call; finalenergy = 0.0; finalgradient = core.Matrix(natom, 3); finalhessian = core.Matrix(3 * natom, 3 * natom). for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha']}. hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = stage['d_scheme'](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient':; hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = stage['d_scheme'](**hiloargs); work = stage['d_gradient'].clone(); work.scale(stage['d_coef']); finalgradient.add(work). elif ptype == 'hessian':; hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = stage['d_scheme'](**hiloargs); work = stage['d_hessian'].clone(); work.scale(stage['d_coef']); finalhessian.add(work). # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]',; 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:56600,Deployability,update,update,56600,"EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_wfn'][3:] == job['f_wfn']) and lvl[1]['f_wfn'].startswith('c4-')) or; ((lvl[1]['f_wfn'] == job['f_wfn'][3:]) and job['f_wfn'].startswith('c4-')) or; (('c4-' + lvl[1]['f_wfn']) == job['f_wfn']) or (lvl[1]['f_wfn'] == ('c4-' + job['f_wfn']))); and (lvl[1]['f_basis'] == job['f_basis']) and (lvl[1]['f_options'] == job['f_options'])):; lvl[1]['f_energy'] = job['f_energy']; lvl[1]['f_gradient'] = job['f_gradient']; lvl[1]['f_hessian'] = job['f_hessian']. # Make xtpl() call; finalenergy = 0.0; finalgradient = core.Matrix(natom, 3); finalhessian = core.Matrix(3 * natom, 3 * natom). for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha']}. hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = stage['d_scheme'](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient':; hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = stage['d_scheme'](**hiloargs); work = stage['d_gradient'].clone(); work.scale(stage['d_coef']); finalgradient.add(work). elif ptype == 'hessian':; hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = stage['d_scheme'](**hiloargs); work = stage['d_hessian'].clone(); work.scale(stage['d_coef']); finalhessian.add(work). # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]',; 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; '', job['f_wfn'], '/', job['f_basis'] + "" + options"" * bool(job['f_options']), star, job['f_energy'],; VARH[job['f_wfn']][j",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:56842,Deployability,update,update,56842,"f_wfn']) == job['f_wfn']) or (lvl[1]['f_wfn'] == ('c4-' + job['f_wfn']))); and (lvl[1]['f_basis'] == job['f_basis']) and (lvl[1]['f_options'] == job['f_options'])):; lvl[1]['f_energy'] = job['f_energy']; lvl[1]['f_gradient'] = job['f_gradient']; lvl[1]['f_hessian'] = job['f_hessian']. # Make xtpl() call; finalenergy = 0.0; finalgradient = core.Matrix(natom, 3); finalhessian = core.Matrix(3 * natom, 3 * natom). for stage in GRAND_NEED:; hiloargs = {'alpha': stage['d_alpha']}. hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_energy')); stage['d_energy'] = stage['d_scheme'](**hiloargs); finalenergy += stage['d_energy'] * stage['d_coef']. if ptype == 'gradient':; hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_gradient')); stage['d_gradient'] = stage['d_scheme'](**hiloargs); work = stage['d_gradient'].clone(); work.scale(stage['d_coef']); finalgradient.add(work). elif ptype == 'hessian':; hiloargs.update(_contract_scheme_orders(stage['d_need'], 'f_hessian')); stage['d_hessian'] = stage['d_scheme'](**hiloargs); work = stage['d_hessian'].clone(); work.scale(stage['d_coef']); finalhessian.add(work). # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [Eh]',; 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; '', job['f_wfn'], '/', job['f_basis'] + "" + options"" * bool(job['f_options']), star, job['f_energy'],; VARH[job['f_wfn']][job['f_wfn']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [Eh]',; 'Scheme'); tables +",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:68322,Deployability,update,updated,68322,"ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treatment'] = ""corl""; metadata.append(stage). # ""method/basis"" syntax only allows for one delta correction; # via ""method/basis+D:delta/basis"". Maximum length of method_list is 2.; if len(method_list) == 2:; stage = {}; stage['wfn'] = method_list[1]; stage['basis'] = basis_list[1]; if 'delta_scheme' in kwargs:; stage['scheme'] = kwargs.pop('delta_scheme'); stage['stage'] = ""delta1""; stage['treatment'] = ""corl""; metadata.append(stage); ; cbs_kwargs[""cbs_metadata""] = metadata; ptype_value, wfn = cbs(func, label, **cbs_kwargs). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.driver_cbs. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:1634,Energy Efficiency,energy,energy,1634,"e implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import math; import re; import sys; from typing import Callable, List. import numpy as np. from psi4 import core; from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver import driver_util; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list. zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }. def _expand_bracketed_basis(basisstring: str, molecule=None):; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule : qcdb.molecule or psi4.core.Molecule; This function checks th",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:10600,Energy Efficiency,power,power,10600,"'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_truhlar_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 *",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:11835,Energy Efficiency,power,power,11835,"sed for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_truhlar_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:12864,Energy Efficiency,power,power,12864,"\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Truhlar 2-point power from SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:13641,Energy Efficiency,power,power,13641," = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Truhlar 2-point power from SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:14946,Energy Efficiency,power,power,14946,"+ 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Karton SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Karton SCF (%s, %s) data' % (zLO, zHI). if verbose",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:15972,Energy Efficiency,power,power,15972,"<==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Karton SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Karton SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Karton 2-point power from SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_Karton_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: float, zMD: int, valueMD: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:28673,Energy Efficiency,energy,energy,28673,"',; 'mrccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['mrccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34101,Energy Efficiency,energy,energy,34101,"f sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34324,Energy Efficiency,energy,energy,34324,"se:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34832,Energy Efficiency,energy,energy,34832,"d(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0);",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34964,Energy Efficiency,energy,energy,34964,"##########################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34988,Energy Efficiency,energy,energy,34988,"##########################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:35035,Energy Efficiency,energy,energy,35035,"##########################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:35440,Energy Efficiency,energy,energy,35440,"ariables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn key",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:35656,Energy Efficiency,energy,energy,35656," - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixe",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:36237,Energy Efficiency,energy,energy,36237,"t. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:36461,Energy Efficiency,energy,energy,36461,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta cor",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:36499,Energy Efficiency,energy,energy,36499,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta cor",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:36785,Energy Efficiency,energy,energy,36785,"omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set thro",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:36825,Energy Efficiency,energy,energy,36825,"omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set thro",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37042,Energy Efficiency,energy,energy,37042,"rccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37105,Energy Efficiency,energy,energy,37105,"rccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37252,Energy Efficiency,energy,energy,37252,"med,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37315,Energy Efficiency,energy,energy,37315,"med,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37444,Energy Efficiency,energy,energy,37444," which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37514,Energy Efficiency,energy,energy,37514," which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37668,Energy Efficiency,energy,energy,37668," corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:37738,Energy Efficiency,energy,energy,37738," corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38107,Energy Efficiency,energy,energy,38107,"ection; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; se",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38412,Energy Efficiency,energy,energy,38412," ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: str; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_x",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38657,Energy Efficiency,energy,energy,38657," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driv",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38911,Energy Efficiency,energy,energy,38911,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cb",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:38953,Energy Efficiency,energy,energy,38953,"|| ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:39483,Energy Efficiency,energy,energy,39483,"is string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: Callable; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:40305,Energy Efficiency,energy,energy,40305,"for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: Callable; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_scheme: Callable; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta2_scheme: Callable; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| ||",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:40854,Energy Efficiency,energy,energy,40854, .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: Callable; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_scheme: Callable; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta2_scheme: Callable; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type scf_alpha: float; :param scf_alpha: |dl| ``1.63`` |dr|.,MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:41413,Energy Efficiency,energy,energy,41413,"orl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_scheme: Callable; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta2_scheme: Callable; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type scf_alpha: float; :param scf_alpha: |dl| ``1.63`` |dr|. Overrides the default \alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` and :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:43393,Energy Efficiency,energy,energy,43393,"sted :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise nonrelativistic.; * ```options_lo```: special options for lower method in a given stage",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45426,Energy Efficiency,energy,energy,45426,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45445,Energy Efficiency,energy,energy,45445,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45592,Energy Efficiency,energy,energy,45592,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45611,Energy Efficiency,energy,energy,45611,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45712,Energy Efficiency,energy,energy,45712,"l of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z',",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45724,Energy Efficiency,energy,energy,45724,"l of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z',",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45856,Energy Efficiency,energy,energy,45856,"r method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, correct",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45892,Energy Efficiency,energy,energy,45892,"r method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, correct",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:46084,Energy Efficiency,energy,energy,46084,"ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:46138,Energy Efficiency,energy,energy,46138,"ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:46251,Energy Efficiency,energy,energy,46251,"ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:46563,Energy Efficiency,energy,energy,46563," corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _proc",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:46599,Energy Efficiency,energy,energy,46599," corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _proc",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:47001,Energy Efficiency,energy,energy,47001,"tion atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:47792,Energy Efficiency,energy,energy,47792,"a MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:47930,Energy Efficiency,energy,energy,47930,"a MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:49240,Energy Efficiency,energy,energy,49240,"ecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; GRAND_NEED = []; MODELCHEM = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf', metadata[0][""scheme""],; _contract_bracketed_basis(metadata[0][""basis""][0]), metadata[0][""wfn""], NEED, +1, 0.0, None, None,; metadata[0][""alpha""]; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], NEED, +1, 0.0, None, None,; delta[""alpha""]; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:50796,Energy Efficiency,energy,energy,50796," 0.0, None, None,; metadata[0][""alpha""]; ]))); if len(metadata) > 1:; for delta in metadata[1:]:; NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis""][0], delta[""basis""][1], delta[""wfn""],; delta[""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis""][0]), delta[""wfn""], NEED, +1, 0.0, None, None,; delta[""alpha""]; ]))); NEED = _expand_scheme_orders(delta[""scheme""], delta[""basis_lo""][0], delta[""basis_lo""][1], delta[""wfn_lo""],; delta[""options_lo""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; delta[""stage""], delta[""scheme""],; _contract_bracketed_basis(delta[""basis_lo""][0]), delta[""wfn_lo""], NEED, -1, 0.0, None, None,; delta[""alpha""]; ]))). for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]. addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; instructions = ''; instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']) and \; (job['f_options'] == mc['f_options']):; dups += 1; if dups >= 1:; del JOBS[indx_job]. # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if (VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]) and \; (mc['f_basis'] == job['f_basis']) and not \; (mc['f_wfn'] == job['f_wfn']) and \; (mc['f_options'] == False):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:51486,Energy Efficiency,energy,energy,51486,"or stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]. addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; instructions = ''; instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']) and \; (job['f_options'] == mc['f_options']):; dups += 1; if dups >= 1:; del JOBS[indx_job]. # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if (VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]) and \; (mc['f_basis'] == job['f_basis']) and not \; (mc['f_wfn'] == job['f_wfn']) and \; (mc['f_options'] == False):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Expand listings to all that will be obtained; JOBS_EXT = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; JOBS_EXT.append(; dict(; zip(f_fields, [; wfn, job['f_basis'], job['f_zeta'], 0.0,; core.Matrix(natom, 3),; core.Matrix(3 * natom, 3 * natom), job['f_options']; ]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addl",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54039,Energy Efficiency,energy,energy,54039,"= mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper() + "" + opts.""*bool(mc['f_options']), addlremark[ptype]); cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; i",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54119,Energy Efficiency,energy,energy,54119,")\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper() + "" + opts.""*bool(mc['f_options']), addlremark[ptype]); cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54674,Energy Efficiency,energy,energy,54674,"basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['f_options']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:60007,Energy Efficiency,energy,energy,60007,"tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[dc]['d_stage'], GRAND_NEED[dc]['d_wfn'] + ' - ' + GRAND_NEED[dc + 1]['d_wfn'], '/',; GRAND_NEED[dc]['d_basis'], '', deltaE_total,; GRAND_NEED[dc]['d_scheme'].__name__); core.set_variable(f""CBS {GRAND_NEED[dc]['d_stage'].upper()} TOTAL ENERGY"", deltaE_total); dc += 2. tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. core.print_out(tables). core.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CBS TOTAL ENERGY', finalenergy); core.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT ENERGY', finalenergy); core.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; basis = core.BasisSet.build(molecule, ""ORBITAL"", 'def2-svp'); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_gradient(finalgradient); wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. ######### COMPUTE / ASSEMBLE; ######### ASSEMBLE / REPORT. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, options, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:60152,Energy Efficiency,energy,energy,60152,"cheme'].__name__); core.set_variable(f""CBS {GRAND_NEED[dc]['d_stage'].upper()} TOTAL ENERGY"", deltaE_total); dc += 2. tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. core.print_out(tables). core.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CBS TOTAL ENERGY', finalenergy); core.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT ENERGY', finalenergy); core.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; basis = core.BasisSet.build(molecule, ""ORBITAL"", 'def2-svp'); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_gradient(finalgradient); wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. ######### COMPUTE / ASSEMBLE; ######### ASSEMBLE / REPORT. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, options, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). if int(scheme.__name__.split('_')[-1]) != Nxtpl:; raise ValidationError(""""""Call to '%s' not valid with '%s' basis sets."""""" % (scheme.__name__, len",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:64768,Energy Efficiency,energy,energy,64768," wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; metho",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:65829,Energy Efficiency,energy,energy,65829,"`""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:66464,Energy Efficiency,energy,energy,66464,"s.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] =",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:19449,Integrability,rout,routines,19449,"% (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:43065,Integrability,interface,interface,43065,".driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculatin",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:43242,Integrability,interface,interface,43242,"corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if special options are required for a step, they should be entered as a dict here. If some options should be used for both parts of the stage, they should be entered in both ```options``` and ```options_lo```. This is helpful for calculating all electron corrections in otherwise frozen core calculations, or relativistic (DKH) Hamiltionian corrections for otherwise no",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:48520,Integrability,wrap,wrapper,48520,"_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:48756,Integrability,wrap,wrapper,48756," = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; GRAND_NEED = []; MODELCHEM = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:48958,Integrability,wrap,wrapper,48958," 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; GRAND_NEED = []; MODELCHEM = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf', metadata[0][""scheme""],; _contract_bracketed_basis(metadata[0][""basis""][0]), metadata[0][""wfn""], NEED, +1, 0.0, None, None,; metadata[0][""alpha""]; ]))); if len(metadata) > 1:; for delta in metadata[1:",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:53438,Integrability,depend,dependent,53438," instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]); core.print_out(instructions). psioh = core.IOManager.shared_object(); psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # needs to be communicated to optimize() so reset by that optstash; core.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper() + "" + opts.""*bool(mc['f_options']), addlremark[ptype]); cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:63754,Integrability,wrap,wrapper,63754,":; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += [f'delta{x}_wfn' for x in range(2, 6)]; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; """""" A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name : str; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:66771,Integrability,wrap,wrapper,66771,"call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treatment'] = ""corl""; metadata.append(stage). # ""method/basis"" syntax only allows for one delta correction; # via ""method/basis+D:delta/basis"". Maximum length of method_list is 2.; if len(method_list) == 2:; stage = {}; stage['wfn'] = method_list[1]; stage['basis'] = basis_list[1]; if ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34349,Modifiability,variab,variables,34349,"le stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54234,Modifiability,variab,variable,54234,"() + "" + opts.""*bool(mc['f_options']), addlremark[ptype]); cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['f_options']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54385,Modifiability,variab,variable,54385," and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if any; if mc[""f_options""]:; optionstash = p4util.OptionsState(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['f_options']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + labe",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:54870,Modifiability,variab,variable,54870,"(*[[opt] for opt in list(mc[""f_options""])]); for k, v, in mc[""f_options""].items():; core.set_global_option(k.upper(), v); else:; optionstash = False. # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = core.variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; core.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Restore modified options; if optionstash:; optionstash.restore(). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']) and \; (mc['f_options'] == job['f_options']):; job['f_energy'] = core.variable(VARH[wfn][wfn]). if verbose > 1:; core.print_variables(); core.clean_variables(); core.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']) and \; (mc['f_options'] == mce['f_options']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Results{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_wfn'][3:] == job['f_wfn']) and lvl[1]['f_wfn'].startswith('c4-')) or; ((lvl[1]['f_wfn'] == job['f_wfn'][3:]) and job['f_wfn'].startswith('",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:66051,Modifiability,variab,variables,66051,"and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:36278,Performance,perform,performed,36278,"t. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:42878,Performance,perform,performed,42878,"ect on others, including :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` and :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_alpha: float; :param corl_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_alpha: float; :param delta_alpha: |dl| ``3.00`` |dr| . Overrides the default \alpha parameter used in the listed; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. * Combined interface; ; :type cbs_metadata: List[Dict]; :param cbs_metadata: |dl| autogenerated from above keywords |dr| || ``[{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}]`` || etc. This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. * ```wfn```: typically ```HF```, which is subsumed in correlated methods anyway.; * ```basis```: basis set, can be in a bracketed form (eg. ```cc-pv[tq]z```). | Other supported arguments for the first dictionary are:. * ```scheme```: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as ```basis```.; * ```alpha```: alpha for the above scheme, if the default is to be overriden; * ```options```: if spe",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:47473,Performance,optimiz,optimize,47473,"rection atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:47494,Performance,optimiz,optimize,47494,"rection atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:52878,Performance,optimiz,optimize,52878,"ed listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Expand listings to all that will be obtained; JOBS_EXT = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; JOBS_EXT.append(; dict(; zip(f_fields, [; wfn, job['f_basis'], job['f_zeta'], 0.0,; core.Matrix(natom, 3),; core.Matrix(3 * natom, 3 * natom), job['f_options']; ]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'] + "" + options""*bool(mc['f_options']),; VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]); core.print_out(instructions). psioh = core.IOManager.shared_object(); psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # needs to be communicated to optimize() so reset by that optstash; core.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper() + "" + opts.""*bool(mc['f_options']), addlremark[ptype]); cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower().replace('*', 's')); exec(commands). # Stash and set options if",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:1929,Security,validat,validate,1929,"he GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import math; import re; import sys; from typing import Callable, List. import numpy as np. from psi4 import core; from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver import driver_util; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list. zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }. def _expand_bracketed_basis(basisstring: str, molecule=None):; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule : qcdb.molecule or psi4.core.Molecule; This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Returns; -------; tuple; Tuple in the ``([basis set names], [basis set zetas])`` fo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:29415,Security,validat,validates,29415,"default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if le",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:29835,Security,validat,validation,29835,"turn xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""option",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:32068,Security,validat,validation,32068,"l""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = f""delta{len(metadata) - 1}""; stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in k",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:32273,Security,validat,validation,32273,"(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:32427,Security,validat,validate,32427,"e[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwarg",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:17918,Testability,log,log,17918,"vel.; valueLO; Lower value used for extrapolation.; zMD; Intermediate zeta level. Should be equal to zLO + 1.; valueMD; Intermediate value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 2.; valueHI; Higher value used for extrapolation.; alpha; Not used. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)"" %; (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinsta",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:19230,Testability,log,log,19230,".upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45372,Usability,simpl,simple,45372,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45530,Usability,simpl,simple,45530,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:64656,Usability,simpl,simple,64656,"se ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:29754,Availability,error,error,29754,"; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; if monomer_energies != 0.0:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items()}; else:; results['%s_energy_body_dict' % b] = {}. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if metadata['return_total_data']:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; else:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; results['ret_energy'] -= results['energy_body_dict'][1]. if metadata['ptype'] != 'energy':; if metadata['return_total_data']:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); else:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); np_final_ptype -= results['ptype_body_dict'][1]. results['ret_ptype'] = core.Matrix.from_array(np_final_ptype); else:; results['ret_ptype'] = results['ret_energy']. if monomer_energies == 0.0:; del results['energy_body_dict']. return results. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:30668,Deployability,update,updated,30668,"body_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; if monomer_energies != 0.0:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items()}; else:; results['%s_energy_body_dict' % b] = {}. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if metadata['return_total_data']:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; else:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; results['ret_energy'] -= results['energy_body_dict'][1]. if metadata['ptype'] != 'energy':; if metadata['return_total_data']:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); else:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); np_final_ptype -= results['ptype_body_dict'][1]. results['ret_ptype'] = core.Matrix.from_array(np_final_ptype); else:; results['ret_ptype'] = results['ret_energy']. if monomer_energies == 0.0:; del results['energy_body_dict']. return results. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:3867,Energy Efficiency,energy,energy,3867,"essian How did you end up here?""). def _print_nbody_energy(energy_body_dict, header, embedding=False):; core.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); core.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; if previous_e == 0.0:; tot_e = False; else:; tot_e = True; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indica",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:4146,Energy Efficiency,energy,energy,4146," else:; tot_e = True; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecul",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:4256,Energy Efficiency,energy,energy,4256," nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:4343,Energy Efficiency,energy,energy,4343,"int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessia",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:5173,Energy Efficiency,energy,energy,5173,"y/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type ptype: str; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:5605,Energy Efficiency,energy,energy,5605,"lecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type ptype: str; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:5832,Energy Efficiency,energy,energy,5832,"urn the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type ptype: str; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: str; :param charge_method: ``scf/",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:6715,Energy Efficiency,charge,charges,6715,"l_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: str; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:6773,Energy Efficiency,charge,charges,6773,"data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: str; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embed",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:6914,Energy Efficiency,charge,charges,6914,"ault is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. ``supersystem`` computes; all higher order n-body effects up to the number of fragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: str; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'g",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:7901,Energy Efficiency,energy,energy,7901,"erridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). if metadata['return_total_data'] is None:; if metadata['ptype'] in ['gradient', 'hessian']:; metadata['return_total_data'] = True; else:; metadata['return_total_data'] = False. # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); if metadata['molecule'].nfragments() == 1:; raise ValidationError(""N-Body requires active mo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:15791,Energy Efficiency,energy,energy,15791,"nations(cp_combos, interior_nbody):; combo_tuple = (x, basis_tuple); vmfc_compute_list[interior_nbody].add(combo_tuple); vmfc_level_list[len(basis_tuple)].add(combo_tuple). # Build a comprehensive compute_range; compute_list = {x: set() for x in nbody_range}; for n in nbody_range:; compute_list[n] |= cp_compute_list[n]; compute_list[n] |= nocp_compute_list[n]; compute_list[n] |= vmfc_compute_list[n]; core.print_out("" Number of %d-body computations: %d\n"" % (n, len(compute_list[n]))). metadata['compute_dict'] = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }. return metadata. def compute_nbody_components(func, method_string, metadata):; """"""Computes requested N-body components. Performs requested computations for psi4::Molecule object `molecule` according to; `compute_list` with function `func` at `method_string` level of theory. Parameters; ----------; func : str; {'energy', 'gradient', 'hessian'}; Function object to be called within N-Body procedure.; method_string : str; Indicates level of theory to be passed to function `func`.; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'compute_list'``: dict of int: set; List of computations to perform. Keys indicate body-levels, e.g,. `compute_list[2]` is the; list of all 2-body computations required.; ``'kwargs'``: dict; Arbitrary keyword arguments to be passed to function `func`. Returns; -------; dict of str: dict; Dictionary containing computed N-body components. Contents:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body p",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:16465,Energy Efficiency,energy,energy,16465,"s': vmfc_level_list; }. return metadata. def compute_nbody_components(func, method_string, metadata):; """"""Computes requested N-body components. Performs requested computations for psi4::Molecule object `molecule` according to; `compute_list` with function `func` at `method_string` level of theory. Parameters; ----------; func : str; {'energy', 'gradient', 'hessian'}; Function object to be called within N-Body procedure.; method_string : str; Indicates level of theory to be passed to function `func`.; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'compute_list'``: dict of int: set; List of computations to perform. Keys indicate body-levels, e.g,. `compute_list[2]` is the; list of all 2-body computations required.; ``'kwargs'``: dict; Arbitrary keyword arguments to be passed to function `func`. Returns; -------; dict of str: dict; Dictionary containing computed N-body components. Contents:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; """"""; # Get required metadata; kwargs = metadata['kwargs']; molecule = metadata['molecule']; #molecule = core.get_active_molecule(); compute_list = metadata['compute_dict']['all']. # Now compute the energies; energies_dict = {}; gradients_dict = {}; ptype_dict = {}; intermediates_dict = {}; if kwargs.get('charge_method', False) and not metadata['embedding_charges']:; metadata['embedding_charges'] = driver_nbody_helper.compute_charges(kwargs['charge_method'],; kwargs.get('charge_type', 'MULLIKEN_CHARGES').upper(), molecule); for count, n in enumerate(compute_list.keys()):; core.print_out(""\n ==> N-Body: Now computing %d-bo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:19161,Energy Efficiency,energy,energy,19161,"le(""CURRENT ENERGY""); gradients_dict[pair] = wfn.gradient(); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ', '.join(; [str(i) for i in pair[1]])); intermediates_dict[var_key] = core.variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % (str(; pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure which has generated the N-body components to be combined.; ``'bsse_type_list'``: list of str; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``: int; Maximum number of bodies to include in the N-Body treatment.; Possible: `max_nbody` <= `max_frag`; Default: `max_nbody` = `max_frag`; ``'max_frag'``: int; Number of distinct fragments comprising full molecular supersystem.; ``'energies_dict'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype_dict'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'compute_dict'``: dict of str: dict; Dictionary containing {int: set} subdicts enumerating compute lists for each possible; BSSE treatment.; ``'kwargs'``: dict; Arbitrary keyword arguments.; component_results : dict of str: dict; Dictionary conta",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:19722,Energy Efficiency,energy,energy,19722,"O', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure which has generated the N-body components to be combined.; ``'bsse_type_list'``: list of str; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``: int; Maximum number of bodies to include in the N-Body treatment.; Possible: `max_nbody` <= `max_frag`; Default: `max_nbody` = `max_frag`; ``'max_frag'``: int; Number of distinct fragments comprising full molecular supersystem.; ``'energies_dict'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype_dict'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'compute_dict'``: dict of str: dict; Dictionary containing {int: set} subdicts enumerating compute lists for each possible; BSSE treatment.; ``'kwargs'``: dict; Arbitrary keyword arguments.; component_results : dict of str: dict; Dictionary containing computed N-body components. Required ``'key': value`` pairs:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; Returns; -------; results : dict of",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:20318,Energy Efficiency,energy,energy,20318,"r; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``: int; Maximum number of bodies to include in the N-Body treatment.; Possible: `max_nbody` <= `max_frag`; Default: `max_nbody` = `max_frag`; ``'max_frag'``: int; Number of distinct fragments comprising full molecular supersystem.; ``'energies_dict'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype_dict'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'compute_dict'``: dict of str: dict; Dictionary containing {int: set} subdicts enumerating compute lists for each possible; BSSE treatment.; ``'kwargs'``: dict; Arbitrary keyword arguments.; component_results : dict of str: dict; Dictionary containing computed N-body components. Required ``'key': value`` pairs:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; Returns; -------; results : dict of str; Dictionary of all N-body results. Contents:; ``'ret_energy'``: float64; Interaction data requested. If multiple BSSE types requested in `bsse_type_list`, the interaction data associated with the *first* BSSE; type in the list is returned.; ``'nbody_dict'``: dict of str: float64; Dictionary of relevant N-body psivars to be set; ``'energy_body_dict'``: dict of int: float64; Dictionary of total energies at each N-body level, i.e., ``results['energy_body_dict'][2]`` is the sum of all 2-body total energies; for the supersystem. May be empty if ``return_total_data`` is ``Fals",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:21391,Energy Efficiency,energy,energy,21391,"e'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; Returns; -------; results : dict of str; Dictionary of all N-body results. Contents:; ``'ret_energy'``: float64; Interaction data requested. If multiple BSSE types requested in `bsse_type_list`, the interaction data associated with the *first* BSSE; type in the list is returned.; ``'nbody_dict'``: dict of str: float64; Dictionary of relevant N-body psivars to be set; ``'energy_body_dict'``: dict of int: float64; Dictionary of total energies at each N-body level, i.e., ``results['energy_body_dict'][2]`` is the sum of all 2-body total energies; for the supersystem. May be empty if ``return_total_data`` is ``False``.; ``'ptype_body_dict'``: dict or dict of int: array_like; Empty dictionary if `ptype is ``'energy'``, or dictionary of total ptype; arrays at each N-body level; i.e., ``results['ptype_body_dict'][2]``; for `ptype` ``'gradient'``is the total 2-body gradient.; """"""; # Unpack metadata; kwargs = metadata['kwargs']. nbody_range = range(1, metadata['max_nbody'] + 1). # Unpack compute list metadata; compute_list = metadata['compute_dict']['all']; cp_compute_list = metadata['compute_dict']['cp']; nocp_compute_list = metadata['compute_dict']['nocp']; vmfc_compute_list = metadata['compute_dict']['vmfc_compute']; vmfc_level_list = metadata['compute_dict']['vmfc_levels']. # Build size and slices dictionaries; fragment_size_dict = {; frag: metadata['molecule'].extract_subsets(frag).natom(); for frag in range(1, metadata['max_frag'] + 1); }; start = 0; fragment_slice_dict = {}; for k, v in fragment_size_dict.items():; fragment_slice_dict[k] = slice(start, start + v); start += v. molecule_total_atoms = sum(fragment_size_dict.values()). # Final dictionaries; cp_energy_by_level = {n:",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:22694,Energy Efficiency,energy,energy,22694,"p']; nocp_compute_list = metadata['compute_dict']['nocp']; vmfc_compute_list = metadata['compute_dict']['vmfc_compute']; vmfc_level_list = metadata['compute_dict']['vmfc_levels']. # Build size and slices dictionaries; fragment_size_dict = {; frag: metadata['molecule'].extract_subsets(frag).natom(); for frag in range(1, metadata['max_frag'] + 1); }; start = 0; fragment_slice_dict = {}; for k, v in fragment_size_dict.items():; fragment_slice_dict[k] = slice(start, start + v); start += v. molecule_total_atoms = sum(fragment_size_dict.values()). # Final dictionaries; cp_energy_by_level = {n: 0.0 for n in nbody_range}; nocp_energy_by_level = {n: 0.0 for n in nbody_range}. cp_energy_body_dict = {n: 0.0 for n in nbody_range}; nocp_energy_body_dict = {n: 0.0 for n in nbody_range}; vmfc_energy_body_dict = {n: 0.0 for n in nbody_range}. # Build out ptype dictionaries if needed; if metadata['ptype'] != 'energy':; if metadata['ptype'] == 'gradient':; arr_shape = (molecule_total_atoms, 3); elif metadata['ptype'] == 'hessian':; arr_shape = (molecule_total_atoms * 3, molecule_total_atoms * 3); else:; raise KeyError(""N-Body: ptype '%s' not recognized"" % ptype). cp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; else:; cp_ptype_by_level, cp_ptype_body_dict = {}, {}; nocp_ptype_by_level, nocp_ptype_body_dict = {}, {}; vmfc_ptype_body_dict = {}. # Sum up all of the levels; nbody_dict = {}; for n in nbody_range:. # Energy; # Extract energies for monomers in monomer basis for CP total data; if n == 1:; monomers_in_monomer_basis = [v for v in nocp_compute_list[1] if len(v[1]) == 1]; monomer_energies = 0.0; monomer_energy_list = []; f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:24377,Energy Efficiency,energy,energy,24377," monomer basis for CP total data; if n == 1:; monomers_in_monomer_basis = [v for v in nocp_compute_list[1] if len(v[1]) == 1]; monomer_energies = 0.0; monomer_energy_list = []; for i in monomers_in_monomer_basis:; monomer_energy_list.append(component_results['energies'][i]); monomer_energies += component_results['energies'][i]. cp_energy_by_level[n] = sum(component_results['energies'][v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(component_results['energies'][v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1)**(n - len(tup[0]))) * component_results['energies'][tup]. # Do ptype; if metadata['ptype'] != 'energy':; _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:24910,Energy Efficiency,energy,energy,24910,"ergy_by_level[n] = sum(component_results['energies'][v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(component_results['energies'][v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1)**(n - len(tup[0]))) * component_results['energies'][tup]. # Do ptype; if metadata['ptype'] != 'energy':; _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - mo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:25196,Energy Efficiency,energy,energy,25196,"ergies'][tup]. # Do ptype; if metadata['ptype'] != 'energy':; _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:25388,Energy Efficiency,energy,energy,25388,"ergies'][tup]. # Do ptype; if metadata['ptype'] != 'energy':; _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:25679,Energy Efficiency,energy,energy,25679,"uster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Tot",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:25898,Energy Efficiency,energy,energy,25898,"). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; i",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:26070,Energy Efficiency,energy,energy,26070,"'ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:26864,Energy Efficiency,energy,energy,26864,"omer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_di",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:27055,Energy Efficiency,energy,energy,27055,"omer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_di",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:27341,Energy Efficiency,energy,energy,27341," nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc ptype; if 'vmfc' in metadata['bsse_type_list']:; if metadata['ptype'] != 'energy':; for n in nbody_range:; if n > 1:; vmfc_ptype_body_dict[n] = vmfc_ptype_by_level[n - 1]; vmfc_ptype_body_dict[n] += vmfc_ptype_by_level[n]. _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)"",; metadata['embedding_charges']); vmfc_interaction_ene",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:28084,Energy Efficiency,energy,energy,28084,"[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)"", metadata['embedding_charges']); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc ptype; if 'vmfc' in metadata['bsse_type_list']:; if metadata['ptype'] != 'energy':; for n in nbody_range:; if n > 1:; vmfc_ptype_body_dict[n] = vmfc_ptype_by_level[n - 1]; vmfc_ptype_body_dict[n] += vmfc_ptype_by_level[n]. _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)"",; metadata['embedding_charges']); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; if monomer_energies != 0.0:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:30050,Energy Efficiency,energy,energy,30050,"body_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; if monomer_energies != 0.0:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items()}; else:; results['%s_energy_body_dict' % b] = {}. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if metadata['return_total_data']:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; else:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; results['ret_energy'] -= results['energy_body_dict'][1]. if metadata['ptype'] != 'energy':; if metadata['return_total_data']:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); else:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); np_final_ptype -= results['ptype_body_dict'][1]. results['ret_ptype'] = core.Matrix.from_array(np_final_ptype); else:; results['ret_ptype'] = results['ret_energy']. if monomer_energies == 0.0:; del results['energy_body_dict']. return results. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:3896,Integrability,depend,depending,3896,"essian How did you end up here?""). def _print_nbody_energy(energy_body_dict, header, embedding=False):; core.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); core.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; if previous_e == 0.0:; tot_e = False; else:; tot_e = True; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indica",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:10229,Modifiability,variab,variables,10229," now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = core.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = metadata['bsse_type_list'][0]; if len(metadata['bsse_type_list']) > 1:; bsse_str = str(metadata['bsse_type_list']); core.print_out(""\n\n""); core.print_out("" ===> N-Body Interaction Abacus <===\n""); core.print_out("" BSSE Treatment: %s\n"" % bsse_str). # Get compute list; metadata = build_nbody_compute_list(metadata). # Compute N-Body components; component_results = compute_nbody_components(func, method_string, metadata). # Assemble N-Body quantities; nbody_results = assemble_nbody_components(metadata, component_results). # Build wfn and bind variables; wfn = core.Wavefunction.build(metadata['molecule'], 'def2-svp'); dicts = [; 'energies', 'ptype', 'intermediates', 'energy_body_dict', 'gradient_body_dict', 'hessian_body_dict', 'nbody',; 'cp_energy_body_dict', 'nocp_energy_body_dict', 'vmfc_energy_body_dict'; ]; if metadata['ptype'] == 'gradient':; wfn.set_gradient(nbody_results['ret_ptype']); nbody_results['gradient_body_dict'] = nbody_results['ptype_body_dict']; elif metadata['ptype'] == 'hessian':; nbody_results['hessian_body_dict'] = nbody_results['ptype_body_dict']; wfn.set_hessian(nbody_results['ret_ptype']); component_results_gradient = component_results.copy(); component_results_gradient['ptype'] = component_results_gradient['gradients']; metadata['ptype'] = 'gradient'; nbody_results_gradient = assemble_nbody_components(metadata, component_results_gradient); wfn.set_gradient(nbody_results_gradient['ret_ptype']); nbody_results['gradient_body_dict'] = nbody_results_gradient['ptype_body_dict']. for r in [component_resul",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:18180,Modifiability,variab,variable,18180,"bedding_charges'] = driver_nbody_helper.compute_charges(kwargs['charge_method'],; kwargs.get('charge_type', 'MULLIKEN_CHARGES').upper(), molecule); for count, n in enumerate(compute_list.keys()):; core.print_out(""\n ==> N-Body: Now computing %d-body complexes <==\n\n"" % n); total = len(compute_list[n]); for num, pair in enumerate(compute_list[n]):; core.print_out(; ""\n N-Body: Computing complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); current_mol.set_name(""%s_%i_%i"" % (current_mol.name(), count, num)); if metadata['embedding_charges']: driver_nbody_helper.electrostatic_embedding(metadata, pair=pair); # Save energies info; ptype_dict[pair], wfn = func(method_string, molecule=current_mol, return_wfn=True, **kwargs); core.set_global_option_python('EXTERN', None); energies_dict[pair] = core.variable(""CURRENT ENERGY""); gradients_dict[pair] = wfn.gradient(); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ', '.join(; [str(i) for i in pair[1]])); intermediates_dict[var_key] = core.variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % (str(; pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure whic",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:18406,Modifiability,variab,variable,18406," ==> N-Body: Now computing %d-body complexes <==\n\n"" % n); total = len(compute_list[n]); for num, pair in enumerate(compute_list[n]):; core.print_out(; ""\n N-Body: Computing complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); current_mol.set_name(""%s_%i_%i"" % (current_mol.name(), count, num)); if metadata['embedding_charges']: driver_nbody_helper.electrostatic_embedding(metadata, pair=pair); # Save energies info; ptype_dict[pair], wfn = func(method_string, molecule=current_mol, return_wfn=True, **kwargs); core.set_global_option_python('EXTERN', None); energies_dict[pair] = core.variable(""CURRENT ENERGY""); gradients_dict[pair] = wfn.gradient(); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ', '.join(; [str(i) for i in pair[1]])); intermediates_dict[var_key] = core.variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % (str(; pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure which has generated the N-body components to be combined.; ``'bsse_type_list'``: list of str; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``:",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:12052,Performance,perform,performed,12052,"ponents(metadata, component_results_gradient); wfn.set_gradient(nbody_results_gradient['ret_ptype']); nbody_results['gradient_body_dict'] = nbody_results_gradient['ptype_body_dict']. for r in [component_results, nbody_results]:; for d in r:; if d in dicts:; for var, value in r[d].items():; try:; wfn.set_scalar_variable(str(var), value); core.set_scalar_variable(str(var), value); except:; wfn.set_array_variable(d.split('_')[0].upper() + ' ' + str(var), core.Matrix.from_array(value)). core.set_variable(""CURRENT ENERGY"", nbody_results['ret_energy']); wfn.set_variable(""CURRENT ENERGY"", nbody_results['ret_energy']); if metadata['ptype'] == 'gradient':; core.set_variable(""CURRENT GRADIENT"", nbody_results['ret_ptype']); elif metadata['ptype'] == 'hessian':; core.set_variable(""CURRENT HESSIAN"", nbody_results['ret_ptype']). if metadata['return_wfn']:; return (nbody_results['ret_ptype'], wfn); else:; return nbody_results['ret_ptype']. def build_nbody_compute_list(metadata):; """"""Generates the list of N-Body computations to be performed for a given BSSE type. Parameters; ----------; metadata : dict of str; Dictionary containing N-body metadata. Required ``'key': value`` pairs:; ``'bsse_type_list'``: list of str; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``: int; Maximum number of bodies to include in the N-Body treatment.; Possible: `max_nbody` <= `max_frag`; Default: `max_nbody` = `max_frag`; ``'max_frag'``: int; Number of distinct fragments comprising full molecular supersystem. Returns; -------; metadata : dict of str; Dictionary containing N-body metadata. New ``'key': value`` pair:; ``'compute_dict'`` : dict of str: dict; Dictionary containing subdicts enumerating compute lists for each possible BSSE treatment. Contents:; ``'all'``: dict of int: set; Set containing full list of computations required; ``'cp'``: dict of int: set; Set containing list of computations required for CP procedure; ``'no",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:16111,Performance,perform,perform,16111,"range}; for n in nbody_range:; compute_list[n] |= cp_compute_list[n]; compute_list[n] |= nocp_compute_list[n]; compute_list[n] |= vmfc_compute_list[n]; core.print_out("" Number of %d-body computations: %d\n"" % (n, len(compute_list[n]))). metadata['compute_dict'] = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }. return metadata. def compute_nbody_components(func, method_string, metadata):; """"""Computes requested N-body components. Performs requested computations for psi4::Molecule object `molecule` according to; `compute_list` with function `func` at `method_string` level of theory. Parameters; ----------; func : str; {'energy', 'gradient', 'hessian'}; Function object to be called within N-Body procedure.; method_string : str; Indicates level of theory to be passed to function `func`.; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'compute_list'``: dict of int: set; List of computations to perform. Keys indicate body-levels, e.g,. `compute_list[2]` is the; list of all 2-body computations required.; ``'kwargs'``: dict; Arbitrary keyword arguments to be passed to function `func`. Returns; -------; dict of str: dict; Dictionary containing computed N-body components. Contents:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; """"""; # Get required metadata; kwargs = metadata['kwargs']; molecule = metadata['molecule']; #molecule = core.get_active_molecule(); compute_list = metadata['compute_dict']['all']. # Now compute the energies; energies_dict = {}; gradients_dic",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:9246,Testability,test,testing,9246,"); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); if metadata['molecule'].nfragments() == 1:; raise ValidationError(""N-Body requires active molecule to have more than 1 fragment.""); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = core.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = metadata['bsse_type_list'][0]; if len(metadata['bsse_type_list']) > 1:; bsse_str = str(metadata['bsse_type_list']); core.print_out(""\n\n""); core.print_out("" ===> N-Body Interaction Abacus <===\n""); core.print_out("" BSSE Treatment: %s\n"" % bsse_str). # Get compute list; metadata = build_nbody_compute_list(metadata). # Compute N-Body components; component_results = compute_nbody_components(func, method_string, metadata). # Assemble N-Body quantities; nbody_results = assemble_nbody_components(metadata, component_results). # Build wfn and bind variables; wfn = core.Wavefunction.build(metadata['molecule'], 'def2-svp'); dicts = [; 'energies', '",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:18609,Testability,test,testing,18609,"complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); current_mol.set_name(""%s_%i_%i"" % (current_mol.name(), count, num)); if metadata['embedding_charges']: driver_nbody_helper.electrostatic_embedding(metadata, pair=pair); # Save energies info; ptype_dict[pair], wfn = func(method_string, molecule=current_mol, return_wfn=True, **kwargs); core.set_global_option_python('EXTERN', None); energies_dict[pair] = core.variable(""CURRENT ENERGY""); gradients_dict[pair] = wfn.gradient(); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ', '.join(; [str(i) for i in pair[1]])); intermediates_dict[var_key] = core.variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % (str(; pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {; 'energies': energies_dict,; 'gradients': gradients_dict,; 'ptype': ptype_dict,; 'intermediates': intermediates_dict; }. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure which has generated the N-body components to be combined.; ``'bsse_type_list'``: list of str; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``: int; Maximum number of bodies to include in the N-Body treatment.; Possible: `max_nbody` <= `max_frag`; Default: `max_nbody` = `max_frag`; ``'max_frag'``: int; Number of dis",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16436,Availability,error,error,16436,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16624,Availability,error,error,16624,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16785,Availability,error,error,16785,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:25766,Deployability,update,updated,25766,"; imports = '\n'.join(future_imports) + '\n'; imports += 'import psi4\n'; imports += 'from psi4 import *\n'; imports += 'from psi4.core import *\n'; imports += 'from psi4.driver.diatomic import anharmonicity\n'; imports += 'from psi4.driver.gaussian_n import *\n'; imports += 'from psi4.driver.frac import ip_fitting, frac_traverse\n'; imports += 'from psi4.driver.aliases import *\n'; imports += 'from psi4.driver.driver_cbs import *\n'; imports += 'from psi4.driver.wrapper_database import database, db, DB_RGT, DB_RXN\n'; imports += 'from psi4.driver.wrapper_autofrag import auto_fragments\n'; imports += 'psi4_io = core.IOManager.shared_object()\n'. # psirc (a baby PSIthon script that might live in ~/.psi4rc); psirc_file = os.path.expanduser('~') + os.path.sep + '.psi4rc'; if os.path.isfile(psirc_file):; fh = open(psirc_file); psirc = fh.read(); fh.close(); psirc = psirc.replace('psi4.IOManager', 'psi4.core.IOManager'); psirc += ""\npsi4.core.print_out('Warning: As of v1.5, the ~/.psi4rc file will no longer be read into Psi4 input.\\n')\n""; else:; psirc = ''. blank_mol = 'geometry(""""""\n'; blank_mol += '0 1\nH 0 0 0\nH 0.74 0 0\n'; blank_mol += '"""""",""blank_molecule_psi4_yo"")\n'. temp = imports + psirc + blank_mol + temp. # Move up the psi4.core namespace; for func in dir(core):; temp = temp.replace(""psi4."" + func, ""psi4.core."" + func). # Move pseudonamespace for physconst into proper namespace; from psi4.driver import constants; for pc in dir(constants):; if not pc.startswith('__'):; temp = temp.replace('psi_' + pc, 'psi4.constants.' + pc). return temp. if __name__ == ""__main__"":; result = process_input(""""""; molecule h2 {; H; H 1 R. R = .9; }. set basis 6-31G**. """"""). print(""Result\n==========================""); print(result). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.inputparser. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:13456,Energy Efficiency,charge,charge,13456,"e:; lines2.append(line); lines = lines2. # 1. Look for units [ang|bohr|au|a.u.] defaults to ang; re_units = re.compile(r'^\s*units?[\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\.u\.))$\s*', re.IGNORECASE); units = 'ang'; lines2 = []; for line in lines:; mobj = re_units.match(line); if mobj:; unit = mobj.group(1); if unit in ['bohr', 'au', 'a.u.']:; units = 'bohr'; else:; units = 'ang'; else:; lines2.append(line); lines = lines2. # 2. Look for basis basisname, defaults to cc-pvdz; # 3. Look for df_basis_scf basisname, defaults to cc-pvdz-jkfit; re_basis = re.compile(r'\s*basis[\s=]+(\S+)\s*$', re.IGNORECASE); re_df_basis = re.compile(r'\s*df_basis_scf[\s=]+(\S+)\s*$', re.IGNORECASE); basis = 'cc-pvdz'; df_basis_scf = 'cc-pvdz-jkfit'; lines2 = []; for line in lines:; mobj = re_basis.match(line); if mobj:; basis = mobj.group(1); else:; mobj = re_df_basis.match(line); if mobj:; df_basis_scf = mobj.group(1); else:; lines2.append(line); lines = lines2. # 4. Look for charge lines Z x y z, convert according to unit convention; charge_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$'); lines2 = []; for line in lines:; mobj = charge_re.match(line); if mobj:; if units == 'ang':; extern += '%sqmmm.addChargeAngstrom(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2),; mobj.group(3), mobj.group(4)); if units == 'bohr':; extern += '%sqmmm.addChargeBohr(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2), mobj.group(3),; mobj.group(4)); else:; lines2.append(line); lines = lines2. # 5. Look for diffuse regions, which are XYZ molecules seperated by the usual -- lines; spacer_re = re.compile(r'^\s*--\s*$'); frags = []; frags.append([]); for line in lines:; mobj = spacer_re.match(line); if mobj:; if len(frags[len(frags) - 1]):; frags.append([]); else:; frags[len(frags) - 1].append(line). extern += '%sextern_mol_temp = core.get_active_molecule()\n' % (spaces). mol_re = re.compile(r'\s*\S+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:1698,Integrability,message,message,1698,"nty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:1778,Integrability,message,message,1778,"nty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:1867,Integrability,wrap,wrapping,1867,"icense for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar si",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2092,Integrability,message,message,2092,"with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and str",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2169,Integrability,message,message,2169,"with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and str",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2263,Integrability,wrap,wrap,2263,"++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2376,Integrability,wrap,wrapped,2376,"p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in k",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2528,Integrability,wrap,wrap,2528,"as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2759,Integrability,wrap,wraps,2759,"):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; if runalso:; core.set_global_option(key, dequotify(value)); return ""%score.set_global_option(\""%s\"", %s)\n"" % (spaces, key, value); else:; # It's a local option, so we need the module name in there too",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:10268,Integrability,message,message,10268,"= symbol_re.match(line); result += """"""%s mol.set_basis_by_symbol(""%s"", ""%s"", role=role)\n"""""" % \; (spaces, m.group('symbol'), m.group('basis')). elif label_re.match(line):; m = label_re.match(line); result += """"""%s mol.set_basis_by_label(""%s"", ""%s"", role=role)\n"""""" % \; (spaces, m.group('label'), m.group('basis')). elif all_re.match(line):; m = all_re.match(line); result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, m.group('basis')). else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if len(result.split('\n')) == 3:; # case with no [basname] markers where whole block is contents of gbs file; result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, name); result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(name), basblock[0]); else:; message = (""Conflicting basis set specification: assign lines present but shells have no [basname] label.""""""); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(basblock[idx]), basblock[idx + 1]). result += """"""%s return basstrings\n"""""" % (spaces); result += """"""{}qcdb.libmintsbasisset.basishorde['{}'] = {}\n"""""" \; .format(spaces, name.upper(), 'basisspec_psi4_yo__' + cleanbas); result += """"""%score.set_global_option(\""%s\"", \""%s\"")"""""" % (spaces, basistype, name); return result. def process_pcm_command(matchobj):; """"""Function to process match of ``pcm name? { ... }``.""""""; spacing = str(matchobj.group(1)) # Ignore..; name = str(matchobj.group(2)) # Ignore..; block = str(matchobj.group(3)) # Get input to PCMSolver; suffix = str(os.getpid()) + '.' + str(uuid.uuid4())[:8]; pcmsolver_fname = 'pcmsolv",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:10405,Integrability,message,message,10405,"% \; (spaces, m.group('label'), m.group('basis')). elif all_re.match(line):; m = all_re.match(line); result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, m.group('basis')). else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if len(result.split('\n')) == 3:; # case with no [basname] markers where whole block is contents of gbs file; result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, name); result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(name), basblock[0]); else:; message = (""Conflicting basis set specification: assign lines present but shells have no [basname] label.""""""); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(basblock[idx]), basblock[idx + 1]). result += """"""%s return basstrings\n"""""" % (spaces); result += """"""{}qcdb.libmintsbasisset.basishorde['{}'] = {}\n"""""" \; .format(spaces, name.upper(), 'basisspec_psi4_yo__' + cleanbas); result += """"""%score.set_global_option(\""%s\"", \""%s\"")"""""" % (spaces, basistype, name); return result. def process_pcm_command(matchobj):; """"""Function to process match of ``pcm name? { ... }``.""""""; spacing = str(matchobj.group(1)) # Ignore..; name = str(matchobj.group(2)) # Ignore..; block = str(matchobj.group(3)) # Get input to PCMSolver; suffix = str(os.getpid()) + '.' + str(uuid.uuid4())[:8]; pcmsolver_fname = 'pcmsolver.' + suffix + '.inp'; with open(pcmsolver_fname, 'w') as handle:; handle.write(block); import pcmsolver; parsed_pcm = pcmsolver.parse_pcm_input(pcmsolver_fname).splitlines(); os.remove(pcmsolver_fname); pcmsolver_parsed_fname = '@pcmsolver.' + suffix; write_input_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16418,Integrability,message,message,16418,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16488,Integrability,message,message,16488,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16606,Integrability,message,message,16606,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16695,Integrability,message,message,16695,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16767,Integrability,message,message,16767,". extern += '%score.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:16855,Integrability,message,message,16855,"_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:19310,Integrability,message,message,19310," expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; for line_count in range(input_start, len(input_lines)):; line = input_lines[line_count]; if re.match(stop_re, line):; input_stop = line_count; break. if input_start == -1 or input_stop == -1:; message = ('Cannot extract infile from outfile.'); raise TestComparisonError(message). raw_input = '\n'.join(input_lines[input_start:input_stop]); raw_input += '\n'. # Echo the infile on the outfile; if print_level > 0:; core.print_out(""\n ==> Input File <==\n\n""); core.print_out(""--------------------------------------------------------------------------\n""); core.print_out(raw_input); core.print_out(""--------------------------------------------------------------------------\n""); core.flush_outfile(). #NOTE: If adding mulitline data to the preprocessor, use ONLY the following syntax:; # function [objname] { ... }; # which has the regex capture group:; #; # r'^(\s*?)FUNCTION\s*(\w*?)\s*\{(.*?)\}', re.MULTILINE | re.DOTALL | re.IGNORECASE; #; # your function is in capture group #1; # your objname is in capture group #2; # your data is in capture group #3. # Sections that are truly to be taken literally (spaces included); # Must be stored then subbed in the end to escape the normal processi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:19387,Integrability,message,message,19387,"replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; for line_count in range(input_start, len(input_lines)):; line = input_lines[line_count]; if re.match(stop_re, line):; input_stop = line_count; break. if input_start == -1 or input_stop == -1:; message = ('Cannot extract infile from outfile.'); raise TestComparisonError(message). raw_input = '\n'.join(input_lines[input_start:input_stop]); raw_input += '\n'. # Echo the infile on the outfile; if print_level > 0:; core.print_out(""\n ==> Input File <==\n\n""); core.print_out(""--------------------------------------------------------------------------\n""); core.print_out(raw_input); core.print_out(""--------------------------------------------------------------------------\n""); core.flush_outfile(). #NOTE: If adding mulitline data to the preprocessor, use ONLY the following syntax:; # function [objname] { ... }; # which has the regex capture group:; #; # r'^(\s*?)FUNCTION\s*(\w*?)\s*\{(.*?)\}', re.MULTILINE | re.DOTALL | re.IGNORECASE; #; # your function is in capture group #1; # your objname is in capture group #2; # your data is in capture group #3. # Sections that are truly to be taken literally (spaces included); # Must be stored then subbed in the end to escape the normal processing. # Process ""cfour name? { ... }""; cfour = re.compile(r'^(\s*?)",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:1985,Modifiability,variab,variable,1985,"oftware Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+)",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2119,Modifiability,variab,variable,2119,"with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and str",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2625,Modifiability,variab,variables,2625,"as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:2858,Modifiability,variab,variables,2858,"):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and string[-1] == '""':; return string[1:-1]; else:; return string. def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; if runalso:; core.set_global_option(key, dequotify(value)); return ""%score.set_global_option(\""%s\"", %s)\n"" % (spaces, key, value); else:; # It's a local option, so we need the module name in there too",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:1240,Security,access,access,1240,"oftware package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:18155,Security,validat,validate,18155,"parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]def process_input(raw_input, print_level=1):; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; *raw_input* is printed to the output file unless *print_level* =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:1543,Availability,avail,available,1543,"nse as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; import time. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. class IPIBroker(Client):; def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:1628,Availability,avail,available,1628,"s distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; import time. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. class IPIBroker(Client):; def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:4764,Deployability,update,updated,4764,"len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:2918,Energy Efficiency,energy,energy,2918,"lf.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done befo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:3856,Energy Efficiency,energy,energy,3856,"len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:1169,Integrability,interface,interfaces,1169,"LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2019 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; import time. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. class IPIBroker(Client):; def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_gro",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:3550,Modifiability,variab,variable,3550,"core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:1295,Testability,test,testing,1295,"or code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; import time. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. class IPIBroker(Client):; def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:2049,Testability,assert,assert,2049,"loor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; import time. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. class IPIBroker(Client):; def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule i",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:2137,Testability,assert,assert,2137,"t time. import numpy as np. import psi4; try:; from ipi.interfaces.clients import Client; ipi_available = True; except ImportError:; ipi_available = False. # Define Client to enable testing of the Broker in the unittests; class Client():; pass. class IPIBroker(Client):; def __init__(self, LOT, options=None, serverdata=False, molecule=None):; self.serverdata = serverdata; if not ipi_available:; psi4.core.print_out(""i-pi is not available for import: ""); psi4.core.print_out(""The broker infrastructure will not be available!\n""); super(IPIBroker, self).__init__(); elif serverdata:; mode, address, port = serverdata.split("":""); mode = mode.lower(); super(IPIBroker, self).__init__(address=address, port=port, mode=mode); else:; super(IPIBroker, self).__init__(_socket=False); self.LOT = LOT; self.options = options if options else {}. if molecule is None:; molecule = psi4.core.get_active_molecule(); self.initial_molecule = molecule; assert self.initial_molecule.orientation_fixed() == True, ""Orientation must be fixed!""; assert self.initial_molecule.point_group().symbol() == ""c1"", ""Symmetry must be 'c1'!"". names = [self.initial_molecule.symbol(i) for i in range(self.initial_molecule.natom())]; psi4.core.print_out(""Initial atoms %s\n"" % names); self.atoms_list = names. psi4.core.print_out(""Psi4 options:\n""); for item, value in self.options.items():; psi4.core.print_out(""%s %s\n"" % (item, value)); psi4.core.set_global_option(item, value); psi4.core.IO.set_default_namespace(""xwrapper""). self.timing = {}. atoms = np.array(self.initial_molecule.geometry()); psi4.core.print_out(""Initial atoms %s\n"" % atoms); psi4.core.print_out(""Force:\n""); self._positions = atoms; self._callback = self.callback; self._nat = np.int32(len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule()",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:13099,Deployability,configurat,configuration,13099,"iplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arguments: MDI configuration options; """"""; MDI_Init(mdi_arguments). [docs]def mdi_run(scf_method, **kwargs):; """""" Begin functioning as an MDI engine. Arguments:; scf_method: Method used when calculating energies or gradients; """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:13558,Deployability,update,updated,13558,"iplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arguments: MDI configuration options; """"""; MDI_Init(mdi_arguments). [docs]def mdi_run(scf_method, **kwargs):; """""" Begin functioning as an MDI engine. Arguments:; scf_method: Method used when calculating energies or gradients; """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:1950,Energy Efficiency,energy,energy,1950,"if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """"""; import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2246,Energy Efficiency,energy,energy,2246,"numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geom",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2259,Energy Efficiency,energy,energy,2259,"celemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2323,Energy Efficiency,charge,charges,2323,"di = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2376,Energy Efficiency,charge,charges,2376,"ld_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI command",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2471,Energy Efficiency,charge,charges,2471,"MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2520,Energy Efficiency,charge,chargefield,2520,"; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSE",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2627,Energy Efficiency,charge,charges,2627,"pi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<ENERGY"": self.send_energy,; ""<FORCES"": self.send_forces,; "">COORDS"": self.recv_c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5094,Energy Efficiency,charge,charges,5094,"ULT""); for command in self.commands.keys():; MDI_Register_Command(""@DEFAULT"", command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5126,Energy Efficiency,charge,charges,5126,"command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.ener",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5142,Energy Efficiency,charge,charges,5142,"command). def length_conversion(self):; """""" Obtain the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.ener",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5187,Energy Efficiency,charge,charges,5187,"n the conversion factor between the geometry specification units and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5212,Energy Efficiency,charge,charge,5212," and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """"""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5263,Energy Efficiency,charge,charges,5263," and bohr. :returns: *unit_conv* Conversion factor between the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """"""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:5310,Energy Efficiency,charge,charges,5310,"tween the geometry specification units and bohr; """"""; unit_name = self.molecule.units(); if unit_name == ""Angstrom"":; unit_conv = qcel.constants.bohr2angstroms; elif unit_name == ""Bohr"":; unit_conv = 1.0; else:; raise Exception('Unrecognized unit type: ' + str(unit_name)). return unit_conv. # Respond to the <NATOMS command; def send_natoms(self):; """""" Send the number of atoms through MDI; """"""; natom = self.molecule.natom(); MDI_Send(natom, 1, MDI_INT, self.comm); return natom. # Respond to the <COORDS command; def send_coords(self):; """""" Send the nuclear coordinates through MDI; """"""; coords = self.molecule.geometry().np.ravel(); MDI_Send(coords, len(coords), MDI_DOUBLE, self.comm); return coords. # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forc",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6042,Energy Efficiency,energy,energy,6042," # Respond to the <CHARGES command; def send_charges(self):; """""" Send the nuclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom <",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6073,Energy Efficiency,energy,energy,6073,"uclear charges through MDI. :returns: *charges* Atomic charges; """"""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.n",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6138,Energy Efficiency,energy,energy,6138,"""""; natom = self.molecule.natom(); charges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms whe",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6185,Energy Efficiency,energy,energy,6185,"harges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6561,Energy Efficiency,charge,charges,6561,"OUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MD",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6606,Energy Efficiency,charge,charges,6606,"OUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MD",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6692,Energy Efficiency,charge,charges,6692,"tomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.se",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6713,Energy Efficiency,charge,charges,6713,"tomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.se",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6792,Energy Efficiency,charge,charges,6792,"m(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nucle",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6810,Energy Efficiency,charge,charges,6810,"m(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nucle",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6873,Energy Efficiency,charge,charge,6873,", natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nu",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:7214,Energy Efficiency,charge,charges,7214,"command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:8471,Energy Efficiency,charge,charges,8471,"olecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE comman",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:8543,Energy Efficiency,charge,charges,8543,"olecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE comman",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9137,Energy Efficiency,charge,charges,9137,"f all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the latti",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9200,Energy Efficiency,charge,charges,9200,"lf.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MD",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9621,Energy Efficiency,charge,charges,9621,"ion received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *di",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9704,Energy Efficiency,charge,charges,9704," in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm)",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9988,Energy Efficiency,charge,charges,9988,"lf.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Res",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10022,Energy Efficiency,charge,charges,10022,"lf.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Res",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10068,Energy Efficiency,charge,charges,10068,"elf, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10100,Energy Efficiency,charge,charges,10100,"elf, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10347,Energy Efficiency,energy,energy,10347,"ttice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT comman",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10377,Energy Efficiency,energy,energy,10377,"nge(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electro",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10391,Energy Efficiency,energy,energy,10391,"nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplic",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10791,Energy Efficiency,charge,charge,10791,"lattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10822,Energy Efficiency,charge,charge,10822,":; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10836,Energy Efficiency,charge,charge,10836,":; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10863,Energy Efficiency,charge,charge,10863,":; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10915,Energy Efficiency,charge,charge,10915," >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10957,Energy Efficiency,charge,charge,10957,"f, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:11030,Energy Efficiency,charge,charge,11030,"s through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:11074,Energy Efficiency,charge,charge,11074,"s through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:11106,Energy Efficiency,charge,charge,11106,", receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if se",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:11118,Energy Efficiency,charge,charge,11118,", receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if se",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:11179,Energy Efficiency,charge,charge,11179,"ce, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:11196,Energy Efficiency,charge,charge,11196,"ce, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:11286,Energy Efficiency,charge,charge,11286,"e_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:12080,Energy Efficiency,charge,charges,12080,"h MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arg",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2539,Modifiability,variab,variables,2539,"ass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:13099,Modifiability,config,configuration,13099,"iplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arguments: MDI configuration options; """"""; MDI_Init(mdi_arguments). [docs]def mdi_run(scf_method, **kwargs):; """""" Begin functioning as an MDI engine. Arguments:; scf_method: Method used when calculating energies or gradients; """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:1971,Performance,optimiz,optimization,1971,"if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """"""; import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:2054,Performance,perform,performed,2054,"on, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """"""; import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6909,Safety,avoid,avoid,6909,", natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nu",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:8116,Safety,avoid,avoid,8116," number of ghost atoms when receiving masses'); self.molecule.set_nuclear_charge(iatom, charges[jatom]); jatom = jatom + 1. # Respond to the >COORDS command; def recv_coords(self, coords=None):; """""" Receive a set of nuclear coordinates through MDI and assign them to the atoms in the current molecule. Arguments:; coords: New nuclear coordinates. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if coords is None:; coords = MDI_Recv(3 * natom, MDI_DOUBLE, self.comm); matrix = psi4.core.Matrix.from_array(np.array(coords).reshape(-1, 3)); self.molecule.set_geometry(matrix). # Respond to the >MASSES command; def recv_masses(self, masses=None):; """""" Receive a set of nuclear masses through MDI and assign them to the atoms in the current molecule. Arguments:; masses: New nuclear masses. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if masses is None:; masses = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the mass of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of latt",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:3241,Availability,error,error,3241,"). @classmethod; def _molecule_from_string(cls,; molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def _molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:7472,Deployability,install,install,7472,"y this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); if ""geom"" in molrec[""qm""]:; geom = np.array(molrec[""qm""][""geom""]).reshape((-1, 3)); if molrec[""qm""][""units""] == ""Angstrom"":; geom = geom / qcel.constants.bohr2angstroms; molecule._initial_cartesian = core.Matrix.from_array(geom); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.molutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:8400,Deployability,update,updated,8400,"y this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); if ""geom"" in molrec[""qm""]:; geom = np.array(molrec[""qm""][""geom""]).reshape((-1, 3)); if molrec[""qm""][""units""] == ""Angstrom"":; geom = geom / qcel.constants.bohr2angstroms; molecule._initial_cartesian = core.Matrix.from_array(geom); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.molutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:3427,Integrability,wrap,wrapper,3427,"try=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def _molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:4837,Integrability,wrap,wrapper,4837,"ass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec), molrec; else:; return core.Molecule.from_dict(molrec). @classmethod; def _molecule_from_schema(cls, molschema: Dict, return_dict: bool = False, nonphysical: bool = False, verbose: int = 1) -> Union[core.Molecule, Tuple[core.Molecule, Dict]]:; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~psi4.core.Molecule.from_arrays`. Parameters; ----------; molschema; Dictionary form of Molecule following known schema.; return_dict; Additionally return Molecule dictionary intermediate.; nonphysical; Do allow masses outside an element's natural range to pass validation?; verbose; Amount of printing. Returns; -------; mol : :py:class:`psi4.core.Molecule`; molrec : dict; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_schema(molschema, nonphysical=nonphysical, verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.to_arrays = qcdb.Molecule.to_arrays; c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:3410,Modifiability,variab,variables,3410,"ame=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def _molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooc",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:7947,Modifiability,variab,variables,7947,"y this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); if ""geom"" in molrec[""qm""]:; geom = np.array(molrec[""qm""][""geom""]).reshape((-1, 3)); if molrec[""qm""][""units""] == ""Angstrom"":; geom = geom / qcel.constants.bohr2angstroms; molecule._initial_cartesian = core.Matrix.from_array(geom); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.molutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:5124,Security,validat,validation,5124,"nt_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec), molrec; else:; return core.Molecule.from_dict(molrec). @classmethod; def _molecule_from_schema(cls, molschema: Dict, return_dict: bool = False, nonphysical: bool = False, verbose: int = 1) -> Union[core.Molecule, Tuple[core.Molecule, Dict]]:; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~psi4.core.Molecule.from_arrays`. Parameters; ----------; molschema; Dictionary form of Molecule following known schema.; return_dict; Additionally return Molecule dictionary intermediate.; nonphysical; Do allow masses outside an element's natural range to pass validation?; verbose; Amount of printing. Returns; -------; mol : :py:class:`psi4.core.Molecule`; molrec : dict; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_schema(molschema, nonphysical=nonphysical, verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.to_arrays = qcdb.Molecule.to_arrays; cls.to_dict = qcdb.Molecule.to_dict; cls.BFS = qcdb.Molecule.BFS; cls.B787 = qcdb.Molecule.B787; cls.scramble = qcdb.Molecule.scramble; cls.from_arrays = _molecule_from_arrays; cls.from_string = _molecule_from_string; cls.to_string = qcdb.Molecule.to_string; c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3048,Availability,error,error,3048,", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.e",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3294,Availability,avail,available,3294,"odule"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = te",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:4020,Availability,error,error,4020,"e"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = con",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:4891,Availability,error,error,4891,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:4957,Availability,error,error,4957,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:5366,Availability,error,error,5366,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:5424,Availability,error,error,5424,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:5732,Deployability,update,updated,5732,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:2606,Integrability,synchroniz,synchronized,2606,"of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugin",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:15,Modifiability,plugin,pluginutil,15,"﻿. psi4.driver.pluginutil. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. Source code for psi4.driver.pluginutil; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import sys. from psi4 import core; from psi4.driver.util.filesystem import *; from psi4.driver.util import tty. [docs]def sanitize_name(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:110,Modifiability,plugin,pluginutil,110,"﻿. psi4.driver.pluginutil. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. Source code for psi4.driver.pluginutil; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import sys. from psi4 import core; from psi4.driver.util.filesystem import *; from psi4.driver.util import tty. [docs]def sanitize_name(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:150,Modifiability,plugin,pluginutil,150,"﻿. psi4.driver.pluginutil. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. Source code for psi4.driver.pluginutil; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import sys. from psi4 import core; from psi4.driver.util.filesystem import *; from psi4.driver.util import tty. [docs]def sanitize_name(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3120,Modifiability,plugin,plugin,3120,"ete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3304,Modifiability,plugin,plugins,3304,"odule"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = te",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3407,Modifiability,plugin,plugin,3407,""", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(tar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3609,Modifiability,plugin,plugin,3609," ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3712,Modifiability,plugin,plugin,3712,"peid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = so",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3972,Modifiability,plugin,plugin,3972,", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err);",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:5012,Modifiability,plugin,plugin,5012,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:5467,Modifiability,plugin,plugin,5467,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:5678,Modifiability,plugin,pluginutil,5678,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:1474,Security,sanitiz,sanitized,1474,"# it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import sys. from psi4 import core; from psi4.driver.util.filesystem import *; from psi4.driver.util import tty. [docs]def sanitize_name(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""req",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3634,Security,sanitiz,sanitized,3634," ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:1109,Deployability,integrat,integrate,1109,"code for psi4.driver.qmmm; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisn",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:5063,Deployability,update,updated,5063,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:1122,Energy Efficiency,charge,charges,1122,"code for psi4.driver.qmmm; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisn",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:1697,Energy Efficiency,charge,charges,1697,"NY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:2233,Energy Efficiency,energy,energy,2233,"ecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:2756,Energy Efficiency,charge,charges,2756,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:3512,Energy Efficiency,charge,charges,3512,"revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.di",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:3654,Energy Efficiency,charge,charge,3654,"typeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:3785,Energy Efficiency,charge,charge,3785,"ion density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charg",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:3854,Energy Efficiency,charge,charges,3854,"\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:3960,Energy Efficiency,charge,charge,3960,"etParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. mo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4034,Energy Efficiency,charge,charges,4034,"CF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021,",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4311,Energy Efficiency,charge,charges,4311,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4372,Energy Efficiency,charge,charges,4372,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4392,Energy Efficiency,charge,charges,4392,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4412,Energy Efficiency,charge,charges,4412,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4432,Energy Efficiency,charge,charges,4432,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4632,Energy Efficiency,charge,charge,4632,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4697,Energy Efficiency,charge,charges,4697,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4726,Energy Efficiency,charge,charge,4726,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4741,Energy Efficiency,charge,charges,4741,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4773,Energy Efficiency,charge,charge,4773,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4784,Energy Efficiency,charge,charge,4784,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4795,Energy Efficiency,charge,charge,4795,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:4806,Energy Efficiency,charge,charge,4806,"; fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qmmm. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:1109,Integrability,integrat,integrate,1109,"code for psi4.driver.qmmm; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """""". from psi4.driver import *. class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisn",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html:2723,Performance,perform,perform,2723,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qmmm.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3251,Availability,avail,available,3251,"cripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Ind",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:4445,Availability,avail,available,4445,"efault performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:4471,Availability,avail,availableDatabases,4471,"efault performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:4734,Availability,avail,available,4734,"pe mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:4760,Availability,avail,availableDatabases,4760,"pe mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5619,Availability,avail,available,5619,"whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5644,Availability,avail,availableDatabases,5644,"whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5703,Availability,error,error,5703,"whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:6209,Availability,avail,availableDatabases,6209,"lean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculati",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:6233,Availability,avail,available,6233,"lean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculati",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:6809,Availability,avail,available,6809,"m']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7017,Availability,avail,available,7017," subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='sm",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13269,Availability,error,error,13269,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13608,Availability,avail,available,13608,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HR",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:14212,Availability,avail,available,14212,"Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:14424,Availability,avail,available,14424," = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Data",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:14648,Availability,avail,available,14648,"le for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """"",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:14936,Availability,avail,available,14936,"']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); core.print_out(instructions). # Loop through chemical systems;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:19870,Availability,error,error,19870," 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" %",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20052,Availability,error,error,20052,"tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS D",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20059,Availability,error,error,20059,"tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS D",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20216,Availability,error,error,20216," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20254,Availability,error,error,20254," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20268,Availability,error,error,20268," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20306,Availability,error,error,20306," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20325,Availability,error,error,20325," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20348,Availability,error,error,20348," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20369,Availability,error,error,20369," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:20377,Availability,error,error,20377," = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABA",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3825,Deployability,continuous,continuous,3825,"beled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; wit",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3972,Deployability,continuous,continuous,3972,"tr; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:11260,Deployability,continuous,continuous,11260,"; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:11327,Deployability,continuous,continuous,11327,"on.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise V",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:15579,Deployability,continuous,continuous,15579,") == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); core.print_out(instructions). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. core.print_out('\n'); p4util.banner(' Database {} Computation: Reagent {} \n {}'.format(db_name, rgt, TAGL[rgt])); core.print_out('\n'). molecule = core.Molecule.from_dict(GEOS[rgt].to_dict()); molecule.set_name(rgt); molecule.update_geometry(). if symmetry_override:; molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; core.set_global_option('REFERENCE', 'UHF'); elif user_reference == 'RKS':; c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:21498,Deployability,update,update,21498,"unt_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:21535,Deployability,update,update,21535," float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt')",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:22946,Deployability,update,updated,22946,".4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:1213,Energy Efficiency,energy,energy,1213,"e quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2947,Energy Efficiency,energy,energy,2947,"`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3363,Energy Efficiency,energy,energy,3363,"tures are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3519,Energy Efficiency,energy,energy,3519,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3652,Energy Efficiency,energy,energy,3652,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:4672,Energy Efficiency,energy,energy,4672,"es; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5318,Energy Efficiency,energy,energy,5318,"n energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the r",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5367,Energy Efficiency,energy,energy,5367,"n energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the r",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5799,Energy Efficiency,energy,energy,5799,"bases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Co",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5907,Energy Efficiency,energy,energy,5907,"symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7374,Energy Efficiency,energy,energy,7374,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish func",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7791,Energy Efficiency,energy,energy,7791," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7868,Energy Efficiency,energy,energy,7868," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7885,Energy Efficiency,energy,energy,7885," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:8039,Energy Efficiency,energy,energy,8039,"ult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:8059,Energy Efficiency,energy,energy,8059,"ult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:8432,Energy Efficiency,energy,energy,8432," S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:11692,Energy Efficiency,energy,energy,11692,"ll reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (d",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:12154,Energy Efficiency,energy,energy,12154," whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; r",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13730,Energy Efficiency,energy,energy,13730,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13797,Energy Efficiency,energy,energy,13797,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:19214,Energy Efficiency,energy,energy,19214,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minD",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:8203,Integrability,wrap,wrappers,8203,"age SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__));",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:1865,Modifiability,variab,variables,1865,"more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational metho",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2689,Modifiability,variab,variable,2689,"docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5863,Modifiability,variab,variables,5863,"symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5937,Modifiability,variab,variable,5937,"n'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || e",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:6064,Modifiability,flexible,flexible,6064,"``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input th",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:9036,Modifiability,extend,extend,9036,"ergy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.ge",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13701,Modifiability,variab,variables,13701,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:17278,Modifiability,variab,variable,17278,"entation(True); molecule.fix_com(True); molecule.update_geometry(). if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; core.set_global_option('REFERENCE', 'UHF'); elif user_reference == 'RKS':; core.set_global_option('REFERENCE', 'UKS'). core.set_global_option('WRITER_FILE_LABEL', user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). if allowoptexceeded:; try:; ERGT[rgt] = func(molecule=molecule, **kwargs); except ConvergenceError:; core.print_out(f""Optimization exceeded cycles for {rgt}""); ERGT[rgt] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); core.print_out("" Database Contributions Map:\n {}\n"".format('-' * 75)); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; core.print_out(' reagent {} contributes by {:.4f} to reaction {}\n'.format(rgt, RXNM[db_rxn][rgt], db_rxn)); core.print_out('\n'); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not mak",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:17998,Modifiability,variab,variables,17998,"[db_rxn]:; core.print_out(' reagent {} contributes by {:.4f} to reaction {}\n'.format(rgt, RXNM[db_rxn][rgt], db_rxn)); core.print_out('\n'); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:18256,Modifiability,variab,variable,18256,"envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:19221,Modifiability,variab,variable,19221,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minD",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:1238,Performance,optimiz,optimize,1238,"e package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3382,Performance,optimiz,optimize,3382,"tures are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3445,Performance,perform,performed,3445,"bal options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Opti",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3493,Performance,perform,performs,3493,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3546,Performance,optimiz,optimize,3546,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3576,Performance,optimiz,optimization,3576,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3619,Performance,perform,performs,3619,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7826,Performance,optimiz,optimize,7826," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'R",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:9354,Performance,load,load,9354,"ion to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' %",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:9516,Performance,load,load,9516,"y); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:9675,Performance,load,loading,9675,"exceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:1688,Security,access,access,1688,"# but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2098,Security,access,accessible,2098,"dation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2546,Security,access,access,2546,"docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5476,Testability,benchmark,benchmark,5476,"f bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5499,Testability,benchmark,benchmark,5499,"f bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7518,Testability,benchmark,benchmark,7518,"ilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:7582,Testability,benchmark,benchmark,7582,"ilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13250,Testability,benchmark,benchmark,13250,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13359,Testability,benchmark,benchmark,13359,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13405,Testability,benchmark,benchmark,13405,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:13587,Testability,benchmark,benchmark,13587,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HR",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:21482,Usability,clear,clear,21482,"Derror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:21519,Usability,clear,clear,21519," = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str +=",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:21934,Usability,simpl,simple,21934,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 20",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1409,Availability,error,error,1409,"rt of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg)",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1715,Availability,error,error,1715,"he implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecati",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1998,Availability,error,error,1998,"ion, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version,",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2309,Availability,error,error,2309,"siException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iterat",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2857,Availability,error,error,2857,"n.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:6246,Availability,avail,available,6246,"e running total of product evaluations that was performed; done : bool, if all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; modul",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:6490,Availability,avail,available,6490,"s from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7462,Availability,reliab,reliable,7462,"cs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2687,Deployability,release,release,2687," a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7471,Deployability,install,install,7471,"cs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7557,Deployability,install,install,7557,") == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7612,Deployability,install,installation,7612,") == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7874,Deployability,install,install,7874,"RENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; side",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7894,Deployability,install,install,7894,"RENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; side",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7928,Deployability,install,install,7928,"ion):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7936,Deployability,install,install,7936,"ion):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:8012,Deployability,install,install,8012,"ion):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:8085,Deployability,install,install,8085,"ssage = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:8973,Deployability,update,updated,8973,"ssage = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:4194,Energy Efficiency,energy,energy,4194," with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; Dictionary of convergence statistics of last iteration.; Keys are:. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1415,Integrability,message,message,1415,"rt of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg)",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1569,Integrability,message,message,1569,"; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; s",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1721,Integrability,message,message,1721,"he implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecati",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1849,Integrability,message,message,1849," more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and sug",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1977,Integrability,depend,dependencies,1977,"General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2004,Integrability,message,message,2004,"ion, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version,",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2133,Integrability,message,message,2133,"ptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2315,Integrability,message,message,2315,"siException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iterat",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2443,Integrability,message,message,2443,"ut file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Cou",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:3294,Integrability,rout,routine,3294," compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:3664,Integrability,message,message,3664," valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:5375,Integrability,message,message,5375,"v = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; Dictionary of convergence statistics of last iteration.; Keys are:. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:6122,Integrability,message,message,6122,"bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Err",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:6330,Integrability,message,message,6330,"t, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:6892,Integrability,message,message,6892,"nfo); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7048,Integrability,message,message,7048,"__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for mor",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:8717,Integrability,message,message,8717,"ssage = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:8785,Integrability,message,message,8785,"ssage = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:3831,Performance,optimiz,optimizer,3831,"yntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:5175,Performance,perform,performed,5175,"t; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; Dictionary of convergence statistics of last iteration.; Keys are:. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class Missi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:5257,Performance,perform,performed,5257,"t; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; Dictionary of convergence statistics of last iteration.; Keys are:. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class Missi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:7956,Safety,detect,detected,7956,"ion):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi4Pasture module(s) [{modlist}] are required to change the default value of {opt}. """"""; install_instructions = """"""; Note: Psi4Pasture is currently in an experimental state with no reliable install; procedure yet, but this is what it would look like. To Build Psi4Pasture and install the required modules within your current; Psi4 installation. >>> # clone the pasture repo; >>> git clone https://github.com/psi4/psi4pasture.git. >>> cmake -S. -Bobjdir -Dpsi4_DIR=$PSI4_INSTALL_PREFIX/share/cmake/psi4 {module_args}; >>> # $PSI4_INSTALL_PREFIX is the $CMAKE_INSTALL_PREFIX for the psi4; >>> # install you want to install pasture to. >>> # build + install install location is detected automatically; >>> cd objdir; >>> make && make install. See https://github.com/psi4/psi4pasture for more details. Or to install using psi4's own build system add; {module_args}; to cmake command line when building psi4.; """"""; pasture_required_modules = {""RUN_CCTRANSORT"": [""ccsort"", ""transqt2""]}. def __init__(self, option):; mods_str = "", "".join([m for m in PastureRequiredError.pasture_required_modules[option]]); msg = PastureRequiredError.msg_tmpl.format(opt=option, modlist=mods_str); PsiException.__init__(self, msg); module_cmake_args = "" "".join(; [""-DENABLE_{}=ON"".format(module) for module in PastureRequiredError.pasture_required_modules[option]]); msg += PastureRequiredError.install_instructions.format(module_args=module_cmake_args); self.message = '\nPsiException: {}\n\n'.format(msg); core.print_out(self.message). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.exceptions. © Copyright 2021, The Psi4 Project.;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2246,Testability,test,test,2246,"n):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Pa",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2592,Usability,simpl,simple,2592,"(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:2878,Availability,toler,tolerance,2878,"counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, digits, label):; # """"""Function to compare two FCHK files. # an older format description can be found here; # http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; # It lists more fields (logical, character) that are not included in this; # test function. They should be covered by the string comparison.; # This function is only meant to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix se",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:4659,Deployability,update,updated,4659,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:3236,Integrability,depend,dependence,3236,"file_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, digits, label):; # """"""Function to compare two FCHK files. # an older format description can be found here; # http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; # It lists more fields (logical, character) that are not included in this; # test function. They should be covered by the string comparison.; # This function is only meant to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; cal",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:1201,Testability,test,testing,1201,"yright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = ['fchkfile_to_string','compare_fchkfiles']. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; wi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:2588,Testability,log,logical,2588,"t64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, digits, label):; # """"""Function to compare two FCHK files. # an older format description can be found here; # http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; # It lists more fields (logical, character) that are not included in this; # test function. They should be covered by the string comparison.; # This function is only meant to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fch",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:2641,Testability,test,test,2641,"t64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, digits, label):; # """"""Function to compare two FCHK files. # an older format description can be found here; # http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; # It lists more fields (logical, character) that are not included in this; # test function. They should be covered by the string comparison.; # This function is only meant to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fch",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:2978,Testability,test,test,2978,":; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, digits, label):; # """"""Function to compare two FCHK files. # an older format description can be found here; # http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; # It lists more fields (logical, character) that are not included in this; # test function. They should be covered by the string comparison.; # This function is only meant to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:3261,Testability,test,tested,3261,"name, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, digits, label):; # """"""Function to compare two FCHK files. # an older format description can be found here; # http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; # It lists more fields (logical, character) that are not included in this; # test function. They should be covered by the string comparison.; # This function is only meant to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_i",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:3520,Testability,test,tests,3520,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:3784,Testability,test,test,3784,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:3867,Testability,test,test,3867,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:4063,Testability,test,test,4063,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:4251,Testability,test,test,4251,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:4329,Testability,test,test,4329,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:4417,Testability,test,tests,4417,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:4430,Testability,test,test,4430,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:4471,Testability,test,tests,4471,"to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1; tests.append(test). return compare_integers(True, all(tests), label). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fchk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12085,Availability,failure,failure,12085,"e = np.zeros((nbf, nbf)); Hcore[(idxs[sl, 0], idxs[sl, 1])] = ints[sl]; Hcore[(idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['hcore'] = Hcore. # Extract ERIs; sl = slice(0, sl.start); eri = np.zeros((nbf, nbf, nbf, nbf)); eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pas",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:15388,Deployability,update,updated,15388,"nergy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evir = epsilon[vir_sl]; denom = 1 / (eocc.reshape(-1, 1, 1, 1) - evir.reshape(-1, 1, 1) + eocc.reshape(-1, 1) - evir); MO = ERI[np.ix_(occ_sl, vir_sl, occ_sl, vir_sl)]; if unrestricted:; mp2_e = 0.5 * np.einsum(""abrs,abrs,abrs->"", MO, MO - MO.swapaxes(1, 3), denom); else:; mp2_e = np.einsum('iajb,iajb,iajb->', MO, MO, denom) + np.einsum('iajb,iajb,iajb->', MO - MO.swapaxes(1, 3),; MO, denom); return mp2_e. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.fcidump. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:2310,Energy Efficiency,energy,energy,2310,"testing import compare_integers, compare_values, compare_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`. :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file. So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:2440,Energy Efficiency,energy,energy,2440,"ions import ValidationError, TestComparisonError. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`. :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file. So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:8053,Energy Efficiency,energy,energy,8053," = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). [docs]def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbo",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:8117,Energy Efficiency,energy,energy,8117,"l]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). [docs]def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:9777,Energy Efficiency,energy,energy,9777,"merate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{: 29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1 B2 B3; 'c2v' : [1,4,2,3], # A1 A2 B1 B2; 'c2h' : [1,4,2,3], # Ag Bg Au Bu; 'd2h' : [1,4,6,7,8,5,3,2] # Ag B1g B2g B3g Au B1u B2u B3u; }. irrep_map = psi2dump[symm]; return np.array(irrep_map, dtype='int'). [docs]def fcidump_from_file(fname):; """"""Function to read in a FCIDUMP file. :returns: a dictionary with FCIDUMP header and integrals; - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'enuc' : nuclear repulsion plus frozen core energy; - 'epsilon' : orbital energies; - 'hcore' : core Hamiltonian; - 'eri' : electron-repulsion integrals. :param fname: FCIDUMP file name; """"""; intdump = {}; with open(fname, 'r') as handle:; assert '&FCI' == handle.readline().strip(). skiplines = 1; read = True; while True:; skiplines += 1; line = handle.readline(); if 'END' in line:; break. key, value = line.split('='); value = value.strip().rstrip(','); if key == 'UHF':; value = 'TRUE' in value; elif key == 'ORBSYM':; value = [int(x) for x in value.split(',')]; else:; value = int(value.replace(',', '')). intdump[key.lower()] = value. # Read the data and index, skip header; raw_ints = np.genfromtxt(fname, skip_header=skiplines). # Read last line, i.e. Enuc + Efzc; intdump['enuc'] = raw_ints[-1, 0]. # Read in integrals and indices; ints = raw_ints[:-1, 0]. # Get dimensions and indices; nbf = intdump['",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12267,Energy Efficiency,energy,energy,12267,"sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12318,Energy Efficiency,energy,energy,12318,"sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12369,Energy Efficiency,energy,energy,12369,"sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12410,Energy Efficiency,energy,energy,12410,"sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12463,Energy Efficiency,energy,energy,12463,"sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:13062,Energy Efficiency,energy,energy,13062," the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORR",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:13194,Energy Efficiency,energy,energy,13194,"sion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:13320,Energy Efficiency,energy,energy,13320," 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', E",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:13464,Energy Efficiency,energy,energy,13464,"on energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:13762,Energy Efficiency,energy,energy,13762,"e=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:14090,Energy Efficiency,energy,energy,14090,"NERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf and pass_mp2), label). [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evir = epsilon[vir_sl]; denom = 1 / (eocc.reshape(-1, 1, 1, 1) - evir.reshape(-1, 1, 1) + eocc.reshape(-1, 1) - evir); MO = ERI[np.ix_(occ_sl, vir_sl, occ_sl, vir_sl)]; if unrestricted:; mp2_e = 0.5 * np.einsum(""abrs,abrs,abrs->"", MO, MO - MO.swapaxes(1, 3), denom); else:; mp2_e = np.einsum('iajb,iajb,iajb->', MO, MO, den",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:5328,Performance,load,load,5328,"gralTransform(wfn, spaces, trans_type); ints.transform_tei(core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all()); core.print_out('Integral transformation complete!\n'). DPD_info = {'instance_id': ints.get_dpd_id(), 'alpha_MO': ints.DPD_ID('[A>=A]+'), 'beta_MO': 0}; if not wfn.same_a_b_orbs():; DPD_info['beta_MO'] = ints.DPD_ID(""[a>=a]+""); # Write TEI to fname in FCIDUMP format; core.fcidump_tei_helper(nirrep, wfn.same_a_b_orbs(), DPD_info, ints_tolerance, fname). # Read-in OEI and write them to fname in FCIDUMP format; # Indexing functions to translate from zero-based (C and Python) to; # one-based (Fortran); mo_idx = lambda x: x + 1; alpha_mo_idx = lambda x: 2 * x + 1; beta_mo_idx = lambda x: 2 * (x + 1). with open(fname, 'a') as intdump:; core.print_out('Writing frozen core operator in FCIDUMP format to ' + fname + '\n'); if reference == 'RHF':; PSIF_MO_FZC = 'MO-basis Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:6238,Performance,load,load,6238,"Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; i",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:6853,Performance,load,load,6853," oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:2655,Safety,sanity check,sanity checks,2655,"tegrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`. :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file. So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += 'NELEC={:d},\n'.format(nelectron); header += 'MS2={:d},\n'.format(wfn.nalpha() - wfn.nbeta()); header += 'UHF=.{}.,\n'.format(not wfn.same_a_b_orbs()).upper(); orbsym = ''; for h in range(active_mopi.n()):; for n in range(f",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:1290,Testability,test,testing,1290,"or code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility function for dumping the Hamiltonian to file in FCIDUMP format."""""". import numpy as np. from psi4.driver import psifiles as psif; from psi4.driver.p4util.testing import compare_integers, compare_values, compare_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`. :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file. So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', retur",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:9973,Testability,assert,assert,9973,"vention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = {'c1' : [1], # A; 'ci' : [1,2], # Ag Au; 'c2' : [1,2], # A B; 'cs' : [1,2], # A' A""; 'd2' : [1,4,3,2], # A B1 B2 B3; 'c2v' : [1,4,2,3], # A1 A2 B1 B2; 'c2h' : [1,4,2,3], # Ag Bg Au Bu; 'd2h' : [1,4,6,7,8,5,3,2] # Ag B1g B2g B3g Au B1u B2u B3u; }. irrep_map = psi2dump[symm]; return np.array(irrep_map, dtype='int'). [docs]def fcidump_from_file(fname):; """"""Function to read in a FCIDUMP file. :returns: a dictionary with FCIDUMP header and integrals; - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'enuc' : nuclear repulsion plus frozen core energy; - 'epsilon' : orbital energies; - 'hcore' : core Hamiltonian; - 'eri' : electron-repulsion integrals. :param fname: FCIDUMP file name; """"""; intdump = {}; with open(fname, 'r') as handle:; assert '&FCI' == handle.readline().strip(). skiplines = 1; read = True; while True:; skiplines += 1; line = handle.readline(); if 'END' in line:; break. key, value = line.split('='); value = value.strip().rstrip(','); if key == 'UHF':; value = 'TRUE' in value; elif key == 'ORBSYM':; value = [int(x) for x in value.split(',')]; else:; value = int(value.replace(',', '')). intdump[key.lower()] = value. # Read the data and index, skip header; raw_ints = np.genfromtxt(fname, skip_header=skiplines). # Read last line, i.e. Enuc + Efzc; intdump['enuc'] = raw_ints[-1, 0]. # Read in integrals and indices; ints = raw_ints[:-1, 0]. # Get dimensions and indices; nbf = intdump['norb']; idxs = raw_ints[:, 1:].astype(int) - 1. # Slices; sl = slice(ints.shape[0] - nbf, ints.shape[0]). # Extract orbital energies; epsilon = np.zeros(nbf); epsilon[idxs[sl, 0]] = ints[sl]; intdump['epsilon'] = epsilon. # Count how many 2-index intdump we have; sl = slice(sl.start - nbf * nbf, ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12121,Testability,test,test,12121,"[sl, 0], idxs[sl, 1])] = ints[sl]; Hcore[(idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['hcore'] = Hcore. # Extract ERIs; sl = slice(0, sl.start); eri = np.zeros((nbf, nbf, nbf, nbf)); eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['T",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:12587,Testability,test,test,12587,", 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]def compare_fcidumps(expected, computed, label):; """"""Function to compare two FCIDUMP files. Prints success; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. :returns: a dictionary of energies computed from the MO integrals.; - 'NUCLEAR REPULSION ENERGY' : nuclear repulsion plus frozen core energy; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). compare_integers(True, (pass_1el and pass_2el and pass_scf a",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:15942,Deployability,update,updated,15942,"(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a core.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim). irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). def _dimension_iter(dim):; """"""; Provides an iterator class for the Dimension object. Allows:; dim = psi4.core.Dimension(...); list(dim); """""". for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation; def block_diagonal_array(*args):; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's block_diag.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:4512,Integrability,interface,interface,4512,"e.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:4634,Integrability,interface,interface,4634,". elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix: Union[core.Matrix, core.Vector], copy: bool = True, dense: bool = False) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a Psi4 Matrix or Vector t",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:5137,Integrability,interface,interface,5137,"not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix: Union[core.Matrix, core.Vector], copy: bool = True, dense: bool = False) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; numpy.ndarray; Returns either a list of np.array's or the base array depending on options. Notes;",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:5230,Integrability,interface,interface,5230,"1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix: Union[core.Matrix, core.Vector], copy: bool = True, dense: bool = False) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; numpy.ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:6112,Integrability,depend,depending,6112,"dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix: Union[core.Matrix, core.Vector], copy: bool = True, dense: bool = False) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; numpy.ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in matrix_views:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1,",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:8176,Integrability,interface,interface,8176,"ue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):; """"""; Writes the irreped matrix to a NumPy zipped file. Can return the packed data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:9517,Performance,load,load,9517,"cked data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(self, filename, prefix=""""):; """"""; Reads the data from a NumPy compress file.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:10374,Security,access,accessor,10374,"data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""]))",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:12211,Security,access,accessing,12211,".Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:12282,Security,access,access,12282,"e ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _np",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:1346,Usability,simpl,simple,1346,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; from typing import List, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr: Union[np.ndarray, List[np.ndarray]], name: str = ""New Matrix"", dim1: Union[List, Tuple, core.Dimension] = None, dim2: core.Dimension = None) -> Union[core.Matrix, core.Vector]:; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr; Numpy array or list of ar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:5720,Usability,simpl,simply,5720,"t2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix: Union[core.Matrix, core.Vector], copy: bool = True, dense: bool = False) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; numpy.ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationErr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:8189,Usability,simpl,simply,8189,"ue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):; """"""; Writes the irreped matrix to a NumPy zipped file. Can return the packed data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html:4421,Deployability,update,updated,4421,"2, 1, 0,; 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symbol, Z, basis)). psi4.core.print_out(f"" Running {len(unq_atoms)} free-atom UHF computations""). optstash = optproc.OptionsState([""SCF"", 'REFERENCE']); for a_sym, a_z, basis in unq_atoms:. # make sure we do UHF/UKS if we're not a singlet; if reference_S[a_z] != 0:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); else:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""RHF""). # Set the molecule, here just an atom; a_mol = psi4.core.Molecule.from_arrays(geom=[0, 0, 0],; elem=[a_sym],; molecular_charge=0,; molecular_multiplicity=int(1 + reference_S[a_z])); a_mol.update_geometry(); psi4.molutil.activate(a_mol). method = theory + ""/"" + basis. # Get the atomic wfn; at_e, at_wfn = psi4.energy(method, return_wfn=True). # Now, re-run mbis for the atomic density, grabbing only the volume; psi4.oeprop(at_wfn, 'MBIS_CHARGES', title=a_sym + "" "" + method, free_atom=True). vw = at_wfn.array_variable('MBIS RADIAL MOMENTS <R^3>') # P::e OEPROP; vw = vw.get(0, 0). # set the atomic widths as wfn variables; wfn.set_variable(""MBIS FREE ATOM "" + a_sym.upper() + "" VOLUME"", vw); # set_variable(""MBIS FREE ATOM n VOLUME"") # P::e OEPROP; ; psi4.core.clean(); psi4.core.clean_variables(). # reset mol and reference to original; optstash.restore(); mol.update_geometry(); psi4.molutil.activate(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.prop_util. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html:3643,Energy Efficiency,energy,energy,3643,"2, 1, 0,; 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symbol, Z, basis)). psi4.core.print_out(f"" Running {len(unq_atoms)} free-atom UHF computations""). optstash = optproc.OptionsState([""SCF"", 'REFERENCE']); for a_sym, a_z, basis in unq_atoms:. # make sure we do UHF/UKS if we're not a singlet; if reference_S[a_z] != 0:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); else:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""RHF""). # Set the molecule, here just an atom; a_mol = psi4.core.Molecule.from_arrays(geom=[0, 0, 0],; elem=[a_sym],; molecular_charge=0,; molecular_multiplicity=int(1 + reference_S[a_z])); a_mol.update_geometry(); psi4.molutil.activate(a_mol). method = theory + ""/"" + basis. # Get the atomic wfn; at_e, at_wfn = psi4.energy(method, return_wfn=True). # Now, re-run mbis for the atomic density, grabbing only the volume; psi4.oeprop(at_wfn, 'MBIS_CHARGES', title=a_sym + "" "" + method, free_atom=True). vw = at_wfn.array_variable('MBIS RADIAL MOMENTS <R^3>') # P::e OEPROP; vw = vw.get(0, 0). # set the atomic widths as wfn variables; wfn.set_variable(""MBIS FREE ATOM "" + a_sym.upper() + "" VOLUME"", vw); # set_variable(""MBIS FREE ATOM n VOLUME"") # P::e OEPROP; ; psi4.core.clean(); psi4.core.clean_variables(). # reset mol and reference to original; optstash.restore(); mol.update_geometry(); psi4.molutil.activate(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.prop_util. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html:1698,Integrability,rout,routine,1698,"ill be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with property-related helper functions."""""". import psi4; from . import optproc. __all__ = ['free_atom_volumes']. [docs]def free_atom_volumes(wfn, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn : psi4.core.Wavefunction; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]. # list of reference number of unpaired electrons.; # Note that this is not the same as the; # total spin of the ground state atom; reference_S = [; 0, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0,; 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecu",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html:1469,Modifiability,variab,variables,1469," #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with property-related helper functions."""""". import psi4; from . import optproc. __all__ = ['free_atom_volumes']. [docs]def free_atom_volumes(wfn, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn : psi4.core.Wavefunction; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]. # list of reference number of unpaired electrons.; # Note that this is not the same as the; # total spin of the ground state atom; reference_S = [; 0, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html:3947,Modifiability,variab,variables,3947,"2, 1, 0,; 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symbol, Z, basis)). psi4.core.print_out(f"" Running {len(unq_atoms)} free-atom UHF computations""). optstash = optproc.OptionsState([""SCF"", 'REFERENCE']); for a_sym, a_z, basis in unq_atoms:. # make sure we do UHF/UKS if we're not a singlet; if reference_S[a_z] != 0:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); else:; psi4.core.set_local_option(""SCF"", ""REFERENCE"", ""RHF""). # Set the molecule, here just an atom; a_mol = psi4.core.Molecule.from_arrays(geom=[0, 0, 0],; elem=[a_sym],; molecular_charge=0,; molecular_multiplicity=int(1 + reference_S[a_z])); a_mol.update_geometry(); psi4.molutil.activate(a_mol). method = theory + ""/"" + basis. # Get the atomic wfn; at_e, at_wfn = psi4.energy(method, return_wfn=True). # Now, re-run mbis for the atomic density, grabbing only the volume; psi4.oeprop(at_wfn, 'MBIS_CHARGES', title=a_sym + "" "" + method, free_atom=True). vw = at_wfn.array_variable('MBIS RADIAL MOMENTS <R^3>') # P::e OEPROP; vw = vw.get(0, 0). # set the atomic widths as wfn variables; wfn.set_variable(""MBIS FREE ATOM "" + a_sym.upper() + "" VOLUME"", vw); # set_variable(""MBIS FREE ATOM n VOLUME"") # P::e OEPROP; ; psi4.core.clean(); psi4.core.clean_variables(). # reset mol and reference to original; optstash.restore(); mol.update_geometry(); psi4.molutil.activate(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.prop_util. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/prop_util.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:38767,Deployability,update,updated,38767,"=FutureWarning,; stacklevel=2); return cls.lagrangian(). core.Wavefunction.X = _core_wavefunction_X. ## Psi4 v1.3 Export Deprecations. def _core_get_gradient():; """"""; .. deprecated:: 1.2. """"""; warnings.warn(; ""Using `psi4.core.get_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and in 1.5 (or whenever Py optking is adopted) it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.get_legacy_gradient(). def _core_set_gradient(val):; """"""; .. deprecated:: 1.2. """"""; warnings.warn(; ""Using `psi4.core.set_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and in 1.5 (or whenever Py optking is adopted) it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.set_legacy_gradient(val). core.get_gradient = _core_get_gradient; core.set_gradient = _core_set_gradient. def _core_doublet(A, B, transA, transB):; """"""Multiply two matrices together. .. deprecated:: 1.4; Use :py:func:`psi4.core.doublet` instead. """"""; warnings.warn(; ""Using `psi4.core.Matrix.doublet` instead of `psi4.core.doublet` is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.doublet(A, B, transA, transB). def _core_triplet(A, B, C, transA, transB, transC):; """"""Multiply three matrices together. .. deprecated:: 1.4; Use :py:func:`psi4.core.triplet` instead. """"""; warnings.warn(; ""Using `psi4.core.Matrix.triplet` instead of `psi4.core.triplet` is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.triplet(A, B, C, transA, transB, transC). core.Matrix.doublet = staticmethod(_core_doublet); core.Matrix.triplet = staticmethod(_core_triplet). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.python_helpers. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:9385,Energy Efficiency,energy,energy,9385,"a().to_array() if wfn.epsilon_a() else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'module': wfn.module(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'density_fitted': wfn.density_fitted(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data, allow_pickle=True). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(orbital_basis: core.BasisSet, aux: core.BasisSet = None, jk_type: str = None, do_wK: bool = None, memory: int = None) -> core.JK:; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis; Orbital basis to use in the JK object.; aux; Optional auxiliary basis set for density-fitted tensors. Defaults; to the DF_BASIS_SCF if set, otherwise the correspond JKFI",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:9398,Energy Efficiency,energy,energy,9398," else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'module': wfn.module(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'density_fitted': wfn.density_fitted(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data, allow_pickle=True). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(orbital_basis: core.BasisSet, aux: core.BasisSet = None, jk_type: str = None, do_wK: bool = None, memory: int = None) -> core.JK:; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis; Orbital basis to use in the JK object.; aux; Optional auxiliary basis set for density-fitted tensors. Defaults; to the DF_BASIS_SCF if set, otherwise the correspond JKFIT basis; to the passed in `orbital",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:3022,Integrability,message,message,3022,"orde[target]; return target. # Figure out what exactly was meant by 'target'.; resolved_target = _resolve_target(key, target). # resolved_target needs to be either a string or function for pyconstuct.; # if a string, they search for a gbs file with that name.; # if a function, it needs to apply a basis to each atom. bs, basisdict = qcdb.BasisSet.pyconstruct(mol.to_dict(),; key,; resolved_target,; fitrole,; other,; return_dict=True,; return_atomlist=return_atomlist). if return_atomlist:; atom_basis_list = []; for atbs in basisdict:; atommol = core.Molecule.from_dict(atbs['molecule']); lmbs = core.BasisSet.construct_from_pydict(atommol, atbs, puream); atom_basis_list.append(lmbs); return atom_basis_list; if isinstance(resolved_target, str):; basisdict['name'] = basisdict['name'].split('/')[-1].replace('.gbs', ''); if callable(resolved_target):; basisdict['name'] = resolved_target.__name__.replace('basisspec_psi4_yo__', '').upper(). if not quiet:; core.print_out(basisdict['message']); if 'ECP' in basisdict['message']:; core.print_out(' !!! WARNING: ECP capability is in beta. Please check occupations closely. !!!\n\n'). if basisdict['key'] is None:; basisdict['key'] = 'BASIS'; psibasis = core.BasisSet.construct_from_pydict(mol, basisdict, puream); return psibasis. core.BasisSet.build = _pybuild_basis. ## Python wavefunction helps. @staticmethod; def _core_wavefunction_build(mol, basis=None):; if basis is None:; basis = core.BasisSet.build(mol); elif isinstance(basis, str):; basis = core.BasisSet.build(mol, ""ORBITAL"", basis). wfn = core.Wavefunction(mol, basis); # Set basis for density-fitted calculations to the zero basis...; # ...until the user explicitly provides a DF basis.; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()); return wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be cons",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:3057,Integrability,message,message,3057,"orde[target]; return target. # Figure out what exactly was meant by 'target'.; resolved_target = _resolve_target(key, target). # resolved_target needs to be either a string or function for pyconstuct.; # if a string, they search for a gbs file with that name.; # if a function, it needs to apply a basis to each atom. bs, basisdict = qcdb.BasisSet.pyconstruct(mol.to_dict(),; key,; resolved_target,; fitrole,; other,; return_dict=True,; return_atomlist=return_atomlist). if return_atomlist:; atom_basis_list = []; for atbs in basisdict:; atommol = core.Molecule.from_dict(atbs['molecule']); lmbs = core.BasisSet.construct_from_pydict(atommol, atbs, puream); atom_basis_list.append(lmbs); return atom_basis_list; if isinstance(resolved_target, str):; basisdict['name'] = basisdict['name'].split('/')[-1].replace('.gbs', ''); if callable(resolved_target):; basisdict['name'] = resolved_target.__name__.replace('basisspec_psi4_yo__', '').upper(). if not quiet:; core.print_out(basisdict['message']); if 'ECP' in basisdict['message']:; core.print_out(' !!! WARNING: ECP capability is in beta. Please check occupations closely. !!!\n\n'). if basisdict['key'] is None:; basisdict['key'] = 'BASIS'; psibasis = core.BasisSet.construct_from_pydict(mol, basisdict, puream); return psibasis. core.BasisSet.build = _pybuild_basis. ## Python wavefunction helps. @staticmethod; def _core_wavefunction_build(mol, basis=None):; if basis is None:; basis = core.BasisSet.build(mol); elif isinstance(basis, str):; basis = core.BasisSet.build(mol, ""ORBITAL"", basis). wfn = core.Wavefunction(mol, basis); # Set basis for density-fitted calculations to the zero basis...; # ...until the user explicitly provides a DF basis.; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()); return wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be cons",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:16914,Integrability,message,message,16914," by looking for assign lines, and remove them; leftover_lines = []; assignments = False; for line in command_lines:; if symbol_re.match(line):; m = symbol_re.match(line); mol.set_basis_by_symbol(m.group('symbol'), m.group('basis'), role=role); assignments = True. elif label_re.match(line):; m = label_re.match(line); mol.set_basis_by_label(m.group('label'), m.group('basis'), role=role); assignments = True. elif all_re.match(line):; m = all_re.match(line); mol.set_basis_all_atoms(m.group('basis'), role=role); assignments = True. else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if not assignments:; # case with no [basname] markers where whole block is contents of gbs file; mol.set_basis_all_atoms(name, role=role); basstrings[basname(name)] = basblock[0]; else:; message = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_g",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:17055,Integrability,message,message,17055,"m.group('symbol'), m.group('basis'), role=role); assignments = True. elif label_re.match(line):; m = label_re.match(line); mol.set_basis_by_label(m.group('label'), m.group('basis'), role=role); assignments = True. elif all_re.match(line):; m = all_re.match(line); mol.set_basis_all_atoms(m.group('basis'), role=role); assignments = True. else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if not assignments:; # case with no [basname] markers where whole block is contents of gbs file; mol.set_basis_all_atoms(name, role=role); basstrings[basname(name)] = basblock[0]; else:; message = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # We",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:17772,Integrability,rout,routing,17772,"tents of gbs file; mol.set_basis_all_atoms(name, role=role); basstrings[basname(name)] = basblock[0]; else:; message = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; ""SCSN-MP2 CORRELATION ENERGY"": ""SCS(N)-MP2 CORRELATION ENERGY"",; ""SCSN-MP2 TOTAL ENERGY"": ""SCS(N)-MP2 TOTAL ENERGY"",; ""MAYER_INDICES"": ""MAYER INDICES"",; ""WIBERG_LOWDIN_INDICES"": ""WIBERG LOWDIN INDICES"",; ""LOWDIN_CHARGES"": ""LOWDIN CHARGES"",; ""MULLIKEN_CHARGES"": ""MULLIKEN CHARGES"",; ""(AT) CORRECTION ENERGY"": ""A-(T) CORRECTION ENERG",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:5078,Modifiability,variab,variable,5078,"ame + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not N",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:5919,Modifiability,variab,variables,5919,"file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefuncti",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:6772,Modifiability,variab,variables,6772,"m = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict:; """"""Converts a Wavefunction object to a base class. Parameters; ----------; wfn; A Wavefunction or inherited class; filename; An optional filename to write the data to. Returns; -------; dict; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:7183,Modifiability,inherit,inherited,7183,"tor[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict:; """"""Converts a Wavefunction object to a base class. Parameters; ----------; wfn; A Wavefunction or inherited class; filename; An optional filename to write the data to. Returns; -------; dict; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.lagrangian().to_array() if wfn.lagrangian() else None,; 'aotoso': wfn.aotoso().to_array() if wfn.aotoso() else",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:7370,Modifiability,variab,variables,7370,"None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict:; """"""Converts a Wavefunction object to a base class. Parameters; ----------; wfn; A Wavefunction or inherited class; filename; An optional filename to write the data to. Returns; -------; dict; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.lagrangian().to_array() if wfn.lagrangian() else None,; 'aotoso': wfn.aotoso().to_array() if wfn.aotoso() else None,; 'gradient': wfn.gradient().to_array() if wfn.gradient() else None,; 'hessian': wfn.hessian().to_array() if wfn.hessian() else None; },; 'vector': {; 'epsilon_a': wfn.epsilon_a().to_array() if wfn.epsilon_a() else N",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:25795,Modifiability,variab,variables,25795,"(""2"", 0) + (counter.get(""1"", 0) + counter.get(""2"", 0)) *; (counter.get(""1"", 0) + counter.get(""2"", 0) + 1) / 2). for idx in product(""012"", repeat=order):; xyz_counts = Counter(idx) # ""010"" --> {""0"": 2, ""1"": 1}; np_index = tuple(int(x) for x in idx) # ('0', '1') --> (0, 1). complete[np_index] = compressed[compound_index(xyz_counts)]. return complete. def _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefuncti",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:25836,Modifiability,variab,variables,25836,"""1"", 0) + counter.get(""2"", 0) + 1) / 2). for idx in product(""012"", repeat=order):; xyz_counts = Counter(idx) # ""010"" --> {""0"": 2, ""1"": 1}; np_index = tuple(int(x) for x in idx) # ('0', '1') --> (0, 1). complete[np_index] = compressed[compound_index(xyz_counts)]. return complete. def _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:25960,Modifiability,variab,variables,25960,"dx) # ""010"" --> {""0"": 2, ""1"": 1}; np_index = tuple(int(x) for x in idx) # ('0', '1') --> (0, 1). complete[np_index] = compressed[compound_index(xyz_counts)]. return complete. def _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefu",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26135,Modifiability,variab,variable,26135,"f _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26193,Modifiability,variab,variable,26193," array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array vari",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26263,Modifiability,variab,variable,26263,"e.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an e",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26344,Modifiability,variab,variable,26344,"ction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26720,Modifiability,variab,variable,26720,"---; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26740,Modifiability,variab,variable,26740,"---; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27043,Modifiability,variab,variables,27043,"n with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27084,Modifiability,variab,variables,27084,"-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27208,Modifiability,variab,variables,27208,"rray([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isi",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27408,Modifiability,variab,variable,27408,"37138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27465,Modifiability,variab,variable,27465,"02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scal",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27534,Modifiability,variab,variable,27534,"key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Ta",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27614,Modifiability,variab,variable,27614," return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27999,Modifiability,variab,variable,27999,"Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28019,Modifiability,variab,variable,28019,"Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28340,Modifiability,variab,variable,28340,"adient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28378,Modifiability,variab,variable,28378,"adient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndar",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28557,Modifiability,variab,variable,28557,"rix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28595,Modifiability,variab,variable,28595,"rix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28794,Modifiability,variab,variable,28794,"iable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # T",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28832,Modifiability,variab,variable,28832,"iable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # T",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29240,Modifiability,variab,variable,29240,"s_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scal",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29279,Modifiability,variab,variable,29279,"s_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scal",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29469,Modifiability,variab,variable,29469,"iable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29508,Modifiability,variab,variable,29508,"iable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29718,Modifiability,variab,variable,29718," raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transiti",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29757,Modifiability,variab,variable,29757," raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transiti",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31347,Modifiability,variab,variable,31347,"able(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead o",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31459,Modifiability,variab,variables,31459,"p.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31572,Modifiability,variab,variable,31572,": _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_vari",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31762,Modifiability,variab,variables,31762,"cary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31913,Modifiability,variab,variable,31913,", Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32007,Modifiability,variab,variable,32007,"."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32060,Modifiability,variab,variables,32060,"qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32280,Modifiability,variab,variables,32280,"turn dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2);",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32376,Modifiability,variab,variables,32376,"iable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _cor",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32431,Modifiability,variab,variables,32431,"ore_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_g",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32652,Modifiability,variab,variable,32652,"on_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32752,Modifiability,variab,variable,32752,"variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.c",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32803,Modifiability,variab,variables,32803,"4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar var",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33028,Modifiability,variab,variables,33028,"r_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33130,Modifiability,variab,variables,33130,"ureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` ins",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33183,Modifiability,variab,variables,33183,"riable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `ps",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33621,Modifiability,variab,variable,33621,"4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33741,Modifiability,variab,variable,33741,".variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33807,Modifiability,variab,variables,33807,"only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_v",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34056,Modifiability,variab,variable,34056,"n(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `ps",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34173,Modifiability,variab,variable,34173,"variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; ca",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34237,Modifiability,variab,variables,34237,"g\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variab",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34683,Modifiability,variab,variables,34683,"ion.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.fr",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34932,Modifiability,variab,variables,34932,"(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecate",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:35047,Modifiability,variab,variables,35047,"ariable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:35113,Modifiability,variab,variables,35113,"unction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"""; .. deprec",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:4627,Performance,load,load,4627,"nsity-fitted calculations to the zero basis...; # ...until the user explicitly provides a DF basis.; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()); return wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmoni",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:4728,Performance,load,load,4728,"et.zero_ao_basis_set()); return wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_pu",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:4911,Performance,load,load,4911,"umber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:5003,Performance,load,load,5003,"at files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array =",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:5034,Performance,load,load,5034,"ten and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:35900,Security,access,accessing,35900,"re.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. def _core_wavefunction_X(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.X` instead of `psi4.core.Wavefunction.lagrangian` is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.lagrangian(). core.Wavefunctio",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:36202,Security,access,accessing,36202,"=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. def _core_wavefunction_X(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.X` instead of `psi4.core.Wavefunction.lagrangian` is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.lagrangian(). core.Wavefunction.X = _core_wavefunction_X. ## Psi4 v1.3 Export Deprecations. def _core_get_gradient():; """"""; .. deprecated:: 1.2. """"""; warnings.warn(; ""Using `psi4.core.get_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and in 1.5 (or whenever Py optking is adopted) it ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:15076,Testability,test,test,15076,"ses multiline string *block* to PCMSolver parser. Parameters; ----------; block; multiline string with PCM input in PCMSolver syntax.; """"""; import pcmsolver. with NamedTemporaryFile(mode=""w+t"", delete=True) as fl:; fl.write(block); fl.flush(); parsed_pcm = pcmsolver.parse_pcm_input(fl.name). with NamedTemporaryFile(mode=""w+t"", delete=False) as fl:; fl.write(parsed_pcm); core.set_local_option(""PCM"", ""PCMSOLVER_PARSED_FNAME"", fl.name). def basname(name):; """"""Imitates BasisSet.make_filename() without the gbs extension""""""; return name.lower().replace('+', 'p').replace('*', 's').replace('(', '_').replace(')', '_').replace(',', '_'). [docs]def temp_circular_import_blocker():; pass. [docs]def basis_helper(block, name='', key='BASIS', set_option=True):; """"""For PsiAPI mode, forms a basis specification function from *block*; and associates it with keyword *key* under handle *name*. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; *set_option* is False, *name* will be set as current active *key*,; equivalent to `set key name` or `set_option({key: name})`. """"""; key = key.upper(); name = ('anonymous' + str(uuid.uuid4())[:8]) if name == '' else name; cleanbas = basname(name).replace('-', '') # further remove hyphens so can be function name; block = qcel.util.filter_comments(block); command_lines = re.split('\n', block). symbol_re = re.compile(r'^\s*assign\s+(?P<symbol>[A-Z]{1,3})\s+(?P<basis>[-+*\(\)\w]+)\s*$', re.IGNORECASE); label_re = re.compile(; r'^\s*assign\s+(?P<label>(?P<symbol>[A-Z]{1,3})(?:(_\w+)|(\d+))?)\s+(?P<basis>[-+*\(\)\w]+)\s*$',; re.IGNORECASE); all_re = re.compile(r'^\s*assign\s+(?P<basis>[-+*\(\)\w]+)\s*$', re.IGNORECASE); basislabel = re.compile(r'\s*\[\s*([-*\(\)\w]+)\s*\]\s*'). def anon(mol, role):; basstrings = {}. # Start by looking for assign lines, and remove them; leftover_lines = []; assignments = False; for line in command_lines:; if symbol_re.match(l",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:24034,Testability,assert,assert,24034,"ndex(key.upper().split()[-1])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ). if reshaper:; return val.np.reshape(reshaper); else:; return val. def _multipole_compressor(complete, order):; """"""Form flat unique components multipole array from complete Cartesian array. Parameters; ----------; order : int; Multipole order. e.g., 1 for dipole, 4 for hexadecapole.; complete : ndarray; Multipole array, order-dimensional Cartesian array expanded to complete components. Returns; -------; compressed : ndarray; Multipole array, length (order + 1) * (order + 2) / 2 compressed to unique components. """"""; compressed = []; for ii in range(order + 1):; lx = order - ii; for lz in range(ii + 1):; ly = ii - lz. np_index = []; for xval in range(lx):; np_index.append(0); for yval in range(ly):; np_index.append(1); for zval in range(lz):; np_index.append(2); compressed.append(complete[tuple(np_index)]). assert len(compressed) == ((order + 1) * (order + 2) / 2); return np.array(compressed). def _multipole_plumper(compressed: np.ndarray, order: int) -> np.ndarray:; """"""Form multidimensional multipole array from unique components array. Parameters; ----------; order; Multipole order. e.g., 1 for dipole, 4 for hexadecapole.; compressed; Multipole array, length (order + 1) * (order + 2) / 2 compressed to unique components. Returns; -------; complete : numpy.ndarray; Multipole array, order-dimensional Cartesian array expanded to complete components. """"""; shape = tuple([3] * order); complete = np.zeros(shape). def compound_index(counter):; # thanks, https://www.pamoc.it/tpc_cart_mom.html Eqn 2.2!; # jn = nz + (ny + nz)(ny + nz + 1) / 2; return int(; counter.get(""2"", 0) + (counter.get(""1"", 0) + counter.get(""2"", 0)) *; (counter.get(""1"", 0) + counter.get(""2"", 0) + 1) / 2). for idx in product(""012"", repeat=order):; xyz_counts = Counter(idx) # ""010"" --> {""0"": 2, ""1"": 1}; np_index = tuple(int(x) for x in idx) # ('0', '1') --> (0, 1",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:5652,Availability,error,error,5652,"or; *type* = 1 or one-line height for *type* = 2. If *strNotOutfile*; is True, function returns string rather than printing it; to output file. """"""; lines = text.split('\n'); max_length = 0; for line in lines:; max_length = max(len(line), max_length). max_length = max(width, max_length). null = ''; if type == 1:; banner = ' //' + null.center(max_length, '>') + '//\n'; for line in lines:; banner += ' //' + line.center(max_length) + '//\n'; banner += ' //' + null.center(max_length, '<') + '//\n'. if type == 2:; banner = ''; for line in lines:; banner += (' ' + line + ' ').center(max_length, '='). if strNotOutfile:; return banner; else:; core.print_out(banner). [docs]def print_stdout(stuff):; """"""Function to print *stuff* to standard output stream.""""""; warnings.warn(; ""Using `psi4.driver.p4util.print_stdout` instead of `print` is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stdout). [docs]def print_stderr(stuff):; """"""Function to print *stuff* to standard error stream.""""""; warnings.warn(; ""Using `psi4.driver.p4util.print_stderr` instead of `print(..., file=sys.stderr)` is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def messag",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:7718,Deployability,update,updated,7718,"t will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:6628,Integrability,message,message,6628,"s.warn(; ""Using `psi4.driver.p4util.print_stderr` instead of `print(..., file=sys.stderr)` is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. ©",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:6703,Integrability,message,message,6703,"s.warn(; ""Using `psi4.driver.p4util.print_stderr` instead of `print(..., file=sys.stderr)` is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. ©",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:6775,Integrability,message,message,6775,"d, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sp",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:6784,Integrability,message,message,6784,"d, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sp",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:6902,Integrability,message,message,6902,"t will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:6959,Integrability,wrap,wrap,6959,"t will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:7014,Integrability,message,message,7014,"t will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:7347,Integrability,wrap,wrap,7347,"t will stop working\n"",; category=FutureWarning,; stacklevel=2). print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Compute the Levenshtein distance between two strings."""""". oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1, options, max_distance):; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`."""""". return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]def message_box(message: str = None, max_width: int = 80, min_width: int = 30):; """""" put a message string into a box for extra attention. Parameters; -----------; message; message string to be boxed. max_width; maximal character width of the box. Returns; --------; str; box containing the message as a multiline string; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.text. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html:1323,Modifiability,flexible,flexible,1323," for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility classes and functions related; to data tables and text. """"""; import sys; import warnings. from psi4.driver import constants. from psi4 import core. [docs]class Table(object):; """"""Class defining a flexible Table object for storing data."""""". def __init__(self, rows=(), row_label_width=10, row_label_precision=4, cols=(), width=16, precision=10):; warnings.warn(; ""Using `psi4.driver.p4util.Table` is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); self.row_label_width = row_label_width; self.row_label_precision = row_label_precision; self.width = width; self.precision = precision; self.rows = rows. if isinstance(cols, str):; self.cols = (cols, ); else:; self.cols = cols. self.labels = []; self.data = []. [docs] def format_label(self):; """"""Function to pad the width of Table object labels.""""""; #str = lambda x: (('%%%d.%df' % (self.row_label_width, self.row_label_precision)) % x); str = lambda x: (('%%%ds' % (self.row_label_width)) % x); return "" "".join(map(str, self.labels)). [docs] def format_values(self, values):; """"""Function to pad the width of Table object data cells.""""""; str = lambda x: (('%%%d.%df' % (self.width, self.precision)) % x",MatchSource.WIKI,psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/text.html
